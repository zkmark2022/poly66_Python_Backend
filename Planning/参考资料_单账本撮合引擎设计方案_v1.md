# 预测市场撮合引擎设计方案 v1.0 (单账本)

## Prediction Market Matching Engine Design - Single Order Book

---

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v1.0 |
| 创建日期 | 2025年1月26日 |
| 基于版本 | 双账本撮合引擎设计方案 v4.0 |
| 文档类型 | 技术架构设计 |
| 适用范围 | 预测市场交易系统核心撮合模块 |

---

## 设计原则 (Design Principles)

> **重要**：以下原则是所有设计决策的指导纲领，后续所有修改都必须遵守或依据此原则进行 review。

### 原则一：Exchange Core 优先

尽量保持和 [exchange-core](https://github.com/exchange-core/exchange-core) 已有能力设计一致，减少代码改动量。

**适用范围**：
- 单一订单簿数据结构
- 撮合算法（价格优先、时间优先）
- Maker/Taker 判定逻辑
- 订单生命周期管理
- 部分成交处理
- 单线程 Sequencer 模型

### 原则二：Kalshi 参考

针对预测市场的特殊需求（exchange-core 未覆盖的部分），参考 [Kalshi](https://kalshi.com) 现有规则。

**适用范围**：
- 价格单位和精度（美分制，1-99）
- YES/NO 二元合约模型
- 净额结算（YES+NO 抵消）
- 手续费结构（Maker/Taker 差异化）
- 市场结算和取消规则

### 原则三：预测市场核心约束

```
YES 价格 + NO 价格 = 100 美分 = $1.00
```

所有设计必须保证此恒等式在任何操作后仍然成立。

### 原则四：单账本转换 (Single Order Book Transformation)

所有 NO 操作通过转换层映射到 YES 订单簿：

| 用户操作 | 转换后 | 类型标记 | 前置条件 | 冻结物 |
|---------|--------|---------|---------|--------|
| Buy YES @ P | Buy YES @ P | Native Buy | 有资金 | 资金 P×qty |
| Sell YES @ P | Sell YES @ P | Native Sell | 有 YES 持仓 | YES 持仓 qty |
| Buy NO @ P | Sell YES @ (100-P) | Synthetic Sell | 有资金 | 资金 P×qty |
| Sell NO @ P | Buy YES @ (100-P) | Synthetic Buy | 有 NO 持仓 | NO 持仓 qty |

**优势**：
- 完全对齐 exchange-core 单账本架构
- 简化撮合逻辑，消除"跨账本"概念
- 直接复用 exchange-core 撮合算法

**关键约束**：
- Sell 操作必须持有对应 Token（Native Sell 需持有 YES，Sell NO 需持有 NO）
- 不允许裸卖空

### 原则五：四种撮合场景

根据订单类型组合，撮合结果分为四种：

| 场景 | Buy 侧 | Sell 侧 | Reserve 变化 | 业务本质 |
|------|--------|--------|-------------|---------|
| **Mint (铸造)** | Native Buy | Synthetic Sell | +$1.00 | 创建 YES/NO 合约对 |
| **Transfer YES** | Native Buy | Native Sell | 不变 | YES 持仓转手 |
| **Transfer NO** | Synthetic Buy | Synthetic Sell | 不变 | NO 持仓转手 |
| **Burn (销毁)** | Synthetic Buy | Native Sell | -$1.00 | 销毁 YES/NO 合约对 |

---

## 修改要点计划 (Modification Checklist)

> **重要**：本节列出所有相对于双账本 v4.0 的修改点，按风险等级排序，便于审查和验证。

### 设计决策确认

| 决策点 | 选择 | 说明 |
|--------|------|------|
| 订单簿模式 | **单账本 + 转换层** | 只维护 YES 订单簿，NO 操作通过转换 |
| Maker/Taker 判定 | **时间优先** | 先挂单者为 Maker，享受价格优化收益 |
| 溢价分配 | **全给 Maker** | 差异化策略，激励挂单提供流动性 |
| 净额结算时机 | **账户层自动执行** | 用户同时持有 YES+NO 时自动销毁 |
| 余额冻结 | **按委托价预冻结** | 下单时冻结，成交时多退少补 |
| 卖单持仓 | **预冻结持仓** | 防止超卖，必须持有才能卖 |

### 修改清单（按风险等级）

| 优先级 | 模块 | 修改内容 | 状态 |
|--------|------|---------|------|
| P0 | 资金安全 | 余额冻结原子性、托管一致性、穿仓防护 | ☐ |
| P1 | 撮合正确性 | 单账本撮合、四种场景判定、价格优化 | ☐ |
| P2 | 持仓管理 | 持仓更新、账户层净额结算 | ☐ |
| P3 | 订单管理 | 订单转换层、订单生命周期 | ☐ |
| P4 | 结算清算 | 市场结算流程、盈亏分配 | ☐ |
| P5 | 性能可用性 | WAL日志、故障恢复、性能指标 | ☐ |

---

## 目录

1. [方案概述](#一方案概述)
2. [核心原理](#二核心原理)
3. [P0: 资金安全设计](#三p0-资金安全设计)
4. [P1: 撮合正确性设计](#四p1-撮合正确性设计)
5. [P2: 持仓管理设计](#五p2-持仓管理设计)
6. [P3: 订单管理设计](#六p3-订单管理设计)
7. [P4: 结算清算设计](#七p4-结算清算设计)
8. [P5: 性能与可用性设计](#八p5-性能与可用性设计)
9. [系统约束与不变量](#九系统约束与不变量)
10. [附录](#十附录)

---

## 一、方案概述

### 1.1 系统定位

单账本撮合引擎是预测市场的核心组件，负责：
- 维护单一 YES 订单簿
- 通过订单转换层支持 NO 操作
- 执行四种撮合场景（Mint、Transfer、Burn）
- 保证资金安全和数据一致性
- 支持高并发低延迟交易

### 1.2 设计目标

| 目标 | 指标 | 说明 |
|------|------|------|
| 零风险敞口 | 平台不持仓 | 纯撮合者角色，不参与交易 |
| 资金安全 | 0 穿仓 | 任何情况下用户余额不为负 |
| 高可用 | 99.99% | 年停机 < 52 分钟 |
| 低延迟 | P99 < 10ms | 订单从接收到确认 |
| 高吞吐 | > 10,000 TPS | 单市场峰值处理能力 |
| 强一致性 | 0 数据丢失 | WAL + 事件溯源保证 |

### 1.3 核心架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                        撮合引擎架构总览                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                    API Gateway                               │   │
│   │              鉴权 │ 限流 │ 路由 │ 幂等检查                   │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                   订单转换层 (Order Transformer)              │   │
│   │        Buy NO → Sell YES │ Sell NO → Buy YES                │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                    Sequencer (定序器)                         │   │
│   │         WAL写入 │ 全局序列号 │ 单线程入口                     │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                 内存撮合引擎 (Memory Engine)                   │   │
│   │                                                              │   │
│   │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │   │
│   │  │   余额管理    │  │  YES 订单簿  │  │   持仓管理    │       │   │
│   │  │  (Balance)   │  │ (OrderBook)  │  │  (Position)  │       │   │
│   │  └──────────────┘  └──────────────┘  └──────────────┘       │   │
│   │                                                              │   │
│   │  ┌─────────────────────────────────────────────────────┐    │   │
│   │  │                 撮合算法                              │    │   │
│   │  │    Mint │ Transfer YES │ Transfer NO │ Burn         │    │   │
│   │  └─────────────────────────────────────────────────────┘    │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                ┌───────────────┼───────────────┐                    │
│                ▼               ▼               ▼                    │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐       │
│   │  Event Bus     │  │  账户净额结算   │  │  Market Data   │       │
│   │  (Kafka)       │  │  (Account)     │  │  (WebSocket)   │       │
│   └────────────────┘  └────────────────┘  └────────────────┘       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.4 与双账本方案的主要差异

| 维度 | 双账本方案 (v4) | 单账本方案 (v1) |
|------|----------------|----------------|
| 订单簿结构 | YES/NO 两个独立订单簿 | 单一 YES 订单簿 |
| NO 操作处理 | 直接在 NO 订单簿操作 | 通过转换层映射到 YES |
| 撮合类型 | 同账本撮合、跨账本撮合 | Mint、Transfer、Burn |
| Exchange-core 对齐 | 需扩展支持双账本 | 原生对齐单账本 |
| 复杂度 | 较高（两个订单簿协调） | 较低（单一订单簿） |

---

## 二、核心原理

### 2.1 预测市场数学本质

**核心恒等式**：
```
YES 价格 + NO 价格 = 100 美分 = $1.00
```

**单账本转换关系**：
```
┌─────────────────────────────────────────────────────────────────┐
│                    订单转换等价关系                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户视角                      订单簿视角                        │
│  ──────────                   ────────────                      │
│  Buy YES @ P     ═══════════▶ Buy YES @ P      (Native Buy)    │
│  Sell YES @ P    ═══════════▶ Sell YES @ P     (Native Sell)   │
│  Buy NO @ P      ═══════════▶ Sell YES @ (100-P) (Synthetic Sell)│
│  Sell NO @ P     ═══════════▶ Buy YES @ (100-P)  (Synthetic Buy) │
│                                                                 │
│  数学基础：                                                      │
│  ──────────                                                     │
│  Buy NO @ 35 ≡ Sell YES @ 65  (因为 100 - 35 = 65)             │
│  Sell NO @ 40 ≡ Buy YES @ 60  (因为 100 - 40 = 60)             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**示例**：
```
YES 价格 = 65 美分 → NO 价格 = 35 美分

用户 A: Buy YES @ 65   → 订单簿: Buy YES @ 65 (Native)
用户 B: Buy NO @ 35    → 订单簿: Sell YES @ 65 (Synthetic)

两者可以撮合 → Mint 场景（创建合约对）
```

### 2.2 单账本订单簿模式

每个市场维护**单一 YES 订单簿**，NO 操作通过转换层映射：

```
┌─────────────────────────────────────────────────────────────────┐
│                      单账本订单簿结构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户操作                    订单转换层                           │
│  ──────────                 ────────────                        │
│  Buy YES @ 65  ─────────────────────────────▶ Buy YES @ 65 (N) │
│  Sell YES @ 67 ─────────────────────────────▶ Sell YES @ 67 (N)│
│  Buy NO @ 35   ──── 转换 ───────────────────▶ Sell YES @ 65 (S)│
│  Sell NO @ 33  ──── 转换 ───────────────────▶ Buy YES @ 67 (S) │
│                                                                 │
│                         ┌─────────────────────────┐             │
│                         │      YES 订单簿          │             │
│                         ├────────────┬────────────┤             │
│                         │  Buy 队列   │  Sell 队列  │             │
│                         ├────────────┼────────────┤             │
│                         │  67×100(S) │  65×80 (S) │             │
│                         │  65×100(N) │  67×50 (N) │             │
│                         │  64×200(N) │  68×80 (N) │             │
│                         └────────────┴────────────┘             │
│                                                                 │
│  标记: (N) = Native 原生订单                                     │
│        (S) = Synthetic 合成订单 (来自 NO 转换)                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 四种撮合场景详解

根据 Buy 侧和 Sell 侧的订单类型（Native/Synthetic），撮合结果分为四种：

```
┌─────────────────────────────────────────────────────────────────┐
│                      四种撮合场景                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 场景 1: Mint (铸造)                                      │   │
│  │ ─────────────────────                                    │   │
│  │ Buy 侧: Native Buy (Buy YES)                             │   │
│  │ Sell 侧: Synthetic Sell (Buy NO → Sell YES)              │   │
│  │                                                          │   │
│  │ Reserve: +$1.00 (双方资金进入托管)                        │   │
│  │ Token: 新铸 YES → Native 方, 新铸 NO → Synthetic 方       │   │
│  │ 资金流: 双方 → Reserve                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 场景 2: Transfer YES (YES 转手)                          │   │
│  │ ─────────────────────────────                            │   │
│  │ Buy 侧: Native Buy (Buy YES)                             │   │
│  │ Sell 侧: Native Sell (Sell YES)                          │   │
│  │                                                          │   │
│  │ Reserve: 不变                                            │   │
│  │ Token: YES 从卖方转移到买方                               │   │
│  │ 资金流: 买方 → 卖方                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 场景 3: Transfer NO (NO 转手)                            │   │
│  │ ───────────────────────────                              │   │
│  │ Buy 侧: Synthetic Buy (Sell NO → Buy YES)                │   │
│  │ Sell 侧: Synthetic Sell (Buy NO → Sell YES)              │   │
│  │                                                          │   │
│  │ Reserve: 不变 (内部 Mint+Burn 抵消)                       │   │
│  │ Token: NO 从 Synthetic Buy 方转移到 Synthetic Sell 方     │   │
│  │ 资金流: Synthetic Sell 方 → Synthetic Buy 方              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 场景 4: Burn (销毁)                                      │   │
│  │ ─────────────────                                        │   │
│  │ Buy 侧: Synthetic Buy (Sell NO → Buy YES)                │   │
│  │ Sell 侧: Native Sell (Sell YES)                          │   │
│  │                                                          │   │
│  │ Reserve: -$1.00 (托管释放资金)                            │   │
│  │ Token: YES + NO 销毁                                     │   │
│  │ 资金流: Reserve → 双方 (按成交价分配)                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 全链路整数化

**核心原则**：系统内部禁止使用浮点数，所有金额和价格统一采用整数表示。

> **对齐 Kalshi**：采用美分 (Cent) 作为基本单位，与 Kalshi 实际精度一致。

| 概念 | 存储单位 | 换算关系 | 示例 |
|------|---------|---------|------|
| 价格 | 美分 (Cent) | 100 美分 = $1.00 | 65 美分 = $0.65 |
| 金额 | 美分 | 100 美分 = $1.00 | 6500 美分 = $65.00 |
| 份数 | 整数 | 1 份 = 1 份合约 | 100 份 |

**价格范围**：
- YES 价格：1 ~ 99 美分（$0.01 ~ $0.99）
- NO 价格：1 ~ 99 美分（$0.01 ~ $0.99）
- 约束：YES 价格 + NO 价格 = 100 美分 = $1.00

**数据类型**：
- 价格：`int8` 或 `int32` (范围 1-99)
- 金额：`int64` (支持大额交易，单位：美分)
- 份数：`int64` (支持大量持仓)

**换算示例**：
```
买 100 份 YES @ 65 美分
冻结金额 = 65 × 100 = 6500 美分 = $65.00

Mint 撮合条件：
Native Buy YES @ 65 + Synthetic Sell YES @ 65 (来自 Buy NO @ 35)
= 65 + 35 = 100 ✓ (可撮合，创建合约对)
```

---

## 三、P0: 资金安全设计

> **风险等级**：最高 (P0)
> **设计目标**：确保任何情况下用户余额不为负，托管资金与合约数量严格匹配

### 3.1 账户模型

> **设计对齐**: 与 [exchange-core](https://github.com/exchange-core/exchange-core) 的 `UserProfile` 和 `SymbolPositionRecord` 结构对齐

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户账户结构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  User Account (对应 exchange-core UserProfile)                  │
│  ├── user_id: long                 // 用户唯一标识 (uid)         │
│  ├── available_balance: int64      // 可用余额（美分）           │
│  ├── frozen_balance: int64         // 冻结余额（美分）           │
│  └── positions: Map<market_id, PositionRecord>                  │
│                                                                 │
│  PositionRecord (对应 exchange-core SymbolPositionRecord)       │
│  ├── yes_volume: int64             // YES 持仓份数 (openVolume) │
│  ├── yes_cost_sum: int64           // YES 累计成本 (openPriceSum)│
│  ├── yes_pending_sell: int64       // YES 卖单冻结 (pendingSellSize)│
│  ├── no_volume: int64              // NO 持仓份数              │
│  ├── no_cost_sum: int64            // NO 累计成本              │
│  └── no_pending_sell: int64        // NO 卖单冻结              │
│                                                                 │
│  计算属性（需要时计算，不存储）：                                  │
│  ├── yes_avg_cost = yes_cost_sum / yes_volume                  │
│  └── no_avg_cost = no_cost_sum / no_volume                     │
│                                                                 │
│  约束条件：                                                      │
│  ① available_balance ≥ 0                                       │
│  ② frozen_balance ≥ 0                                          │
│  ③ yes_volume ≥ yes_pending_sell ≥ 0                           │
│  ④ no_volume ≥ no_pending_sell ≥ 0                             │
│  ⑤ yes_cost_sum ≥ 0, no_cost_sum ≥ 0                           │
│                                                                 │
│  设计说明：                                                      │
│  ─────────                                                      │
│  使用 cost_sum（累计成本）而非 avg_cost（平均成本）的原因：        │
│  • 避免整数除法精度丢失                                          │
│  • 与 exchange-core 的 openPriceSum 字段对齐                    │
│  • 市场取消时可精确计算退款                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 余额冻结机制

**策略**：按委托价预冻结

#### 3.2.1 四种订单类型的冻结规则

| 订单类型 | 用户操作 | 转换后 | 冻结物 | 校验条件 |
|---------|---------|--------|--------|---------|
| Native Buy | Buy YES @ P | Buy YES @ P | 资金 P×qty | available_balance ≥ P×qty |
| Native Sell | Sell YES @ P | Sell YES @ P | YES 持仓 qty | yes_volume - yes_pending_sell ≥ qty |
| Synthetic Sell | Buy NO @ P | Sell YES @ (100-P) | 资金 P×qty | available_balance ≥ P×qty |
| Synthetic Buy | Sell NO @ P | Buy YES @ (100-P) | NO 持仓 qty | no_volume - no_pending_sell ≥ qty |

> **关键约束**：Sell 操作必须持有对应 Token，不允许裸卖空

#### 3.2.2 Native Buy 冻结

```
Native Buy YES 下单时：
──────────────────────
输入: Buy YES @ 65 美分 × 100 份
冻结金额 = price × quantity = 65 × 100 = 6500 美分 = $65.00

操作（原子）:
  IF available_balance >= 6500 THEN
    available_balance -= 6500
    frozen_balance += 6500
    创建订单 (order_type = NATIVE_BUY)
  ELSE
    拒绝订单，余额不足
  END
```

#### 3.2.3 Native Sell 冻结

```
Native Sell YES 下单时：
───────────────────────
输入: Sell YES @ 67 美分 × 50 份
冻结持仓 = quantity = 50 份

操作（原子）:
  可用持仓 = yes_volume - yes_pending_sell
  IF 可用持仓 >= 50 THEN
    yes_pending_sell += 50
    创建订单 (order_type = NATIVE_SELL)
  ELSE
    拒绝订单，YES 持仓不足
  END
```

#### 3.2.4 Synthetic Sell 冻结 (Buy NO)

```
Buy NO 下单时（转换为 Synthetic Sell YES）：
──────────────────────────────────────────
输入: Buy NO @ 35 美分 × 100 份
转换: Sell YES @ 65 美分 × 100 份
冻结金额 = NO价格 × quantity = 35 × 100 = 3500 美分 = $35.00

操作（原子）:
  IF available_balance >= 3500 THEN
    available_balance -= 3500
    frozen_balance += 3500
    创建订单 (order_type = SYNTHETIC_SELL, original_price = 35)
  ELSE
    拒绝订单，余额不足
  END

注意: 冻结的是 NO 价格 (35 美分)，不是转换后的 YES 价格 (65 美分)
```

#### 3.2.5 Synthetic Buy 冻结 (Sell NO)

```
Sell NO 下单时（转换为 Synthetic Buy YES）：
──────────────────────────────────────────
输入: Sell NO @ 40 美分 × 50 份
转换: Buy YES @ 60 美分 × 50 份
冻结持仓 = quantity = 50 份

操作（原子）:
  可用持仓 = no_volume - no_pending_sell
  IF 可用持仓 >= 50 THEN
    no_pending_sell += 50
    创建订单 (order_type = SYNTHETIC_BUY, original_price = 40)
  ELSE
    拒绝订单，NO 持仓不足
  END

注意: 冻结的是 NO 持仓，不是资金
```

#### 3.2.6 成交时余额调整

成交时的余额调整取决于撮合场景：

```
┌─────────────────────────────────────────────────────────────────┐
│                    成交时余额调整（按场景）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Mint (Native Buy + Synthetic Sell):                           │
│  ─────────────────────────────────────                          │
│  Native Buy 方:                                                 │
│    冻结金额 = yes_price × qty                                   │
│    实际支付 = trade_price × qty (进入 Reserve)                  │
│    退还 = 冻结金额 - 实际支付 (若有差额)                          │
│                                                                 │
│  Synthetic Sell 方 (Buy NO):                                    │
│    冻结金额 = no_price × qty                                    │
│    实际支付 = (100 - trade_price) × qty (进入 Reserve)          │
│    退还 = 冻结金额 - 实际支付 (若有差额)                          │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Transfer YES (Native Buy + Native Sell):                       │
│  ────────────────────────────────────────                       │
│  Native Buy 方:                                                 │
│    冻结金额 = buy_price × qty                                   │
│    实际支付 = trade_price × qty (给卖方)                        │
│    退还 = 冻结金额 - 实际支付                                    │
│                                                                 │
│  Native Sell 方:                                                │
│    冻结持仓释放: yes_pending_sell -= qty                        │
│    持仓扣减: yes_volume -= qty                                  │
│    收入: trade_price × qty                                      │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Transfer NO (Synthetic Buy + Synthetic Sell):                  │
│  ─────────────────────────────────────────────                  │
│  Synthetic Buy 方 (Sell NO):                                    │
│    冻结持仓释放: no_pending_sell -= qty                         │
│    持仓扣减: no_volume -= qty                                   │
│    收入: no_price × qty                                         │
│                                                                 │
│  Synthetic Sell 方 (Buy NO):                                    │
│    冻结金额 = no_price × qty                                    │
│    实际支付 = no_price × qty (给对方)                           │
│    获得持仓: no_volume += qty                                   │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Burn (Synthetic Buy + Native Sell):                            │
│  ───────────────────────────────────                            │
│  Synthetic Buy 方 (Sell NO):                                    │
│    冻结持仓释放: no_pending_sell -= qty                         │
│    持仓扣减: no_volume -= qty                                   │
│    收入: (100 - trade_price) × qty (从 Reserve)                │
│                                                                 │
│  Native Sell 方:                                                │
│    冻结持仓释放: yes_pending_sell -= qty                        │
│    持仓扣减: yes_volume -= qty                                  │
│    收入: trade_price × qty (从 Reserve)                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 托管账户设计

> **设计依据**:
> - `pnl_pool` 字段参考 exchange-core 的资金追踪机制
> - 与 `cost_sum` 配合，保证恒等式始终成立

```
┌─────────────────────────────────────────────────────────────────┐
│                        市场托管账户 (Reserve)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Market Reserve                                                 │
│  ├── market_id: string                                          │
│  ├── reserve_balance: int64    // 托管余额（美分）              │
│  ├── pnl_pool: int64           // 盈亏池（美分，可正可负）       │
│  ├── total_yes_shares: int64   // YES 总份数                    │
│  └── total_no_shares: int64    // NO 总份数                     │
│                                                                 │
│  核心不变量（任何时刻必须成立）：                                  │
│  ───────────────────────────────                                │
│  ① total_yes_shares == total_no_shares                         │
│  ② reserve_balance == total_yes_shares × 100                   │
│  ③ reserve_balance + pnl_pool                                  │
│       == Σ(user.yes_cost_sum) + Σ(user.no_cost_sum)            │
│                                                                 │
│  pnl_pool 说明：                                                 │
│  ───────────────                                                │
│  • 追踪 Transfer 交易产生的盈亏流动                              │
│  • 正值: 累计亏损流入（卖家亏损）                                 │
│  • 负值: 累计利润流出（卖家盈利）                                 │
│  • 市场取消时用于精确退款                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.3.1 四种场景的 Reserve 变化

```
┌─────────────────────────────────────────────────────────────────┐
│                    Reserve 变化（按场景）                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景 1: Mint (铸造)                                            │
│  ─────────────────────                                          │
│  Reserve 变化: +$1.00 (100 美分)                                │
│  YES 份数: +1                                                   │
│  NO 份数: +1                                                    │
│                                                                 │
│  资金来源:                                                       │
│    Native Buy 方支付: P_yes 美分                                │
│    Synthetic Sell 方支付: P_no 美分 (100 - P_yes)              │
│    合计: P_yes + P_no = 100 美分                               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  场景 2: Transfer YES (YES 转手)                                │
│  ───────────────────────────────                                │
│  Reserve 变化: 不变                                             │
│  YES 份数: 不变                                                 │
│  NO 份数: 不变                                                  │
│  pnl_pool 变化: -(卖方收入 - 卖方成本) = -seller_pnl           │
│                                                                 │
│  资金流动:                                                       │
│    买方 → 卖方 (直接转账，不经 Reserve)                         │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  场景 3: Transfer NO (NO 转手)                                  │
│  ─────────────────────────────                                  │
│  Reserve 变化: 不变 (内部 Mint + Burn 抵消)                     │
│  YES 份数: 不变                                                 │
│  NO 份数: 不变                                                  │
│  pnl_pool 变化: -(卖方收入 - 卖方成本) = -seller_pnl           │
│                                                                 │
│  资金流动:                                                       │
│    NO 买方 → NO 卖方 (直接转账)                                 │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  场景 4: Burn (销毁)                                            │
│  ─────────────────                                              │
│  Reserve 变化: -$1.00 (100 美分)                                │
│  YES 份数: -1                                                   │
│  NO 份数: -1                                                    │
│                                                                 │
│  资金去向:                                                       │
│    Native Sell 方收到: P_yes 美分                               │
│    Synthetic Buy 方收到: P_no 美分 (100 - P_yes)               │
│    合计: P_yes + P_no = 100 美分                               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  场景 5: 账户层净额结算 (Auto-Netting)                          │
│  ─────────────────────────────────────                          │
│  触发: 同一用户同时持有 YES 和 NO                               │
│  Reserve 变化: -$1.00 (100 美分)                                │
│  YES 份数: -1                                                   │
│  NO 份数: -1                                                    │
│  pnl_pool 变化: release_amount - cost_released                 │
│                                                                 │
│  资金去向:                                                       │
│    用户收到: 100 美分 (固定，无论原始成本)                      │
│                                                                 │
│  pnl_pool 调整说明:                                             │
│    release_amount = 100 美分 (每对合约固定释放)                 │
│    cost_released = yes_cost + no_cost (用户实际成本)           │
│    pnl_adjustment = release_amount - cost_released             │
│                                                                 │
│  示例:                                                          │
│    用户 YES 成本 65 美分 + NO 成本 40 美分 = 105 美分           │
│    释放 100 美分，pnl_adjustment = 100 - 105 = -5              │
│    pnl_pool -= (-5) → pnl_pool += 5                            │
│    (用户通过低价买入 NO 获得的 5 美分利润，留在 pnl_pool 中)   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.3.2 pnl_pool 资金流转示例

```
┌─────────────────────────────────────────────────────────────────┐
│                    pnl_pool 资金流转示例                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初始状态: reserve=0, pnl_pool=0                                │
│                                                                 │
│  T1: Mint - A (Buy YES @ 60), B (Buy NO @ 40), 各 100 份        │
│  ─────────────────────────────────────────────────────          │
│  A.yes_cost_sum = 6000 美分 ($60.00)                           │
│  B.no_cost_sum = 4000 美分 ($40.00)                            │
│  reserve_balance = 10000 美分 ($100.00)                        │
│  pnl_pool = 0                                                  │
│  验证: 10000 + 0 = 6000 + 4000 ✓                               │
│                                                                 │
│  T2: Transfer YES - C (Buy YES @ 65) 从 A (Sell YES @ 65), 50份 │
│  ─────────────────────────────────────────────────────          │
│  A 卖出成本: 50 × 60 = 3000 美分                                │
│  A 卖出收入: 50 × 65 = 3250 美分                                │
│  A 利润: 250 美分 ($2.50) (流出系统)                             │
│                                                                 │
│  A.yes_cost_sum = 6000 - 3000 = 3000 美分                      │
│  C.yes_cost_sum = 50 × 65 = 3250 美分                          │
│  reserve_balance = 10000 美分 (不变)                           │
│  pnl_pool = 0 - 250 = -250 美分                                │
│                                                                 │
│  验证: reserve(10000) + pnl(-250)                              │
│        = A.yes(3000) + C.yes(3250) + B.no(4000)                │
│        = 9750 美分 ✓                                            │
│                                                                 │
│  T3: Burn - B (Sell NO @ 35) 与 D (Sell YES @ 65), 50 份        │
│  ─────────────────────────────────────────────────────          │
│  B 收到: 50 × 35 = 1750 美分 (从 Reserve)                      │
│  D 收到: 50 × 65 = 3250 美分 (从 Reserve)                      │
│  合计从 Reserve 释放: 1750 + 3250 = 5000 美分                  │
│                                                                 │
│  reserve_balance = 10000 - 5000 = 5000 美分                    │
│  total_yes_shares = 100 - 50 = 50                              │
│  total_no_shares = 100 - 50 = 50                               │
│  验证: reserve(5000) = 50 × 100 ✓                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 穿仓防护机制

#### 3.4.1 多重检查点

```
防护层级：
─────────

Layer 1: API 网关层
  └── 基础参数校验、限流

Layer 2: 下单预检层
  └── 余额/持仓充足性检查
  └── 冻结操作（原子）

Layer 3: 撮合引擎层
  └── 成交前二次校验
  └── 原子化成交处理

Layer 4: 事后校验层
  └── 每笔成交后验证不变量
  └── 异常立即熔断
```

#### 3.4.2 原子操作保证

```python
# 伪代码：原子化余额操作
def atomic_freeze(user_id: str, amount: int64) -> bool:
    """
    使用 Redis Lua 脚本或数据库事务保证原子性
    """
    script = """
    local available = redis.call('HGET', KEYS[1], 'available')
    if tonumber(available) >= tonumber(ARGV[1]) then
        redis.call('HINCRBY', KEYS[1], 'available', -ARGV[1])
        redis.call('HINCRBY', KEYS[1], 'frozen', ARGV[1])
        return 1
    else
        return 0
    end
    """
    return redis.eval(script, keys=[f"balance:{user_id}"], args=[amount])
```

#### 3.4.3 多层价格校验

> 针对 Mint 场景的价格边界校验

**校验层级**：

```
多层价格防御架构：
─────────────────

Layer 1: 订单创建时校验 (API 层)
  ├── 校验点: OrderService.createOrder()
  ├── 规则: 1 <= price <= 99
  └── 失败处理: 拒绝订单，返回 INVALID_PRICE 错误

Layer 2: 撮合前校验 (撮合引擎入口)
  ├── 校验点: match_order() 入口
  ├── 规则: assert 1 <= order.book_price <= 99
  └── 失败处理: 记录异常日志，触发告警

Layer 3: Mint 撮合校验 (成交前)
  ├── 校验点: execute_mint_trade() 内部
  ├── 规则:
  │     assert native_buy.price + synthetic_sell.original_price == 100
  └── 失败处理: 触发熔断，详见 8.6 节

Layer 4: 事后校验 (成交后)
  ├── 校验点: verify_trade_invariants()
  ├── 规则: 校验成交记录中所有价格在合法范围
  └── 失败处理: 触发熔断，人工审核
```

### 3.5 资金流转状态机

```
┌─────────────────────────────────────────────────────────────────┐
│                      资金状态流转图                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                        ┌─────────┐                              │
│                        │  可用   │                              │
│                        │Available│                              │
│                        └────┬────┘                              │
│                             │                                   │
│              下单冻结 ──────┼────── 订单取消解冻                  │
│                             ▼                                   │
│                        ┌─────────┐                              │
│                        │  冻结   │                              │
│                        │ Frozen  │                              │
│                        └────┬────┘                              │
│                             │                                   │
│     ┌───────────────────────┼───────────────────────┐           │
│     ▼                       ▼                       ▼           │
│ ┌────────┐            ┌────────┐              ┌────────┐       │
│ │  Mint  │            │Transfer│              │  Burn  │       │
│ │ (铸造) │            │ (转让) │              │ (销毁) │       │
│ └───┬────┘            └───┬────┘              └───┬────┘       │
│     │                     │                       │             │
│     ▼                     ▼                       ▼             │
│ ┌────────┐            ┌────────┐              ┌────────┐       │
│ │进Reserve│           │给对手方│              │从Reserve│      │
│ │+$1.00  │            │(直接)  │              │释放-$1 │       │
│ └───┬────┘            └───┬────┘              └───┬────┘       │
│     │                     │                       │             │
│     └─────────────────────┴───────────────────────┘             │
│                             │                                   │
│                             ▼                                   │
│                    ┌──────────────────┐                         │
│                    │  扣除手续费 → 平台  │                         │
│                    │  (Taker/Maker Fee) │                         │
│                    └──────────────────┘                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.6 手续费设计

> **参考**: Kalshi 手续费模型，对齐 exchange-core 实现

#### 3.6.1 手续费规则总览

| 规则 | 内容 | 说明 |
|------|------|------|
| 收取时机 | **成交时收取** | 对齐 exchange-core `handleMatcherEventTrade` |
| 费率结构 | **Maker/Taker 差异化** | 激励挂单提供流动性 |
| 计费基础 | **用户实际支付/收取金额** | Native 用 YES 价格，Synthetic 用 NO 价格 |
| 结算费 | **无** | 参考 Kalshi "no settlement fee" |
| 市场取消 | **不退已收手续费** | 交易已发生，服务已提供 |
| 账户净额结算 | **不收费** | 系统自动操作，非用户主动交易 |

> **重要**: Synthetic 订单（Buy NO / Sell NO）的手续费必须基于 **NO 价格**（用户实际支付/收取的金额），而非转换后的 YES 价格。否则深虚值 NO 交易（如 Buy NO @ $0.01）的手续费会接近甚至超过本金，杀死低价合约的流动性。

#### 3.6.2 平台账户结构

```
Platform Account (全局)
├── fee_balance: int64              // 累计手续费余额
├── fee_by_currency: Map<int, int64>  // 按币种分类 (对齐 exchange-core)
└── risk_reserve_balance: int64     // 风险准备金余额

Market Fee Config (每市场可配置)
├── taker_fee_rate: int32        // Taker 费率 (万分比, 如 10 = 0.1%)
├── maker_fee_rate: int32        // Maker 费率 (万分比, 如 5 = 0.05%)
└── fee_enabled: bool            // 是否启用手续费

风险准备金说明 (risk_reserve_balance):
───────────────────────────────────────
• 来源: 市场取消时的整数除法舍入误差
• 用途: 吸收系统内部精度误差，不转嫁给用户
• 监控: 若单次超过阈值触发告警，人工审核
```

#### 3.6.3 手续费计算公式

```python
def calculate_fee(trade_value: int, fee_rate: int) -> int:
    """
    基础手续费计算（向上取整）

    Args:
        trade_value: 成交金额（美分）
        fee_rate: 费率 (万分比, 如 10 = 0.1%)

    Returns:
        手续费金额（美分）(向上取整，保证平台不亏)
    """
    fee = (trade_value * fee_rate + 9999) // 10000
    return fee


def get_fee_trade_value(order: Order, trade_price: int, qty: int) -> int:
    """
    根据订单类型获取正确的手续费计算基础

    关键原则: 手续费基于用户实际支付/收取的金额
    - Native 订单: 使用 YES 价格（trade_price）
    - Synthetic 订单: 使用 NO 价格（用户实际支付/收取的金额）

    Args:
        order: 订单对象
        trade_price: YES 视角的成交价（美分）
        qty: 成交数量

    Returns:
        手续费计算基础金额（美分）
    """
    if order.order_type == OrderType.NATIVE_BUY:
        # Buy YES: 用户支付 YES 价格
        return trade_price * qty

    elif order.order_type == OrderType.NATIVE_SELL:
        # Sell YES: 用户收取 YES 价格
        return trade_price * qty

    elif order.order_type == OrderType.SYNTHETIC_SELL:
        # Buy NO: 用户支付 NO 价格 = original_price
        # 注意: 不能用 (100 - trade_price)，因为成交价可能经过优化
        # 必须用 original_price，这是用户实际愿意支付的价格
        return order.original_price * qty

    elif order.order_type == OrderType.SYNTHETIC_BUY:
        # Sell NO: 用户收取 NO 价格 = 100 - trade_price
        no_price = 100 - trade_price
        return no_price * qty

    raise ValueError(f"Unknown order type: {order.order_type}")


def calculate_order_fee(order: Order, trade_price: int, qty: int,
                        fee_rate: int) -> int:
    """
    计算订单手续费（完整流程）

    示例 1 - Native Buy:
        Buy YES @ 65 × 100份
        trade_value = 65 × 100 = 6500 美分
        fee = (6500 × 10 + 9999) // 10000 = 7 美分

    示例 2 - Synthetic Sell (Buy NO @ $0.01):
        Buy NO @ 1 × 100份
        trade_value = 1 × 100 = 100 美分 (使用 NO 价格!)
        fee = (100 × 10 + 9999) // 10000 = 1 美分
        (而非按 YES 价格 99 美分计算，否则 fee ≈ 10 美分，费率 1000%!)
    """
    trade_value = get_fee_trade_value(order, trade_price, qty)
    return calculate_fee(trade_value, fee_rate)
```

#### 3.6.4 四种场景的手续费收取

> **核心原则**: 使用 `calculate_order_fee(order, trade_price, qty, fee_rate)` 自动根据订单类型选择正确的计费基础

```
┌─────────────────────────────────────────────────────────────────┐
│                    手续费收取（按场景）                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Mint (Native Buy + Synthetic Sell):                           │
│  ─────────────────────────────────────                          │
│  Native Buy 方:                                                 │
│    trade_value = yes_price × qty (用户实际支付)                │
│    fee = calculate_order_fee(buy_order, trade_price, qty, rate)│
│                                                                 │
│  Synthetic Sell 方 (Buy NO):                                   │
│    trade_value = original_price × qty (NO价格，用户实际支付)   │
│    fee = calculate_order_fee(sell_order, trade_price, qty,rate)│
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Transfer YES (Native Buy + Native Sell):                       │
│  ────────────────────────────────────────                       │
│  双方都是 Native 订单，直接使用 trade_price:                    │
│    buy_fee = calculate_order_fee(buy, trade_price, qty, rate)  │
│    sell_fee = calculate_order_fee(sell, trade_price, qty, rate)│
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Transfer NO (Synthetic Buy + Synthetic Sell):                  │
│  ─────────────────────────────────────────────                  │
│  双方都是 Synthetic 订单，使用 NO 价格:                         │
│    Synthetic Buy (Sell NO): trade_value = (100-trade_price)×qty│
│    Synthetic Sell (Buy NO): trade_value = original_price × qty │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Burn (Synthetic Buy + Native Sell):                            │
│  ───────────────────────────────────                            │
│  Synthetic Buy 方 (Sell NO):                                    │
│    trade_value = (100 - trade_price) × qty (NO价格)            │
│    fee = calculate_order_fee(buy, trade_price, qty, rate)      │
│                                                                 │
│  Native Sell 方 (Sell YES):                                     │
│    trade_value = trade_price × qty (YES价格)                   │
│    fee = calculate_order_fee(sell, trade_price, qty, rate)     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

深虚值 NO 手续费对比示例:
───────────────────────────
Buy NO @ $0.01 (1美分) × 100份

❌ 错误做法 (按转换后的 YES 价格):
   trade_value = 99 × 100 = 9900 美分
   fee (1%) = 99 美分
   实际费率 = 99 / 1 = 9900%！

✅ 正确做法 (按 NO 价格):
   trade_value = 1 × 100 = 100 美分
   fee (1%) = 1 美分
   实际费率 = 1%
```

#### 3.6.5 全局手续费校验

```python
def verify_fee_invariant() -> bool:
    """
    手续费守恒校验

    全局恒等式:
    Σ(用户余额) + Σ(托管余额) + Σ(手续费) == Σ(充值) - Σ(提现)
    """
    total_user = sum(u.available + u.frozen for u in all_users())
    total_reserve = sum(m.reserve_balance for m in all_markets())
    total_fees = platform_fee_account.fee_balance

    net_deposits = total_deposits() - total_withdrawals()

    assert total_user + total_reserve + total_fees == net_deposits, \
        f"Global balance mismatch"

    return True
```

---

## 四、P1: 撮合正确性设计

> **风险等级**：高 (P1)
> **设计目标**：确保撮合算法正确，价格公平，场景判定准确

### 4.1 撮合类型概述

单账本撮合根据 Buy 侧和 Sell 侧的订单类型（Native/Synthetic），分为四种场景：

| 场景 | Buy 侧订单类型 | Sell 侧订单类型 | Reserve 变化 | 业务本质 |
|------|--------------|----------------|-------------|---------|
| **Mint** | Native Buy | Synthetic Sell | +$1.00 | 创建合约对 |
| **Transfer YES** | Native Buy | Native Sell | 不变 | YES 持仓转让 |
| **Transfer NO** | Synthetic Buy | Synthetic Sell | 不变 | NO 持仓转让 |
| **Burn** | Synthetic Buy | Native Sell | -$1.00 | 销毁合约对 |

> **对比双账本**：原双账本设计使用"同账本撮合"和"跨账本撮合"两种类型。单账本设计将这两种重新分类为四种场景，逻辑更清晰。

```
┌─────────────────────────────────────────────────────────────────┐
│                    场景判定矩阵                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                        Sell 侧                                  │
│                  ┌────────────┬────────────┐                   │
│                  │   Native   │  Synthetic │                   │
│                  │ (Sell YES) │ (Buy NO)   │                   │
│        ┌─────────┼────────────┼────────────┤                   │
│   Buy  │ Native  │  Transfer  │    Mint    │                   │
│   侧   │(Buy YES)│    YES     │   (铸造)   │                   │
│        ├─────────┼────────────┼────────────┤                   │
│        │Synthetic│    Burn    │  Transfer  │                   │
│        │(Sell NO)│   (销毁)   │     NO     │                   │
│        └─────────┴────────────┴────────────┘                   │
│                                                                 │
│  标记说明:                                                      │
│    Native Buy = 用户 Buy YES                                   │
│    Native Sell = 用户 Sell YES                                 │
│    Synthetic Buy = 用户 Sell NO → 转换为 Buy YES               │
│    Synthetic Sell = 用户 Buy NO → 转换为 Sell YES              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 Maker/Taker 判定规则

**规则**：**时间优先** - 先挂单者为 Maker，后到触发者为 Taker

```
┌─────────────────────────────────────────────────────────────────┐
│                    Maker/Taker 判定逻辑                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  基本规则:                                                      │
│  ──────────                                                     │
│  • 先在订单簿中挂单的 = Maker                                    │
│  • 后到达触发成交的 = Taker                                      │
│  • Maker 享受更低手续费，Taker 可享受价格改善                     │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  示例 1: Transfer YES                                          │
│  ────────────────────────                                       │
│  订单 A: Sell YES @ 65 美分, 时间 T1 (先挂单)                    │
│  订单 B: Buy YES @ 66 美分, 时间 T2 (后到，触发成交)             │
│                                                                 │
│  判定: A 是 Maker (Native Sell), B 是 Taker (Native Buy)        │
│  场景: Transfer YES                                             │
│  成交价: 65 美分 (Maker 价格)                                   │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  示例 2: Mint                                                   │
│  ────────────────                                               │
│  订单 A: Buy YES @ 65 美分, 时间 T1 (先挂单，Native Buy)         │
│  订单 B: Buy NO @ 38 美分, 时间 T2                               │
│          → 转换为 Sell YES @ 62 美分 (Synthetic Sell)            │
│                                                                 │
│  判定: A 是 Maker (Native Buy), B 是 Taker (Synthetic Sell)     │
│  场景: Mint                                                     │
│  成交条件: Buy @ 65 >= Sell @ 62 ✓                              │
│  溢价: 65 - 62 = 3 美分 → 归 Maker                              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  示例 3: Transfer NO                                            │
│  ─────────────────────                                          │
│  订单 A: Sell NO @ 40 美分, 时间 T1                              │
│          → 转换为 Buy YES @ 60 美分 (Synthetic Buy, Maker)       │
│  订单 B: Buy NO @ 42 美分, 时间 T2                               │
│          → 转换为 Sell YES @ 58 美分 (Synthetic Sell, Taker)     │
│                                                                 │
│  判定: A 是 Maker (Synthetic Buy), B 是 Taker (Synthetic Sell)  │
│  场景: Transfer NO                                              │
│  成交条件: Buy @ 60 >= Sell @ 58 ✓                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2.1 Self-Trade Prevention (自成交预防)

**规则**：禁止同一用户在同一市场同时持有可成交的买卖订单

**检测时机**：订单提交时（入簿前）

```
┌─────────────────────────────────────────────────────────────────┐
│              Self-Trade Prevention (自成交预防)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  目的: 防止用户与自己的订单成交，避免刷量和误操作手续费损耗      │
│                                                                 │
│  检测逻辑:                                                      │
│  ──────────                                                     │
│  新订单为 BUY (book_direction = BUY):                          │
│    检查该用户是否有 SELL 订单在簿，且 sell_price <= buy_price  │
│                                                                 │
│  新订单为 SELL (book_direction = SELL):                        │
│    检查该用户是否有 BUY 订单在簿，且 buy_price >= sell_price   │
│                                                                 │
│  处理方式: 拒绝新订单，返回错误                                 │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  错误响应示例:                                                  │
│  ──────────────                                                 │
│  {                                                              │
│    "success": false,                                            │
│    "error_code": "SELF_TRADE_PREVENTED",                       │
│    "message": "订单被拒绝：您在该市场已有可成交的反向订单"      │
│  }                                                              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  示例场景:                                                      │
│  ──────────                                                     │
│  用户 A 已有订单: Sell YES @ 60 × 50份 (在订单簿中)            │
│  用户 A 提交新单: Buy YES @ 65 × 30份                          │
│                                                                 │
│  检测: 65 >= 60，会发生自成交                                   │
│  结果: 拒绝新订单，返回 SELF_TRADE_PREVENTED 错误              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  注意事项:                                                      │
│  ──────────                                                     │
│  • 检测基于 book_price（订单簿中的 YES 价格）                   │
│  • Synthetic 订单使用转换后的 book_price 进行检测               │
│  • 用户可先取消旧订单，再提交新订单                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**伪代码实现**：

```python
def check_self_trade(new_order: Order, user_id: str, market_id: str) -> bool:
    """
    检查新订单是否会导致自成交
    Returns: True 如果会自成交（应拒绝），False 如果安全
    """
    # 获取该用户在该市场的所有活跃订单
    user_orders = get_user_active_orders(user_id, market_id)

    for existing_order in user_orders:
        if existing_order.order_id == new_order.order_id:
            continue

        # 检查是否为反向订单且价格可成交
        if new_order.book_direction == Direction.BUY:
            # 新订单是买单，检查是否有可成交的卖单
            if existing_order.book_direction == Direction.SELL:
                if new_order.book_price >= existing_order.book_price:
                    return True  # 会自成交
        else:
            # 新订单是卖单，检查是否有可成交的买单
            if existing_order.book_direction == Direction.BUY:
                if existing_order.book_price >= new_order.book_price:
                    return True  # 会自成交

    return False  # 安全，不会自成交

def submit_order(order: Order) -> OrderResult:
    # ... 其他验证 ...

    # Self-Trade Prevention 检查
    if check_self_trade(order, order.user_id, order.market_id):
        return OrderResult(
            success=False,
            error_code="SELF_TRADE_PREVENTED",
            message="订单被拒绝：您在该市场已有可成交的反向订单"
        )

    # 继续正常的订单处理流程
    # ...
```

### 4.3 价格优化机制

**核心原则**：成交价 = Maker 价格（遵循 exchange-core 标准 Price-Time Priority）

**策略**：溢价归 Maker（差异化策略，激励挂单提供流动性）

> **注意**：此策略与传统交易所（溢价给 Taker）不同，是本系统的差异化设计。

#### 4.3.1 Mint 场景价格优化

Mint 场景由 Native Buy + Synthetic Sell 构成，但 Maker 可能是任一方。

**Case 1: Native Buy 是 Maker（先挂单）**

```
┌─────────────────────────────────────────────────────────────────┐
│             Mint Case 1: Native Buy 是 Maker                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: Native Buy (Maker) + Synthetic Sell (Taker)             │
│  ─────────────────────────────────────────────────              │
│  订单 A (Maker, T1): Buy YES @ 65 美分                         │
│  订单 B (Taker, T2): Buy NO @ 38 美分 → Sell YES @ 62 美分     │
│                                                                 │
│  成交条件: Maker.buy_price >= Taker.sell_price                 │
│            65 >= 62 ✓                                           │
│                                                                 │
│  计算:                                                          │
│  ───────                                                        │
│  成交价 = Maker.book_price = 65 美分 (YES 价格)                │
│  NO 价格 = 100 - 65 = 35 美分                                  │
│                                                                 │
│  价格优化分析:                                                  │
│  ────────────────                                               │
│  Maker (Buy YES): 委托 65 美分，成交 65 美分 (按委托价)         │
│  Taker (Buy NO):  委托 38 美分，成交 35 美分，节省 3 美分       │
│                                                                 │
│  等效视角: 溢价 = 38 - 35 = 3 美分归 Taker (Price Improvement) │
│                                                                 │
│  资金流:                                                        │
│  ────────                                                       │
│  Maker (Native Buy):    65 美分 → Reserve，获得 YES            │
│  Taker (Synthetic Sell): 35 美分 → Reserve，获得 NO            │
│  Reserve: +100 美分 (+$1.00)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Case 2: Synthetic Sell 是 Maker（先挂单）**

```
┌─────────────────────────────────────────────────────────────────┐
│             Mint Case 2: Synthetic Sell 是 Maker                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: Synthetic Sell (Maker) + Native Buy (Taker)             │
│  ─────────────────────────────────────────────────              │
│  订单 A (Maker, T1): Buy NO @ 38 美分 → Sell YES @ 62 美分     │
│  订单 B (Taker, T2): Buy YES @ 65 美分                         │
│                                                                 │
│  成交条件: Taker.buy_price >= Maker.sell_price                 │
│            65 >= 62 ✓                                           │
│                                                                 │
│  计算:                                                          │
│  ───────                                                        │
│  成交价 = Maker.book_price = 62 美分 (YES 价格)                │
│  NO 价格 = 100 - 62 = 38 美分                                  │
│                                                                 │
│  价格优化分析:                                                  │
│  ────────────────                                               │
│  Maker (Buy NO):  委托 38 美分，成交 38 美分 (按委托价)         │
│  Taker (Buy YES): 委托 65 美分，成交 62 美分，节省 3 美分       │
│                                                                 │
│  等效视角: 溢价 = 65 - 62 = 3 美分归 Taker (Price Improvement) │
│                                                                 │
│  资金流:                                                        │
│  ────────                                                       │
│  Maker (Synthetic Sell): 38 美分 → Reserve，获得 NO            │
│  Taker (Native Buy):     62 美分 → Reserve，获得 YES           │
│  Reserve: +100 美分 (+$1.00)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Mint 场景统一原则：**

| Maker 类型 | 成交价 (YES) | 成交价 (NO) | Price Improvement 归属 |
|-----------|--------------|-------------|----------------------|
| Native Buy (Buy YES) | Maker.book_price | 100 - trade_price | Taker (Buy NO) 节省 |
| Synthetic Sell (Buy NO) | Maker.book_price | 100 - trade_price | Taker (Buy YES) 节省 |

**统一规则**：
- 成交价 = Maker.book_price（YES 订单簿中的价格）
- NO 成交价 = 100 - YES 成交价
- Price Improvement 始终归 Taker

#### 4.3.2 Transfer 场景价格优化

```
┌─────────────────────────────────────────────────────────────────┐
│                   Transfer 场景价格优化                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Transfer YES (Native Buy + Native Sell):                       │
│  ─────────────────────────────────────────                      │
│  Maker (T1): Sell YES @ 65 美分                                │
│  Taker (T2): Buy YES @ 67 美分                                 │
│                                                                 │
│  成交价 = 65 美分 (Maker 价格)                                  │
│  Taker 获得 Price Improvement: 2 美分 (67 - 65)                │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Transfer NO (Synthetic Buy + Synthetic Sell):                  │
│  ──────────────────────────────────────────────                 │
│  用户 A (Maker, T1): Sell NO @ 35 美分 → Buy YES @ 65 美分     │
│  用户 B (Taker, T2): Buy NO @ 37 美分 → Sell YES @ 63 美分     │
│                                                                 │
│  成交条件: Maker.buy_price >= Taker.sell_price                 │
│            65 >= 63 ✓                                           │
│                                                                 │
│  成交价 (YES): 65 美分 (Maker 的 Buy YES 价格)                  │
│  成交价 (NO):  35 美分 (100 - 65)                               │
│                                                                 │
│  收益分析:                                                      │
│  ──────────                                                     │
│  Maker (Sell NO): 挂 35 美分，成交 35 美分，无额外收益          │
│  Taker (Buy NO):  挂 37 美分，成交 35 美分，节省 2 美分         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 4.3.3 Burn 场景价格优化

```
┌─────────────────────────────────────────────────────────────────┐
│                    Burn 场景价格优化                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: Synthetic Buy (Sell NO, Maker) + Native Sell (Taker)    │
│  ─────────────────────────────────────────────────────          │
│  用户 A (Maker, T1): Sell NO @ 35 美分 → Buy YES @ 65 美分     │
│  用户 B (Taker, T2): Sell YES @ 63 美分                        │
│                                                                 │
│  成交条件: Maker.buy_price >= Taker.sell_price                 │
│            65 >= 63 ✓                                           │
│                                                                 │
│  成交价 (YES): 65 美分 (Maker 的 Buy YES 价格)                  │
│  成交价 (NO):  35 美分 (100 - 65)                               │
│                                                                 │
│  收益分析:                                                      │
│  ──────────                                                     │
│  Maker (Sell NO): 挂 35 美分，收到 35 美分 (从 Reserve)         │
│  Taker (Sell YES): 挂 63 美分，收到 65 美分，多得 2 美分        │
│                                                                 │
│  资金流:                                                        │
│  ────────                                                       │
│  Reserve → Taker: 65 美分                                      │
│  Reserve → Maker: 35 美分                                      │
│  Reserve: -100 美分 (-$1.00)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 单账本撮合算法

单账本撮合直接使用 exchange-core 标准 CLOB 算法，场景判定在成交时根据订单类型确定。

#### 4.4.1 撮合条件

```
成交条件（标准 CLOB）:
  当存在 Buy 订单和 Sell 订单满足:
    Buy.price >= Sell.price
  则可成交

场景判定（成交时确定）:
  if Buy 是 Native && Sell 是 Synthetic:
      场景 = Mint
  elif Buy 是 Native && Sell 是 Native:
      场景 = Transfer YES
  elif Buy 是 Synthetic && Sell 是 Synthetic:
      场景 = Transfer NO
  elif Buy 是 Synthetic && Sell 是 Native:
      场景 = Burn
```

#### 4.4.2 撮合引擎核心算法

```python
# 撮合引擎核心算法伪代码

class OrderType(Enum):
    NATIVE_BUY = 1      # Buy YES (原生)
    NATIVE_SELL = 2     # Sell YES (原生)
    SYNTHETIC_BUY = 3   # Sell NO → Buy YES (合成)
    SYNTHETIC_SELL = 4  # Buy NO → Sell YES (合成)


class MatchScenario(Enum):
    MINT = 1          # 铸造合约对
    TRANSFER_YES = 2  # YES 转手
    TRANSFER_NO = 3   # NO 转手
    BURN = 4          # 销毁合约对


def match_order(incoming_order: Order) -> List[Trade]:
    """
    撮合入口函数 - 单账本标准 CLOB 撮合
    """
    trades = []

    if incoming_order.book_direction == BUY:
        # 买单: 匹配订单簿中的卖单
        trades = match_buy_order(incoming_order)
    else:
        # 卖单: 匹配订单簿中的买单
        trades = match_sell_order(incoming_order)

    # 剩余数量入簿
    if incoming_order.remaining_qty > 0:
        add_to_orderbook(incoming_order)

    return trades


def match_buy_order(order: Order) -> List[Trade]:
    """
    Buy 订单撮合（标准 CLOB）

    在单账本模型中:
    - Native Buy (Buy YES) 直接作为买单
    - Synthetic Buy (Sell NO → Buy YES) 也作为买单
    """
    trades = []

    while order.remaining_qty > 0:
        # 获取最优卖单 (最低价)
        best_sell = get_best_sell()

        if not best_sell or order.book_price < best_sell.book_price:
            break  # 无法成交

        # 执行成交
        trade = execute_trade(order, best_sell)
        trades.append(trade)

    return trades


def match_sell_order(order: Order) -> List[Trade]:
    """
    Sell 订单撮合（标准 CLOB）

    在单账本模型中:
    - Native Sell (Sell YES) 直接作为卖单
    - Synthetic Sell (Buy NO → Sell YES) 也作为卖单
    """
    trades = []

    while order.remaining_qty > 0:
        # 获取最优买单 (最高价)
        best_buy = get_best_buy()

        if not best_buy or best_buy.book_price < order.book_price:
            break  # 无法成交

        # 执行成交
        trade = execute_trade(best_buy, order)
        trades.append(trade)

    return trades


def execute_trade(buy_order: Order, sell_order: Order) -> Trade:
    """
    执行成交 - 判定场景并分发到对应处理函数
    """
    # 确定 Maker/Taker (时间优先)
    if buy_order.timestamp < sell_order.timestamp:
        maker, taker = buy_order, sell_order
    else:
        maker, taker = sell_order, buy_order

    # 判定场景
    scenario = determine_scenario(buy_order.order_type, sell_order.order_type)

    # 成交价 = Maker 价格 (exchange-core 标准)
    trade_price = maker.book_price

    # 成交数量
    trade_qty = min(buy_order.remaining_qty, sell_order.remaining_qty)

    # 根据场景执行不同结算逻辑
    if scenario == MatchScenario.MINT:
        return execute_mint(buy_order, sell_order, trade_price, trade_qty, maker, taker)
    elif scenario == MatchScenario.TRANSFER_YES:
        return execute_transfer_yes(buy_order, sell_order, trade_price, trade_qty, maker, taker)
    elif scenario == MatchScenario.TRANSFER_NO:
        return execute_transfer_no(buy_order, sell_order, trade_price, trade_qty, maker, taker)
    elif scenario == MatchScenario.BURN:
        return execute_burn(buy_order, sell_order, trade_price, trade_qty, maker, taker)


def determine_scenario(buy_type: OrderType, sell_type: OrderType) -> MatchScenario:
    """
    根据订单类型判定撮合场景
    """
    if buy_type == OrderType.NATIVE_BUY:
        if sell_type == OrderType.SYNTHETIC_SELL:
            return MatchScenario.MINT
        else:  # NATIVE_SELL
            return MatchScenario.TRANSFER_YES
    else:  # SYNTHETIC_BUY
        if sell_type == OrderType.SYNTHETIC_SELL:
            return MatchScenario.TRANSFER_NO
        else:  # NATIVE_SELL
            return MatchScenario.BURN
```

#### 4.4.3 Mint 场景执行

```python
def execute_mint(buy: Order, sell: Order, price: int, qty: int,
                 maker: Order, taker: Order) -> Trade:
    """
    Mint 场景执行 - 创建合约对

    buy: Native Buy (Buy YES)
    sell: Synthetic Sell (Buy NO → Sell YES)

    资金: 双方 → Reserve (+$1.00)
    持仓: Native Buy 获得 YES, Synthetic Sell 方获得 NO
    """
    market = get_market(buy.market_id)

    # ═══════════════════════════════════════════════════════
    # Layer 3 前置校验 (详见 3.4.3 节)
    # ═══════════════════════════════════════════════════════
    assert 1 <= price <= 99, \
        f"[CRITICAL] Trade price {price} out of valid range [1, 99]"

    # YES 价格 = 成交价 (Maker 价格)
    yes_price = price
    # NO 价格 = 100 - YES 价格
    no_price = 100 - yes_price

    with transaction():
        # ═══════════════════════════════════════════════════════
        # Step 1: Native Buy 方 (获得 YES)
        # ═══════════════════════════════════════════════════════
        buy_user = get_user(buy.user_id)
        buy_position = get_position(buy.user_id, market.id)

        # 扣减冻结余额
        buy_frozen = buy.book_price * qty  # 冻结的是委托价
        buy_payment = yes_price * qty       # 实际支付成交价
        buy_refund = buy_frozen - buy_payment

        buy_user.frozen_balance -= buy_frozen
        if buy_refund > 0:
            buy_user.available_balance += buy_refund

        # 获得 YES 持仓
        buy_position.yes_volume += qty
        buy_position.yes_cost_sum += buy_payment

        # ═══════════════════════════════════════════════════════
        # Step 2: Synthetic Sell 方 (获得 NO)
        # ═══════════════════════════════════════════════════════
        sell_user = get_user(sell.user_id)
        sell_position = get_position(sell.user_id, market.id)

        # 扣减冻结余额 (冻结的是原始 NO 价格)
        sell_frozen = sell.original_price * qty  # Buy NO 时冻结的金额
        sell_payment = no_price * qty             # 实际支付成交价
        sell_refund = sell_frozen - sell_payment

        sell_user.frozen_balance -= sell_frozen
        if sell_refund > 0:
            sell_user.available_balance += sell_refund

        # 获得 NO 持仓
        sell_position.no_volume += qty
        sell_position.no_cost_sum += sell_payment

        # ═══════════════════════════════════════════════════════
        # Step 3: 更新 Reserve
        # ═══════════════════════════════════════════════════════
        market.reserve_balance += 100 * qty  # 每对合约 $1.00
        market.total_yes_shares += qty
        market.total_no_shares += qty

        # ═══════════════════════════════════════════════════════
        # Step 4: 更新订单状态
        # ═══════════════════════════════════════════════════════
        update_order_filled(buy, qty)
        update_order_filled(sell, qty)

        # ═══════════════════════════════════════════════════════
        # Step 5: 账户层净额结算检查
        # ═══════════════════════════════════════════════════════
        execute_netting_if_needed(buy.user_id, market.id)
        execute_netting_if_needed(sell.user_id, market.id)

        # ═══════════════════════════════════════════════════════
        # Step 6: 验证不变量
        # ═══════════════════════════════════════════════════════
        assert_reserve_invariant(market)

    return Trade(
        trade_id=generate_trade_id(),
        market_id=market.id,
        maker_order_id=maker.id,
        taker_order_id=taker.id,
        scenario=MatchScenario.MINT,
        yes_price=yes_price,
        no_price=no_price,
        quantity=qty,
        timestamp=now()
    )
```

#### 4.4.4 Transfer YES 场景执行

```python
def execute_transfer_yes(buy: Order, sell: Order, price: int, qty: int,
                         maker: Order, taker: Order) -> Trade:
    """
    Transfer YES 场景执行 - YES 持仓转让

    buy: Native Buy (Buy YES)
    sell: Native Sell (Sell YES)

    资金: 买方 → 卖方 (直接转账)
    持仓: YES 从卖方转移到买方
    Reserve: 不变
    """
    market = get_market(buy.market_id)

    # 成交价 = Maker 价格
    trade_price = price

    buy_user = get_user(buy.user_id)
    sell_user = get_user(sell.user_id)
    buy_position = get_position(buy.user_id, market.id)
    sell_position = get_position(sell.user_id, market.id)

    with transaction():
        # ═══════════════════════════════════════════════════════
        # Step 1: 买方资金结算
        # ═══════════════════════════════════════════════════════
        buy_frozen = buy.book_price * qty      # 预冻结金额
        buy_payment = trade_price * qty         # 实际支付
        buy_refund = buy_frozen - buy_payment   # 退还差额

        buy_user.frozen_balance -= buy_frozen
        if buy_refund > 0:
            buy_user.available_balance += buy_refund

        # ═══════════════════════════════════════════════════════
        # Step 2: 卖方持仓与资金结算
        # ═══════════════════════════════════════════════════════
        # 计算卖出成本 (按比例)
        sell_cost_per_unit = sell_position.yes_cost_sum // sell_position.yes_volume
        sold_cost = sell_cost_per_unit * qty

        # 扣减持仓
        sell_position.yes_pending_sell -= qty
        sell_position.yes_volume -= qty
        sell_position.yes_cost_sum -= sold_cost

        # 卖方收款
        sell_user.available_balance += buy_payment

        # ═══════════════════════════════════════════════════════
        # Step 3: 更新 pnl_pool (追踪盈亏流动)
        # ═══════════════════════════════════════════════════════
        seller_pnl = buy_payment - sold_cost  # 卖方盈亏
        market.pnl_pool -= seller_pnl

        # ═══════════════════════════════════════════════════════
        # Step 4: 买方持仓更新
        # ═══════════════════════════════════════════════════════
        buy_position.yes_volume += qty
        buy_position.yes_cost_sum += buy_payment

        # ═══════════════════════════════════════════════════════
        # Step 5: 更新订单状态
        # ═══════════════════════════════════════════════════════
        update_order_filled(buy, qty)
        update_order_filled(sell, qty)

        # ═══════════════════════════════════════════════════════
        # Step 6: 验证与净额结算
        # ═══════════════════════════════════════════════════════
        assert_cost_invariant(market)
        execute_netting_if_needed(buy.user_id, market.id)

    return Trade(
        trade_id=generate_trade_id(),
        market_id=market.id,
        maker_order_id=maker.id,
        taker_order_id=taker.id,
        scenario=MatchScenario.TRANSFER_YES,
        price=trade_price,
        quantity=qty,
        seller_pnl=seller_pnl,
        timestamp=now()
    )
```

#### 4.4.5 Transfer NO 场景执行

```python
def execute_transfer_no(buy: Order, sell: Order, price: int, qty: int,
                        maker: Order, taker: Order) -> Trade:
    """
    Transfer NO 场景执行 - NO 持仓转让

    场景: Synthetic Buy + Synthetic Sell (两个 Synthetic 订单匹配)

    ═══════════════════════════════════════════════════════════════
    订单簿视角 (YES 订单簿):
    ═══════════════════════════════════════════════════════════════
    buy  = Synthetic Buy  = 在 YES 订单簿的 Buy 队列
    sell = Synthetic Sell = 在 YES 订单簿的 Sell 队列
    price = 成交价 (YES 价格) = Maker.book_price

    Maker/Taker 判定: 基于时间优先，先挂单者为 Maker

    ═══════════════════════════════════════════════════════════════
    用户视角 (NO 交易):
    ═══════════════════════════════════════════════════════════════
    buy 订单的用户: 原始操作是 Sell NO → 放弃 NO 持仓，获得资金
    sell 订单的用户: 原始操作是 Buy NO → 支付资金，获得 NO 持仓

    ═══════════════════════════════════════════════════════════════
    价格转换:
    ═══════════════════════════════════════════════════════════════
    YES 成交价 = price (订单簿撮合价，即 Maker.book_price)
    NO 成交价 = 100 - price

    ═══════════════════════════════════════════════════════════════
    示例:
    ═══════════════════════════════════════════════════════════════
    用户 A (Maker, T1): Sell NO @ 35 → 转换为 Buy YES @ 65 (先挂单)
    用户 B (Taker, T2): Buy NO @ 37 → 转换为 Sell YES @ 63 (后到达)

    成交: YES price = 65 (Maker.book_price)
          NO price = 100 - 65 = 35

    结果:
    - 用户 A (Sell NO): 获得 35 美分，NO 持仓 -1
    - 用户 B (Buy NO):  支付 35 美分，NO 持仓 +1
    - 用户 B 节省 2 美分 (挂单 37，实际 35) → Price Improvement

    ═══════════════════════════════════════════════════════════════
    内部逻辑: Mint + Burn 同时发生并抵消
    资金: NO 买方 → NO 卖方
    持仓: NO 从卖方转移到买方
    Reserve: 不变 (Mint +$1 和 Burn -$1 抵消)
    """
    market = get_market(buy.market_id)

    # 价格计算
    yes_price = price              # YES 成交价 = Maker.book_price
    no_price = 100 - yes_price     # NO 成交价 = 100 - YES 成交价

    # 参数角色映射 (订单簿视角 → 用户视角):
    # buy (Synthetic Buy, Buy YES 队列) = 用户原始操作是 Sell NO = NO 卖方
    # sell (Synthetic Sell, Sell YES 队列) = 用户原始操作是 Buy NO = NO 买方

    buy_user = get_user(buy.user_id)   # NO 卖方 (Sell NO 的用户)
    sell_user = get_user(sell.user_id)  # NO 买方 (Buy NO 的用户)
    buy_position = get_position(buy.user_id, market.id)
    sell_position = get_position(sell.user_id, market.id)

    with transaction():
        # ═══════════════════════════════════════════════════════
        # Step 1: Synthetic Buy 方 (Sell NO) - NO 卖方
        # ═══════════════════════════════════════════════════════
        # 计算卖出成本 (按比例)
        buy_cost_per_unit = buy_position.no_cost_sum // buy_position.no_volume
        sold_cost = buy_cost_per_unit * qty

        # 释放冻结的 NO 持仓
        buy_position.no_pending_sell -= qty
        buy_position.no_volume -= qty
        buy_position.no_cost_sum -= sold_cost

        # 收到 NO 价格
        buy_user.available_balance += no_price * qty

        # ═══════════════════════════════════════════════════════
        # Step 2: Synthetic Sell 方 (Buy NO) - NO 买方
        # ═══════════════════════════════════════════════════════
        # 扣减冻结的资金
        sell_frozen = sell.original_price * qty  # 冻结的是原始 Buy NO 价格
        sell_payment = no_price * qty             # 实际支付
        sell_refund = sell_frozen - sell_payment

        sell_user.frozen_balance -= sell_frozen
        if sell_refund > 0:
            sell_user.available_balance += sell_refund

        # 获得 NO 持仓
        sell_position.no_volume += qty
        sell_position.no_cost_sum += sell_payment

        # ═══════════════════════════════════════════════════════
        # Step 3: 更新 pnl_pool
        # ═══════════════════════════════════════════════════════
        seller_pnl = (no_price * qty) - sold_cost
        market.pnl_pool -= seller_pnl

        # ═══════════════════════════════════════════════════════
        # Step 4: Reserve 不变 (Mint + Burn 抵消)
        # ═══════════════════════════════════════════════════════
        # 无需更新 reserve_balance, total_shares

        # ═══════════════════════════════════════════════════════
        # Step 5: 更新订单状态
        # ═══════════════════════════════════════════════════════
        update_order_filled(buy, qty)
        update_order_filled(sell, qty)

        # ═══════════════════════════════════════════════════════
        # Step 6: 验证与净额结算
        # ═══════════════════════════════════════════════════════
        assert_cost_invariant(market)
        execute_netting_if_needed(buy.user_id, market.id)
        execute_netting_if_needed(sell.user_id, market.id)

    return Trade(
        trade_id=generate_trade_id(),
        market_id=market.id,
        maker_order_id=maker.id,
        taker_order_id=taker.id,
        scenario=MatchScenario.TRANSFER_NO,
        yes_price=yes_price,
        no_price=no_price,
        quantity=qty,
        seller_pnl=seller_pnl,
        timestamp=now()
    )
```

#### 4.4.6 Burn 场景执行

```python
def execute_burn(buy: Order, sell: Order, price: int, qty: int,
                 maker: Order, taker: Order) -> Trade:
    """
    Burn 场景执行 - 销毁合约对

    buy: Synthetic Buy (Sell NO → Buy YES)
    sell: Native Sell (Sell YES)

    资金: Reserve → 双方 (释放 $1.00)
    持仓: YES 和 NO 各销毁一份
    """
    market = get_market(buy.market_id)

    # 成交价 (YES) = Maker 价格
    yes_price = price
    # NO 价格 = 100 - YES 价格
    no_price = 100 - yes_price

    buy_user = get_user(buy.user_id)   # NO 卖方 (Sell NO)
    sell_user = get_user(sell.user_id)  # YES 卖方 (Sell YES)
    buy_position = get_position(buy.user_id, market.id)
    sell_position = get_position(sell.user_id, market.id)

    with transaction():
        # ═══════════════════════════════════════════════════════
        # Step 1: Synthetic Buy 方 (Sell NO) - 销毁 NO，获得资金
        # ═══════════════════════════════════════════════════════
        # 先计算单位成本（在扣减持仓之前）
        buy_cost_per_unit = buy_position.no_cost_sum // buy_position.no_volume
        buy_sold_cost = buy_cost_per_unit * qty

        # 再扣减持仓
        buy_position.no_pending_sell -= qty
        buy_position.no_volume -= qty
        buy_position.no_cost_sum -= buy_sold_cost

        # 从 Reserve 获得 NO 价格
        buy_user.available_balance += no_price * qty

        # ═══════════════════════════════════════════════════════
        # Step 2: Native Sell 方 (Sell YES) - 销毁 YES，获得资金
        # ═══════════════════════════════════════════════════════
        # 先计算单位成本（在扣减持仓之前）
        sell_cost_per_unit = sell_position.yes_cost_sum // sell_position.yes_volume
        sell_sold_cost = sell_cost_per_unit * qty

        # 再扣减持仓
        sell_position.yes_pending_sell -= qty
        sell_position.yes_volume -= qty
        sell_position.yes_cost_sum -= sell_sold_cost

        # 从 Reserve 获得 YES 价格
        sell_user.available_balance += yes_price * qty

        # ═══════════════════════════════════════════════════════
        # Step 3: 更新 Reserve (释放资金)
        # ═══════════════════════════════════════════════════════
        market.reserve_balance -= 100 * qty  # 每对合约释放 $1.00
        market.total_yes_shares -= qty
        market.total_no_shares -= qty

        # ═══════════════════════════════════════════════════════
        # Step 4: 更新订单状态
        # ═══════════════════════════════════════════════════════
        update_order_filled(buy, qty)
        update_order_filled(sell, qty)

        # ═══════════════════════════════════════════════════════
        # Step 5: 验证不变量
        # ═══════════════════════════════════════════════════════
        assert_reserve_invariant(market)

    return Trade(
        trade_id=generate_trade_id(),
        market_id=market.id,
        maker_order_id=maker.id,
        taker_order_id=taker.id,
        scenario=MatchScenario.BURN,
        yes_price=yes_price,
        no_price=no_price,
        quantity=qty,
        timestamp=now()
    )
```

### 4.5 撮合示例完整演算

```
┌─────────────────────────────────────────────────────────────────┐
│                    完整撮合示例                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初始状态:                                                       │
│  ──────────                                                     │
│  Market: reserve=10,000, pnl_pool=0                            │
│  YES 订单簿: 空                                                 │
│  total_yes_shares=100, total_no_shares=100                     │
│                                                                 │
│  ═══════════════════════════════════════════════════════════   │
│                                                                 │
│  T1: 用户 A 下单 Buy YES @ 65 × 50 (Native Buy)                │
│  ─────────────────────────────────────────────                  │
│  操作: 冻结 A 余额 3250 美分 ($32.50)                           │
│  订单簿: Buy YES @ 65 × 50 (Native)                            │
│                                                                 │
│  ═══════════════════════════════════════════════════════════   │
│                                                                 │
│  T2: 用户 B 下单 Buy NO @ 38 × 50 (Synthetic Sell)              │
│  ─────────────────────────────────────────────                  │
│  转换: Sell YES @ 62 × 50                                      │
│  冻结: B 余额 1900 美分 ($19.00)                               │
│                                                                 │
│  撮合: Buy @ 65 >= Sell @ 62 ✓ → Mint                          │
│  成交价 (Maker=A): YES=65 美分, NO=35 美分                      │
│                                                                 │
│  结算:                                                          │
│  ────────                                                       │
│  A (Native Buy):                                                │
│    冻结释放: 3250                                               │
│    实际支付: 65 × 50 = 3250 → Reserve                          │
│    获得: yes_volume += 50, yes_cost_sum += 3250                │
│                                                                 │
│  B (Synthetic Sell, Buy NO):                                   │
│    冻结释放: 1900                                               │
│    实际支付: 35 × 50 = 1750 → Reserve                          │
│    退还: 1900 - 1750 = 150 (3 美分/份溢价)                     │
│    获得: no_volume += 50, no_cost_sum += 1750                  │
│                                                                 │
│  Reserve: 10000 + 3250 + 1750 = 15000 (+$50.00)               │
│  Shares: yes=150, no=150                                       │
│                                                                 │
│  ═══════════════════════════════════════════════════════════   │
│                                                                 │
│  T3: 用户 C 下单 Buy YES @ 70 × 30 (Native Buy)                │
│  ─────────────────────────────────────────────                  │
│  冻结: C 余额 2100 美分                                         │
│  无匹配卖单 → 入簿                                              │
│                                                                 │
│  T4: 用户 D 下单 Sell YES @ 68 × 30 (Native Sell, D 持有 YES)  │
│  ─────────────────────────────────────────────                  │
│  冻结: D 持仓 30 份 YES                                         │
│                                                                 │
│  撮合: Buy @ 70 >= Sell @ 68 ✓ → Transfer YES                  │
│  成交价 (Maker=C): 70 美分                                      │
│                                                                 │
│  结算:                                                          │
│  ────────                                                       │
│  C (Native Buy, Taker):                                         │
│    冻结释放: 2100                                               │
│    实际支付: 70 × 30 = 2100 → D                                │
│    获得: yes_volume += 30, yes_cost_sum += 2100                │
│                                                                 │
│  D (Native Sell, Maker):                                        │
│    冻结释放: 30 份 YES                                          │
│    yes_volume -= 30, yes_cost_sum -= (按比例)                  │
│    收到: 2100                                                   │
│    pnl = 2100 - sold_cost                                      │
│                                                                 │
│  Reserve: 15000 (不变, Transfer)                               │
│  pnl_pool: -= D 的 pnl                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 成交价格确定规则总结

| 场景 | 成交价确定 | 说明 |
|------|-----------|------|
| Mint | YES_price = Maker.book_price, NO_price = 100 - YES_price | Maker 可能是 Native Buy 或 Synthetic Sell |
| Transfer YES | price = Maker.book_price | 标准 CLOB，Maker 价格 |
| Transfer NO | YES_price = Maker.book_price, NO_price = 100 - YES_price | 以 Maker 的 Buy YES 价格为准 |
| Burn | YES_price = Maker.book_price, NO_price = 100 - YES_price | Reserve 按此分配 |

### 4.7 与双账本撮合的对比

| 维度 | 双账本方案 | 单账本方案 |
|------|-----------|-----------|
| 订单簿数量 | 2 个 (YES + NO) | 1 个 (YES) |
| 撮合类型 | 同账本、跨账本 | Mint、Transfer YES、Transfer NO、Burn |
| NO 订单处理 | 直接在 NO 订单簿 | 转换为 YES 订单 |
| 路由逻辑 | 同账本优先 + 跨账本 | 统一 CLOB 撮合 |
| Exchange-core 对齐 | 需扩展 | 原生对齐 |
| 场景判定时机 | 撮合时确定路由 | 成交时确定场景 |
| 复杂度 | 较高 | 较低 |

---

## 五、P2: 持仓管理设计

> **风险等级**：中高 (P2)
> **设计目标**：正确管理用户持仓，自动净额结算，保证份数守恒

### 5.1 持仓数据结构

> **设计对齐**: 与 exchange-core 的 `SymbolPositionRecord` 结构对齐

```
┌─────────────────────────────────────────────────────────────────┐
│                    PositionRecord 数据结构                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PositionRecord {                                               │
│      user_id: long                                              │
│      market_id: int                                             │
│                                                                 │
│      // YES 持仓 (对应 exchange-core SymbolPositionRecord)      │
│      yes_volume: int64           // 持仓份数 (openVolume)       │
│      yes_cost_sum: int64         // 累计成本 (openPriceSum)     │
│      yes_pending_sell: int64     // 卖单冻结 (pendingSellSize)  │
│                                                                 │
│      // NO 持仓                                                 │
│      no_volume: int64            // 持仓份数                    │
│      no_cost_sum: int64          // 累计成本                    │
│      no_pending_sell: int64      // 卖单冻结                    │
│                                                                 │
│      updated_at: timestamp                                      │
│  }                                                              │
│                                                                 │
│  约束:                                                          │
│    yes_volume >= yes_pending_sell >= 0                         │
│    no_volume >= no_pending_sell >= 0                           │
│    yes_cost_sum >= 0                                           │
│    no_cost_sum >= 0                                            │
│                                                                 │
│  计算属性:                                                       │
│    yes_avg_cost = yes_cost_sum / yes_volume (需要时计算)        │
│    no_avg_cost = no_cost_sum / no_volume                       │
│                                                                 │
│  与 exchange-core 映射:                                          │
│  ───────────────────────                                        │
│  本系统字段          │ exchange-core 字段                        │
│  yes_volume         │ openVolume (symbol=YES)                  │
│  yes_cost_sum       │ openPriceSum                             │
│  yes_pending_sell   │ pendingSellSize                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 持仓创建与更新（按撮合场景）

#### 5.2.1 Mint 场景持仓创建

```
Mint 成交后（Native Buy + Synthetic Sell）:
───────────────────────────────────────────

场景: 用户A Buy YES @ 65 × 100份，用户B Buy NO @ 35 × 100份

持仓更新 (使用 cost_sum 累加，无除法):
  用户A (Native Buy, 获得 YES):
    yes_volume += 100
    yes_cost_sum += 65 × 100 = 6500

  用户B (Synthetic Sell, 获得 NO):
    no_volume += 100
    no_cost_sum += 35 × 100 = 3500

托管更新:
  reserve_balance += 100 × 100 = 10000 美分 ($100.00)
  total_yes_shares += 100
  total_no_shares += 100
```

#### 5.2.2 Transfer YES 场景持仓转移

```
Transfer YES 成交后（Native Buy + Native Sell）:
─────────────────────────────────────────────────

场景: 用户A Buy YES @ 65 × 50份 成交，用户B Sell YES @ 65 × 50份

持仓更新:
  用户A (Native Buy, 获得 YES):
    yes_volume += 50
    yes_cost_sum += 65 × 50 = 3250

  用户B (Native Sell, 释放 YES):
    sold_cost = (yes_cost_sum / yes_volume) × 50  // 按比例计算卖出成本
             = 60 × 50 = 3000  (假设原成本 60)
    yes_volume -= 50
    yes_cost_sum -= 3000
    yes_pending_sell -= 50

资金流转:
  A.frozen_balance -= 3250  // 买方支付
  B.available_balance += 3250  // 卖方收款

盈亏池更新:
  seller_pnl = 收入 - 成本 = 3250 - 3000 = 250
  pnl_pool -= 250  // 利润流出，pnl_pool减少

验证恒等式:
  reserve_balance + pnl_pool == Σ(cost_sum)
```

#### 5.2.3 Transfer NO 场景持仓转移

```
Transfer NO 成交后（Synthetic Buy + Synthetic Sell）:
───────────────────────────────────────────────────────

场景:
  用户A: Sell NO @ 35 × 50 (Synthetic Buy, 释放 NO 持仓)
  用户B: Buy NO @ 35 × 50 (Synthetic Sell, 获得 NO 持仓)

持仓更新:
  用户A (Synthetic Buy, 释放 NO):
    sold_cost = (no_cost_sum / no_volume) × 50
             = 30 × 50 = 1500  (假设原成本 30)
    no_volume -= 50
    no_cost_sum -= 1500
    no_pending_sell -= 50
    收款: 35 × 50 = 1750

  用户B (Synthetic Sell, 获得 NO):
    no_volume += 50
    no_cost_sum += 35 × 50 = 1750
    支付: 1750

盈亏池更新:
  seller_pnl = 收入 - 成本 = 1750 - 1500 = 250
  pnl_pool -= 250

Reserve 不变 (内部 Mint + Burn 抵消)
```

#### 5.2.4 Burn 场景持仓销毁

```
Burn 成交后（Synthetic Buy + Native Sell）:
───────────────────────────────────────────

场景:
  用户A: Sell NO @ 35 × 100 (Synthetic Buy, 销毁 NO)
  用户B: Sell YES @ 65 × 100 (Native Sell, 销毁 YES)

持仓更新:
  用户A (Synthetic Buy, 销毁 NO):
    no_volume -= 100
    no_cost_sum -= (按比例计算)
    no_pending_sell -= 100
    收款 (从 Reserve): 35 × 100 = 3500

  用户B (Native Sell, 销毁 YES):
    yes_volume -= 100
    yes_cost_sum -= (按比例计算)
    yes_pending_sell -= 100
    收款 (从 Reserve): 65 × 100 = 6500

Reserve 更新:
  reserve_balance -= 100 × 100 = 10000 美分 ($100.00)
  total_yes_shares -= 100
  total_no_shares -= 100
```

### 5.3 账户层自动净额结算 (Auto-Netting)

> **重要说明**：自动净额结算是**账户层**的操作，不是撮合系统的职责。撮合系统只负责四种场景的执行，账户系统负责在用户同时持有 YES 和 NO 时触发净额结算。

> **设计依据**:
> - **参考 Kalshi**: 即时对冲 (instant netting)，用户永不同时持有 YES 和 NO
> - **同步执行**: 成交时立即结算，消除竞态条件
> - **不收手续费**: Kalshi 规则，净额结算是后台会计操作 (Compression)，非用户主动交易
> - **cost_sum 处理**: 按比例减少，保持隐式 avg_cost 不变

**策略**：**成交时同步执行**，作为交易事务的一部分

```
┌─────────────────────────────────────────────────────────────────┐
│                   账户层净额结算机制                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  触发时机:                                                       │
│  ──────────                                                     │
│  任何撮合成交后，检查相关用户是否同时持有 YES 和 NO               │
│  如果是，立即执行净额结算（同一事务内）                            │
│                                                                 │
│  可能触发的场景:                                                 │
│  ────────────────                                               │
│  • Mint: 新创建的持仓可能与已有持仓形成 YES+NO                   │
│  • Transfer: 买入的持仓可能与已有持仓形成 YES+NO                 │
│                                                                 │
│  执行流程:                                                       │
│  ──────────                                                     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   撮合成交事务                            │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │  1. 执行场景结算 (Mint/Transfer/Burn)                    │   │
│  │  2. 更新持仓                                             │   │
│  │  3. 更新订单状态                                          │   │
│  │  4. 账户层净额结算检查 ◄── 用户永不同时持有 YES/NO         │   │
│  │     └─ execute_netting_if_needed(user_id, market_id)     │   │
│  │  5. 提交事务                                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  优势:                                                          │
│  ──────                                                         │
│  ✓ 无竞态条件 - 同一事务内完成                                    │
│  ✓ 用户永不同时持有 YES/NO - 符合 Kalshi 行为                     │
│  ✓ 状态一致性强 - 不变量始终满足                                  │
│  ✓ 实现简单 - 无需额外队列服务                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.3.1 净额结算执行逻辑

```python
def execute_netting_if_needed(user_id: str, market_id: str):
    """
    账户层净额结算 - 成交时立即执行

    参考 Kalshi: 用户永不同时持有 YES 和 NO
    """
    # 注意: 此函数在交易事务内调用，共享事务上下文
    position = get_position(user_id, market_id)

    # 检查是否需要净额结算
    if position.yes_volume <= 0 or position.no_volume <= 0:
        return  # 无需处理

    # 计算可净额数量（排除冻结部分）
    available_yes = position.yes_volume - position.yes_pending_sell
    available_no = position.no_volume - position.no_pending_sell
    netting_qty = min(available_yes, available_no)

    if netting_qty <= 0:
        return  # 无可用净额

    # 执行净额结算（在当前事务内）
    # 1. 计算双方成本
    yes_cost_per_unit = position.yes_cost_sum // position.yes_volume
    no_cost_per_unit = position.no_cost_sum // position.no_volume
    yes_netting_cost = yes_cost_per_unit * netting_qty
    no_netting_cost = no_cost_per_unit * netting_qty

    # 2. 销毁持仓
    position.yes_volume -= netting_qty
    position.no_volume -= netting_qty
    position.yes_cost_sum -= yes_netting_cost
    position.no_cost_sum -= no_netting_cost

    # 3. 从 Reserve 释放资金（每对合约 100 美分 = $1.00）
    release_amount = netting_qty * 100
    cost_released = yes_netting_cost + no_netting_cost

    # 调整 pnl_pool 以维持不变量: reserve + pnl_pool == Σ(cost_sum)
    # reserve 变化 = -release_amount
    # cost_sum 变化 = -cost_released
    # 需要: reserve变化 + pnl_pool变化 = cost_sum变化
    # 即: -release_amount + pnl_adjustment = -cost_released
    # 所以: pnl_adjustment = release_amount - cost_released
    pnl_adjustment = release_amount - cost_released

    market = get_market(market_id)
    market.reserve_balance -= release_amount
    market.pnl_pool -= pnl_adjustment  # 维持不变量
    market.total_yes_shares -= netting_qty
    market.total_no_shares -= netting_qty

    # 4. 资金返还用户
    user = get_user(user_id)
    user.available_balance += release_amount

    # 5. 记录净额结算事件
    emit_event(NettingExecuted(
        user_id=user_id,
        market_id=market_id,
        quantity=netting_qty,
        release_amount=release_amount,
        cost_released=cost_released,
        pnl_adjustment=pnl_adjustment
    ))
```

#### 5.3.2 部分成交与净额结算的交互

当订单部分成交时，新获得的持仓可能触发净额结算。需要明确**订单冻结**与**净额结算释放**是两个独立的资金池。

```
┌─────────────────────────────────────────────────────────────────┐
│            部分成交 + 净额结算 执行顺序                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景示例:                                                       │
│  ──────────                                                     │
│  初始状态:                                                       │
│    用户 A 持有 NO 100份                                         │
│    用户 A 提交: Buy YES @ 65 × 100份                            │
│    冻结资金: 65 × 100 = 6500 美分                               │
│                                                                 │
│  部分成交 50份 (Mint 场景):                                      │
│  ─────────────────────────────                                  │
│                                                                 │
│  Step 1: 执行 Mint 结算                                         │
│    • 用户 A 支付: 65 × 50 = 3250 美分 (从冻结资金扣除)          │
│    • 用户 A 获得: YES 50份                                      │
│    • 订单冻结更新: 6500 → 3250 美分 (剩余 50份的冻结)           │
│                                                                 │
│  Step 2: 更新订单状态                                           │
│    • filled_qty: 0 → 50                                        │
│    • status: OPEN → PARTIAL_FILLED                             │
│                                                                 │
│  Step 3: 净额结算检查                                           │
│    • available_yes = 50 (新获得)                                │
│    • available_no = 100 (原有)                                  │
│    • netting_qty = min(50, 100) = 50                           │
│                                                                 │
│  Step 4: 执行净额结算                                           │
│    • 销毁 YES 50份 + NO 50份                                    │
│    • Reserve 释放: 50 × 100 = 5000 美分 → 用户 available        │
│    • 用户 A 持仓: YES 0份, NO 50份                              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  最终状态:                                                       │
│  ──────────                                                     │
│  用户 A:                                                        │
│    • YES 持仓: 0份                                              │
│    • NO 持仓: 50份                                              │
│    • 冻结资金: 3250 美分 (订单剩余部分)                          │
│    • available_balance: +5000 美分 (净额结算释放)               │
│                                                                 │
│  订单状态:                                                       │
│    • filled_qty: 50                                            │
│    • remaining: 50                                             │
│    • frozen: 3250 美分                                         │
│    • status: PARTIAL_FILLED                                    │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  关键规则:                                                       │
│  ──────────                                                     │
│  1. 订单冻结金额 = remaining_qty × price (仅追踪订单未成交部分)  │
│  2. 净额结算释放资金 → available_balance (与订单冻结独立)        │
│  3. 两个资金池互不影响，用户可自由使用净额释放的资金             │
│  4. 订单取消时，冻结资金返还 available_balance                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**伪代码执行顺序**:

```python
def process_partial_fill(order: Order, fill_qty: int, trade_price: int):
    """
    部分成交处理 - 包含净额结算检查
    """
    with transaction():
        # Step 1: 执行场景结算 (Mint/Transfer/Burn)
        execute_trade_settlement(order, fill_qty, trade_price)

        # Step 2: 更新订单冻结
        if order.order_type in [OrderType.NATIVE_BUY, OrderType.SYNTHETIC_SELL]:
            # 买单: 释放已成交部分的冻结资金
            released_freeze = order.original_price * fill_qty
            order.frozen_amount -= released_freeze

        # Step 3: 更新订单状态
        order.filled_qty += fill_qty
        if order.filled_qty == order.quantity:
            order.status = OrderStatus.FILLED
        else:
            order.status = OrderStatus.PARTIAL_FILLED

        # Step 4: 净额结算检查 (关键步骤)
        # 新获得的持仓可能与已有持仓形成 YES+NO 组合
        position = get_position(order.user_id, order.market_id)
        execute_netting_if_needed(position)

        # Step 5: 提交事务
```

### 5.4 份数守恒验证

**不变量**：任何时刻，市场 YES 总份数 = NO 总份数

```python
def verify_share_conservation(market_id: str) -> bool:
    """
    份数守恒验证 (每笔交易后执行)
    """
    market = get_market(market_id)

    # 方式1: 从市场汇总数据验证
    assert market.total_yes_shares == market.total_no_shares, \
        f"Share mismatch: YES={market.total_yes_shares}, NO={market.total_no_shares}"

    # 方式2: 从所有用户持仓累加验证 (定期对账)
    total_yes = sum(p.yes_volume for p in get_all_positions(market_id))
    total_no = sum(p.no_volume for p in get_all_positions(market_id))
    assert total_yes == total_no, \
        f"User position mismatch: YES={total_yes}, NO={total_no}"

    # 方式3: Reserve 金额验证（每份 100 美分）
    assert market.reserve_balance == market.total_yes_shares * 100, \
        f"Reserve mismatch: reserve={market.reserve_balance}, expected={market.total_yes_shares * 100}"

    return True
```

### 5.5 单账本模式下的持仓管理特点

| 维度 | 双账本 | 单账本 |
|------|--------|--------|
| 持仓数据结构 | 相同 | 相同 (YES/NO 分别追踪) |
| 创建持仓时机 | 跨账本成交 | Mint 场景 |
| 转移持仓时机 | 同账本成交 | Transfer YES/NO 场景 |
| 销毁持仓时机 | 净额结算 | Burn 场景 + 账户层净额结算 |
| 净额结算触发 | 任何成交后检查 | 任何成交后检查 |

> **关键区别**：单账本模式下，Burn 场景是两个用户主动交易触发的持仓销毁（一个卖 YES，一个卖 NO），而账户层净额结算是同一用户同时持有 YES 和 NO 时的自动抵消。两者都会导致 Reserve 减少和份数销毁。

---

## 六、P3: 订单管理设计

> **风险等级**：中 (P3)
> **设计目标**：正确管理订单生命周期，支持订单转换，保证部分成交正确性

### 6.1 订单数据结构

> **单账本更新**: 增加订单转换层字段，支持 NO 操作映射到 YES 订单簿

```
Order {
    // ═══════════════════════════════════════════════════════
    // 基础字段
    // ═══════════════════════════════════════════════════════
    id: string                  // 订单唯一ID
    market_id: string           // 市场ID
    user_id: string             // 用户ID

    // ═══════════════════════════════════════════════════════
    // 用户原始意图 (API 层接收)
    // ═══════════════════════════════════════════════════════
    original_side: enum {YES, NO}        // 原始方向
    original_direction: enum {BUY, SELL} // 原始买卖
    original_price: int32                // 原始价格 (美分, 1-99)

    // ═══════════════════════════════════════════════════════
    // 订单簿视角 (转换后)
    // ═══════════════════════════════════════════════════════
    book_direction: enum {BUY, SELL}     // 订单簿中的方向
    book_price: int32                    // 订单簿中的价格
    order_type: enum {
        NATIVE_BUY,       // Buy YES → Buy YES
        NATIVE_SELL,      // Sell YES → Sell YES
        SYNTHETIC_BUY,    // Sell NO → Buy YES
        SYNTHETIC_SELL    // Buy NO → Sell YES
    }

    // ═══════════════════════════════════════════════════════
    // 订单类型 (对齐 exchange-core)
    // ═══════════════════════════════════════════════════════
    time_in_force: enum {GTC, IOC, FOK}

    // ═══════════════════════════════════════════════════════
    // 数量与状态
    // ═══════════════════════════════════════════════════════
    quantity: int64             // 委托数量
    filled_qty: int64           // 已成交数量
    frozen_amount: int64        // 冻结金额/持仓
    status: enum {
        PENDING,        // 待处理
        OPEN,           // 挂单中 (仅 GTC)
        PARTIAL_FILLED, // 部分成交
        FILLED,         // 完全成交
        CANCELLED,      // 已取消
        REJECTED        // 已拒绝
    }
    created_at: timestamp
    updated_at: timestamp
}

计算属性:
  remaining_qty = quantity - filled_qty

订单类型映射:
  ┌─────────────────────────────────────────────────────────────┐
  │ 用户操作        │ order_type      │ book_direction │ 转换公式 │
  ├─────────────────────────────────────────────────────────────┤
  │ Buy YES @ P    │ NATIVE_BUY      │ BUY           │ 无转换   │
  │ Sell YES @ P   │ NATIVE_SELL     │ SELL          │ 无转换   │
  │ Buy NO @ P     │ SYNTHETIC_SELL  │ SELL          │ 100 - P  │
  │ Sell NO @ P    │ SYNTHETIC_BUY   │ BUY           │ 100 - P  │
  └─────────────────────────────────────────────────────────────┘
```

### 6.2 订单转换层

**核心职责**：将用户的 NO 操作转换为 YES 订单簿操作

```python
def transform_order(user_order: UserOrderRequest) -> Order:
    """
    订单转换层 - 将用户订单转换为订单簿订单
    """
    order = Order()
    order.id = generate_order_id()
    order.market_id = user_order.market_id
    order.user_id = user_order.user_id
    order.time_in_force = user_order.time_in_force
    order.quantity = user_order.quantity

    # 保存原始意图
    order.original_side = user_order.side
    order.original_direction = user_order.direction
    order.original_price = user_order.price

    if user_order.side == YES:
        if user_order.direction == BUY:
            # Buy YES → 直接入 Buy 队列
            order.order_type = OrderType.NATIVE_BUY
            order.book_direction = BUY
            order.book_price = user_order.price
        else:  # SELL
            # Sell YES → 直接入 Sell 队列
            order.order_type = OrderType.NATIVE_SELL
            order.book_direction = SELL
            order.book_price = user_order.price
    else:  # NO
        if user_order.direction == BUY:
            # Buy NO → 转换为 Sell YES @ (100 - P)
            order.order_type = OrderType.SYNTHETIC_SELL
            order.book_direction = SELL
            order.book_price = 100 - user_order.price
        else:  # SELL
            # Sell NO → 转换为 Buy YES @ (100 - P)
            order.order_type = OrderType.SYNTHETIC_BUY
            order.book_direction = BUY
            order.book_price = 100 - user_order.price

    return order
```

### 6.3 订单生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│                      订单状态机                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                        ┌───────────┐                            │
│                        │  PENDING  │                            │
│                        │  (待处理)  │                            │
│                        └─────┬─────┘                            │
│                              │                                  │
│              ┌───────────────┼───────────────┐                  │
│              ▼               ▼               ▼                  │
│        ┌──────────┐    ┌──────────┐    ┌──────────┐            │
│        │ REJECTED │    │   OPEN   │    │  FILLED  │            │
│        │ (拒绝)   │    │ (挂单中) │    │(完全成交)│            │
│        └──────────┘    └────┬─────┘    └──────────┘            │
│                             │                    ▲              │
│              ┌──────────────┼──────────────┐     │              │
│              ▼              ▼              ▼     │              │
│        ┌──────────┐  ┌───────────┐  ┌──────────┐│              │
│        │CANCELLED │  │ PARTIAL   │  │  FILLED  ││              │
│        │ (取消)   │  │ FILLED    │──┴──────────┘│              │
│        └──────────┘  │(部分成交) │               │              │
│                      └─────┬─────┘               │              │
│                            │                     │              │
│                            └─────────────────────┘              │
│                              继续成交直到完全成交                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.4 订单提交时序与冻结机制

> **设计依据**: 沿用 exchange-core 标准处理方案

**核心原则**：**资金/持仓冻结在订单进入 Sequencer 队列之前同步完成**

```
┌─────────────────────────────────────────────────────────────────┐
│              订单提交时序 (单账本模式)                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  API 层 (同步执行)                                               │
│  ════════════════                                               │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Step 1: 参数校验                                        │   │
│  │  ─────────────────                                       │   │
│  │  · 验证用户存在                                          │   │
│  │  · 验证 Market 有效                                      │   │
│  │  · 验证价格范围 [1, 99]                                  │   │
│  │  · 验证数量 > 0                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          │                                      │
│                          ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Step 2: 订单转换                                        │   │
│  │  ─────────────────                                       │   │
│  │  · 调用 transform_order()                               │   │
│  │  · 确定 order_type, book_direction, book_price          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          │                                      │
│                          ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Step 3: 风控与冻结 (根据 order_type 不同)               │   │
│  │  ─────────────────────────────────                       │   │
│  │  NATIVE_BUY (Buy YES):                                  │   │
│  │    frozen = original_price × quantity                   │   │
│  │    检查: available_balance >= frozen                    │   │
│  │                                                          │   │
│  │  NATIVE_SELL (Sell YES):                                │   │
│  │    frozen = quantity (持仓份数)                         │   │
│  │    检查: yes_volume - yes_pending_sell >= quantity      │   │
│  │                                                          │   │
│  │  SYNTHETIC_SELL (Buy NO):                               │   │
│  │    frozen = original_price × quantity (NO 价格)         │   │
│  │    检查: available_balance >= frozen                    │   │
│  │                                                          │   │
│  │  SYNTHETIC_BUY (Sell NO):                               │   │
│  │    frozen = quantity (NO 持仓份数)                      │   │
│  │    检查: no_volume - no_pending_sell >= quantity        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          │                                      │
│                          ▼                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Step 4: 订单入队                                        │   │
│  │  ─────────────────                                       │   │
│  │  · 订单状态设为 PENDING                                  │   │
│  │  · 发送到 Sequencer 队列                                 │   │
│  │  · 返回订单 ID 给用户                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**冻结规则汇总**:

| order_type | 用户操作 | 冻结物 | 冻结数量 |
|------------|---------|--------|---------|
| NATIVE_BUY | Buy YES @ P | 资金 | P × qty |
| NATIVE_SELL | Sell YES @ P | YES 持仓 | qty |
| SYNTHETIC_SELL | Buy NO @ P | 资金 | P × qty |
| SYNTHETIC_BUY | Sell NO @ P | NO 持仓 | qty |

### 6.5 订单类型支持

> **对齐 exchange-core**: 支持 GTC, IOC, FOK 三种订单类型

| 类型 | 全称 | 说明 | 入簿行为 |
|------|------|------|---------|
| **GTC** | Good-till-Cancel | 标准限价单 | 未成交部分入簿等待 |
| **IOC** | Immediate-or-Cancel | 立即成交或取消 | **不入簿**，未成交部分取消 |
| **FOK** | Fill-or-Kill | 全部成交或全部取消 | **不入簿**，无法全部成交则全部取消 |

```
┌─────────────────────────────────────────────────────────────────┐
│                    订单类型行为对比                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  GTC (Good-till-Cancel) - 标准限价单                            │
│  ───────────────────────────────────                            │
│  · 按指定价格撮合                                                │
│  · 未成交部分入簿等待                                            │
│  · 直到完全成交或用户取消                                        │
│  · 适用场景: 挂单做市、不急于成交                                │
│                                                                 │
│  IOC (Immediate-or-Cancel) - 立即成交或取消                     │
│  ──────────────────────────────────────                         │
│  · 按指定价格立即撮合                                            │
│  · 未成交部分自动取消 (不入簿)                                   │
│  · 适用场景: 快速成交、可接受部分成交                            │
│  · 注意: price 字段起到滑点保护作用                              │
│                                                                 │
│  FOK (Fill-or-Kill) - 全部成交或全部取消                        │
│  ────────────────────────────────────                           │
│  · 必须全部成交，否则全部取消                                    │
│  · 不允许部分成交                                                │
│  · 适用场景: 套利、对冲等需要精确数量的场景                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.6 IOC 订单示例

```
┌─────────────────────────────────────────────────────────────────┐
│                    IOC 订单执行示例 (单账本)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: 用户提交 IOC Buy NO @ 40 × 100份                         │
│  ─────────────────────────────────────                          │
│  转换: IOC Sell YES @ 60 × 100份 (Synthetic Sell)              │
│                                                                 │
│  订单簿状态 (YES):                                              │
│    Buy 队列: [Buy @ 62 × 50, Buy @ 58 × 30, ...]               │
│                                                                 │
│  撮合过程:                                                      │
│  ──────────                                                     │
│  成交条件: 买价 >= 卖价 (60)                                    │
│  第1笔: Buy YES @ 62 × 50份 → 成交 (62 >= 60 ✓) → Mint        │
│  第2笔: Buy YES @ 58 × 30份 → 跳过 (58 < 60 ✗)                 │
│                                                                 │
│  结果:                                                          │
│  ──────                                                         │
│  成交: 50份 (Mint 场景)                                        │
│    买方支付: 62 × 50 = 3100 → Reserve                          │
│    卖方支付: 38 × 50 = 1900 → Reserve                          │
│    买方获得: YES 50份                                          │
│    卖方获得: NO 50份                                           │
│  取消: 50份 (未成交部分自动取消)                                 │
│  返还: 40 × 50 = 2000 美分给用户                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.7 部分成交处理

```python
def handle_partial_fill(order: Order, fill_qty: int64, trade_price: int,
                        scenario: MatchScenario):
    """
    处理部分成交 - 根据订单类型和场景调整
    """
    # 更新订单状态
    order.filled_qty += fill_qty

    if order.filled_qty >= order.quantity:
        order.status = OrderStatus.FILLED
    else:
        order.status = OrderStatus.PARTIAL_FILLED

    # 根据 order_type 调整冻结
    if order.order_type == OrderType.NATIVE_BUY:
        # 买 YES: 冻结的是资金
        frozen_for_fill = order.original_price * fill_qty
        actual_payment = trade_price * fill_qty
        refund = frozen_for_fill - actual_payment

        order.frozen_amount -= frozen_for_fill
        if refund > 0:
            add_available_balance(order.user_id, refund)

    elif order.order_type == OrderType.NATIVE_SELL:
        # 卖 YES: 冻结的是 YES 持仓
        order.frozen_amount -= fill_qty
        # 持仓扣减在成交处理中完成

    elif order.order_type == OrderType.SYNTHETIC_SELL:
        # 买 NO: 冻结的是资金 (NO 价格)
        frozen_for_fill = order.original_price * fill_qty
        no_price = 100 - trade_price
        actual_payment = no_price * fill_qty
        refund = frozen_for_fill - actual_payment

        order.frozen_amount -= frozen_for_fill
        if refund > 0:
            add_available_balance(order.user_id, refund)

    elif order.order_type == OrderType.SYNTHETIC_BUY:
        # 卖 NO: 冻结的是 NO 持仓
        order.frozen_amount -= fill_qty
        # 持仓扣减在成交处理中完成
```

### 6.8 订单取消处理

> **并发安全说明**: 订单取消与撮合的竞态条件由 **单线程 Sequencer 模型** 天然避免

```python
def cancel_order(order_id: str) -> bool:
    """
    取消订单 - 根据订单类型释放冻结
    """
    order = get_order(order_id)

    if order.status not in [OrderStatus.OPEN, OrderStatus.PARTIAL_FILLED]:
        return False  # 不可取消

    with transaction():
        remaining = order.quantity - order.filled_qty

        if order.order_type == OrderType.NATIVE_BUY:
            # 买 YES: 解冻资金
            frozen_remaining = order.original_price * remaining
            add_available_balance(order.user_id, frozen_remaining)
            deduct_frozen_balance(order.user_id, frozen_remaining)

        elif order.order_type == OrderType.NATIVE_SELL:
            # 卖 YES: 解冻 YES 持仓
            position = get_position(order.user_id, order.market_id)
            position.yes_pending_sell -= remaining
            # 解冻后检查是否需要净额结算
            execute_netting_if_needed(position)

        elif order.order_type == OrderType.SYNTHETIC_SELL:
            # 买 NO: 解冻资金 (NO 价格)
            frozen_remaining = order.original_price * remaining
            add_available_balance(order.user_id, frozen_remaining)
            deduct_frozen_balance(order.user_id, frozen_remaining)

        elif order.order_type == OrderType.SYNTHETIC_BUY:
            # 卖 NO: 解冻 NO 持仓
            position = get_position(order.user_id, order.market_id)
            position.no_pending_sell -= remaining
            # 解冻后检查是否需要净额结算
            execute_netting_if_needed(position)

        # 从订单簿移除
        remove_from_orderbook(order)

        # 更新状态
        order.status = OrderStatus.CANCELLED
        order.frozen_amount = 0

    return True
```

### 6.9 单账本订单管理特点

| 维度 | 双账本 | 单账本 |
|------|--------|--------|
| 订单数据结构 | side + direction | + order_type, book_direction, book_price |
| 订单簿 | YES/NO 两个 | YES 一个 |
| NO 订单 | 直接入 NO 订单簿 | 转换后入 YES 订单簿 |
| 冻结规则 | 根据 side/direction | 根据 order_type |
| 撮合逻辑 | 分账本撮合 | 统一 CLOB 撮合 |
| 场景判定 | 路由时确定 | 成交时根据 order_type 确定 |

---

## 七、P4: 结算清算设计

> **风险等级**：中 (P4)
> **设计目标**：正确执行市场结算，公平分配盈亏

### 7.1 市场状态机

```
┌─────────────────────────────────────────────────────────────────┐
│                      市场状态机                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐          │
│  │ DRAFT  │───▶│ LISTED │───▶│TRADING │───▶│ HALTED │          │
│  │ (草稿) │    │(已上线) │    │(交易中) │    │ (暂停) │          │
│  └────────┘    └────────┘    └───┬────┘    └───┬────┘          │
│                                  │             │                │
│                                  ▼             ▼                │
│                             ┌────────┐    ┌────────┐           │
│                             │MATURED │───▶│SETTLING│           │
│                             │ (到期) │    │(结算中) │           │
│                             └────────┘    └───┬────┘           │
│                                               │                 │
│                                               ▼                 │
│                                          ┌────────┐            │
│                                          │SETTLED │            │
│                                          │(已结算) │            │
│                                          └────────┘            │
│                                                                 │
│  特殊状态:                                                       │
│  ┌──────────┐                                                   │
│  │CANCELLED │  可从 TRADING/HALTED 进入 (市场取消)              │
│  │ (已取消) │                                                   │
│  └──────────┘                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 结算流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      结算流程                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Step 1: 锁定市场                                               │
│  ─────────────────                                              │
│  - 市场状态 → SETTLING                                          │
│  - 停止接收新订单                                                │
│  - 停止撮合引擎                                                  │
│                                                                 │
│  Step 2: 清理未成交订单                                          │
│  ──────────────────────                                         │
│  FOR EACH order IN open_orders:                                 │
│    - 取消订单 (根据 order_type 释放冻结)                         │
│    - 解冻用户资金/持仓                                           │
│                                                                 │
│  Step 3: 获取判定结果                                            │
│  ──────────────────                                             │
│  - Oracle 提交结果 (YES 或 NO)                                  │
│  - 可选: 争议期 (允许申诉)                                       │
│                                                                 │
│  Step 4: 执行清算                                                │
│  ────────────────                                               │
│  result = market.outcome  // YES 或 NO                          │
│                                                                 │
│  FOR EACH position IN all_positions:                            │
│    IF position.{result}_volume > 0:                            │
│      // 赢家: 每份获得 100 美分 = $1.00                          │
│      payout = position.{result}_volume × 100                   │
│      add_available_balance(position.user_id, payout)           │
│    // 输家: 持仓归零，无收益                                     │
│                                                                 │
│  Step 5: 验证并关闭                                              │
│  ──────────────────                                             │
│  ASSERT reserve_balance == 0  // 托管已清空                      │
│  - 清空所有持仓记录                                              │
│  - 市场状态 → SETTLED                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 结算代码

```python
def settle_market(market_id: str, outcome: Outcome):
    """
    市场结算
    outcome: YES 或 NO
    """
    market = get_market(market_id)

    assert market.status == MarketStatus.MATURED or market.status == MarketStatus.SETTLING

    with transaction():
        # 1. 锁定市场
        market.status = MarketStatus.SETTLING
        market.outcome = outcome

        # 2. 取消所有未成交订单
        for order in get_open_orders(market_id):
            cancel_order(order.id)

        # 3. 执行清算
        total_payout = 0

        for position in get_all_positions(market_id):
            if outcome == Outcome.YES:
                winning_shares = position.yes_volume
            else:
                winning_shares = position.no_volume

            if winning_shares > 0:
                payout = winning_shares * 100  # 每份 100 美分 = $1.00
                add_available_balance(position.user_id, payout)
                total_payout += payout

            # 清空持仓
            clear_position(position)

        # 4. 验证托管清空
        assert market.reserve_balance == total_payout
        market.reserve_balance = 0

        # 5. 完成结算
        market.status = MarketStatus.SETTLED
        market.settled_at = now()

        emit_event(MarketSettled(market_id, outcome, total_payout))
```

### 7.4 市场取消处理

> **设计依据**:
> - **退款算法**: 使用 `cost_sum` 和 `pnl_pool` 实现精确退款
> - **精度保证**: 避免 `avg_cost` 整数除法导致的精度丢失
> - **手续费处理**: 参考 Kalshi 规则，已收手续费不退还

```python
def cancel_market(market_id: str, reason: str):
    """
    市场取消 - 基于 cost_sum 和 pnl_pool 的精确退款
    """
    market = get_market(market_id)

    with transaction():
        # Phase 1: 取消订单，释放冻结
        for order in get_open_orders(market_id):
            cancel_order(order.id)

        # Phase 2: 强制净额结算
        for position in get_all_positions(market_id):
            netting_qty = min(position.yes_volume, position.no_volume)

            if netting_qty > 0:
                # 按比例计算净额部分的成本
                yes_cost_per_unit = position.yes_cost_sum // position.yes_volume
                no_cost_per_unit = position.no_cost_sum // position.no_volume

                # 减少持仓和成本
                position.yes_volume -= netting_qty
                position.yes_cost_sum -= yes_cost_per_unit * netting_qty
                position.no_volume -= netting_qty
                position.no_cost_sum -= no_cost_per_unit * netting_qty

                # 退还净额资金 (每对 100 美分)
                netting_refund = netting_qty * 100
                add_available_balance(position.user_id, netting_refund)
                market.reserve_balance -= netting_refund

        # Phase 3: 单边持仓按成本比例退款
        available_funds = market.reserve_balance + market.pnl_pool

        total_cost = sum(
            p.yes_cost_sum + p.no_cost_sum
            for p in get_all_positions(market_id)
        )

        if total_cost > 0 and available_funds > 0:
            total_refunded = 0
            positions = list(get_all_positions(market_id))

            for i, position in enumerate(positions):
                user_cost = position.yes_cost_sum + position.no_cost_sum

                if user_cost > 0:
                    if i == len(positions) - 1:
                        refund = available_funds - total_refunded
                    else:
                        refund = (user_cost * available_funds) // total_cost

                    if refund > 0:
                        add_available_balance(position.user_id, refund)
                        total_refunded += refund

                clear_position(position)

        # Phase 4: 市场关闭
        market.reserve_balance = 0
        market.pnl_pool = 0
        market.total_yes_shares = 0
        market.total_no_shares = 0
        market.status = MarketStatus.CANCELLED
        market.cancel_reason = reason
        market.cancelled_at = now()

        emit_event(MarketCancelled(market_id, reason))
```

---

## 八、P5: 性能与可用性设计

> **风险等级**：较低 (P5)
> **设计目标**：保证系统高性能、高可用、可恢复

### 8.1 WAL (Write-Ahead Log) 设计

> **沿用 exchange-core**: Event-sourcing + Deterministic Replay 模式

```
┌─────────────────────────────────────────────────────────────────┐
│                    WAL 事件类型 (单账本)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  事件类型:                                                       │
│  ──────────                                                     │
│  ORDER_PLACED         - 订单创建 (含 order_type 标记)            │
│  ORDER_CANCELLED      - 订单取消                                │
│  ORDER_FILLED         - 订单成交                                │
│  TRADE_MINT           - Mint 场景成交                           │
│  TRADE_TRANSFER_YES   - Transfer YES 场景成交                   │
│  TRADE_TRANSFER_NO    - Transfer NO 场景成交                    │
│  TRADE_BURN           - Burn 场景成交                           │
│  NETTING_EXECUTED     - 账户层净额结算执行                       │
│  MARKET_SETTLED       - 市场结算完成                            │
│  MARKET_CANCELLED     - 市场取消完成                            │
│                                                                 │
│  对比双账本: 移除 TRADE_CROSS_BOOK，改为四种场景事件             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 状态快照设计

```
┌─────────────────────────────────────────────────────────────────┐
│                    状态快照内容 (单账本)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Snapshot {                                                     │
│      sequence_id: long           // WAL 序列号                  │
│      timestamp: datetime                                        │
│                                                                 │
│      // 单账本简化: 只有 YES 订单簿                              │
│      yes_orderbook: {                                          │
│          buy_orders: List<Order>   // 含 order_type 标记       │
│          sell_orders: List<Order>  // 含 order_type 标记       │
│      }                                                          │
│                                                                 │
│      // 用户余额                                                 │
│      user_balances: Map<user_id, Balance>                      │
│                                                                 │
│      // 用户持仓 (YES/NO 分别追踪)                              │
│      user_positions: Map<(user_id, market_id), Position>       │
│                                                                 │
│      // 市场状态                                                 │
│      markets: Map<market_id, MarketState>                      │
│  }                                                              │
│                                                                 │
│  对比双账本: 快照结构简化，只保存单一订单簿                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.3 故障恢复流程

```
恢复步骤:
──────────

1. 加载最新快照
   └── 从磁盘读取 snapshot_{sequence_id}.bin

2. 重放 WAL 日志
   └── 从 sequence_id + 1 开始重放所有事件

3. 验证状态一致性
   └── 执行 verify_all_invariants()

4. 恢复服务
   └── 开始接收新订单
```

### 8.4 熔断机制

```python
class MarketCircuitBreaker:
    """
    市场熔断器
    """
    def __init__(self, market_id: str):
        self.market_id = market_id
        self.is_triggered = False
        self.trigger_reason = None
        self.trigger_context = None
        self.trigger_time = None

    def trigger(self, reason: str, context: Dict[str, Any]) -> bool:
        """
        触发熔断
        """
        if self.is_triggered:
            return False

        self.is_triggered = True
        self.trigger_reason = reason
        self.trigger_context = context
        self.trigger_time = now()

        # 1. 暂停市场交易
        market = get_market(self.market_id)
        market.status = MarketStatus.HALTED

        # 2. 记录诊断信息
        log_alert(
            level="CRITICAL",
            message=f"Circuit breaker triggered: {reason}",
            context=context
        )

        # 3. 发送告警
        emit_event(CircuitBreakerTriggered(
            market_id=self.market_id,
            reason=reason,
            context=context
        ))

        return True


def trigger_circuit_breaker(market_id: str, reason: str, context: Dict[str, Any]) -> None:
    """
    触发熔断的便捷函数
    """
    breaker = get_circuit_breaker(market_id)
    breaker.trigger(reason, context)
```

---

## 九、系统约束与不变量

### 9.1 核心不变量

系统必须在任何时刻满足以下约束：

| # | 不变量 | 公式 | 校验时机 |
|---|--------|------|---------|
| 1 | 份数平衡 | `YES总份数 == NO总份数` | 每笔交易后 |
| 2 | 托管平衡 | `reserve_balance == YES总份数 × 100` (美分) | 每笔交易后 |
| 3 | 成本守恒 | `reserve + pnl_pool == Σ(cost_sum)` | 每笔交易后 |
| 4 | 用户余额非负 | `available + frozen >= 0` | 每次操作后 |
| 5 | 持仓非负 | `volume >= pending_sell >= 0` | 每次操作后 |
| 6 | 成本非负 | `cost_sum >= 0` | 每次操作后 |
| 7 | 价格边界 | `1 <= price <= 99` (美分) | 多层校验 |
| 8 | 整数精确 | 所有金额为整数（美分） | 每次计算后 |
| 9 | 净额完成 | `NOT (yes > 0 AND no > 0)` | 每次交易后(软约束) |
| 10 | 订单转换一致 | `book_price == 100 - original_price` (Synthetic) | 订单创建时 |

### 9.2 单账本特有约束

| # | 不变量 | 说明 |
|---|--------|------|
| 11 | 订单类型一致 | `order_type` 与 `original_side/direction` 匹配 |
| 12 | 场景判定一致 | 场景由 `buy.order_type` 和 `sell.order_type` 唯一确定 |
| 13 | Reserve 变化一致 | Mint +$1, Transfer 0, Burn -$1 |

### 9.3 一致性校验

```python
def verify_all_invariants(market_id: str) -> bool:
    """
    全量不变量校验
    """
    market = get_market(market_id)

    # 不变量 1: 份数平衡
    assert market.total_yes_shares == market.total_no_shares, \
        "Share imbalance detected"

    # 不变量 2: 托管平衡（每份 100 美分）
    assert market.reserve_balance == market.total_yes_shares * 100, \
        "Reserve balance mismatch"

    # 不变量 3: 成本守恒
    total_cost_sum = sum(
        p.yes_cost_sum + p.no_cost_sum
        for p in get_all_positions(market_id)
    )
    assert market.reserve_balance + market.pnl_pool == total_cost_sum, \
        "Cost sum mismatch"

    # 用户级校验
    for position in get_all_positions(market_id):
        user = get_user(position.user_id)

        assert user.available_balance >= 0, "Negative available balance"
        assert user.frozen_balance >= 0, "Negative frozen balance"
        assert position.yes_volume >= position.yes_pending_sell >= 0
        assert position.no_volume >= position.no_pending_sell >= 0

    return True
```

---

## 十、附录

### 附录A: 术语表

| 术语 | 英文 | 定义 |
|------|------|------|
| 美分 | Cent | 价格和金额单位，100 美分 = $1.00 |
| Native 订单 | Native Order | 直接进入订单簿的订单 (Buy YES, Sell YES) |
| Synthetic 订单 | Synthetic Order | 通过转换进入订单簿的订单 (Buy NO, Sell NO) |
| Mint | 铸造 | Native Buy + Synthetic Sell，创建合约对 |
| Transfer | 转手 | 持仓在用户间转移 |
| Burn | 销毁 | Synthetic Buy + Native Sell，销毁合约对 |
| 净额结算 | Auto-Netting | 账户层自动销毁 YES+NO 持仓 |
| Maker | 挂单方 | 先挂出等待成交的订单 |
| Taker | 吃单方 | 主动与现有挂单成交 |
| Reserve | 托管账户 | 系统保管的合约对应资金，每对 YES+NO 合约锁定 $1.00。Mint 时增加，Burn/净额结算时减少。不变量：`reserve_balance == total_shares × 100` |
| pnl_pool | 盈亏池 | 追踪 Transfer 交易中用户盈亏流动的账户（可正可负）。当卖方盈利时减少，亏损时增加。与 Reserve 配合维持不变量：`reserve + pnl_pool == Σ(cost_sum)` |
| cost_sum | 累计成本 | 用户持仓的累计购入成本（美分）。使用累计值而非平均值，避免整数除法精度丢失。对齐 exchange-core 的 `openPriceSum` |
| WAL | Write-Ahead Log | 预写日志 |

### 附录B: 设计决策记录

| 决策 | 选择 | 备选方案 | 理由 |
|------|------|---------|------|
| 订单簿模式 | **单账本 + 转换层** | 双账本独立 | 对齐 exchange-core，简化撮合 |
| 撮合类型 | **四种场景** | 同账本/跨账本 | 逻辑更清晰 |
| NO 操作处理 | **转换为 YES** | 独立 NO 订单簿 | 原生对齐 exchange-core |
| Maker/Taker判定 | 时间优先 | 触发者为Taker | 公平，激励早挂单 |
| 溢价分配 | 给Maker | 给Taker/五五分 | 差异化策略，激励挂单 |
| 净额结算时机 | **账户层同步** | 撮合层处理 | 职责分离，参考 Kalshi |
| 余额冻结 | 按委托价 | 按最差价 | 平衡资金利用率 |
| 价格精度 | 美分制 (1-99) | 基点制 | 对齐 Kalshi |
| 成本存储 | cost_sum (累计) | avg_cost (平均) | 避免精度丢失 |

### 附录C: 版本历史

| 版本 | 日期 | 主要变更 |
|------|------|---------|
| v1.0 | 2025-01-26 | 基于双账本 v4.0 创建单账本设计方案 |
| v1.1 | 2025-01-26 | 修复 SB-001: 净额结算时更新 pnl_pool 以维持不变量；完善术语表定义 |
| v1.2 | 2025-01-26 | 修复 SB-009: 手续费计算基于用户实际支付金额，Synthetic 订单使用 NO 价格 |
| v1.3 | 2025-01-26 | 修复 SB-002: Burn 场景统一代码风格，先计算成本再扣减持仓 |
| v1.4 | 2025-01-26 | 修复 SB-003: 完善 Mint 场景价格优化说明，补充两种 Maker 情况及统一原则 |
| v1.5 | 2025-01-26 | 修复 SB-006: 添加 Self-Trade Prevention (自成交预防) 机制 |
| v1.6 | 2025-01-26 | 修复 SB-010: 取消卖单订单后添加净额结算检查 |
| v1.7 | 2025-01-26 | 修复 SB-004: 完善 Transfer NO 场景注释，明确订单簿视角与用户视角的映射 |
| v1.8 | 2025-01-26 | 修复 SB-008: 添加部分成交与净额结算交互的执行顺序说明 |

### 附录D: exchange-core 集成说明

| 本系统概念 | exchange-core 对应 | 说明 |
|-----------|-------------------|------|
| YES OrderBook | OrderBook | 单一订单簿 (原生对齐) |
| order_type | - | 扩展字段，标记订单来源 |
| PositionRecord | SymbolPositionRecord | 持仓记录 |
| yes_volume | openVolume | 持仓数量 |
| yes_cost_sum | openPriceSum | 累计成本 |
| yes_pending_sell | pendingSellSize | 卖单冻结 |

### 附录E: 与双账本方案对比

| 维度 | 双账本方案 (v4) | 单账本方案 (v1) |
|------|----------------|----------------|
| 订单簿数量 | 2 个 (YES + NO) | 1 个 (YES) |
| NO 订单处理 | 直接入 NO 订单簿 | 转换后入 YES 订单簿 |
| 撮合类型 | 同账本、跨账本 | Mint、Transfer YES、Transfer NO、Burn |
| Exchange-core 对齐 | 需扩展支持双账本 | 原生对齐单账本 |
| 实现复杂度 | 较高 | 较低 |
| 订单数据结构 | side + direction | + order_type, book_direction, book_price |
| 路由逻辑 | 同账本优先 + 跨账本 | 统一 CLOB 撮合 |

---

*文档结束*