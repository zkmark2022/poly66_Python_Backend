# 预测市场 AMM 模块设计

## 冷启动流动性补贴管理系统（独立服务架构）

---

### 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v7.1 (基于 v7.0 漏洞修复 + 对抗性增强) |
| 创建日期 | 2025年1月 |
| 最后更新 | 2026年2月25日 |
| 文档类型 | 模块设计文档 |
| 依赖文档 | docs/撮合系统/单账本撮合引擎设计方案_v1.md |
| 参考文档 | docs/AMM/做市商机器人设计：冷启动与风险补贴模型.md |
| 升级计划 | docs/AMM/AMM_V4_UPGRADE_PLAN.md |

---

### 目录

1. 设计哲学（v4.0 重构）
2. 核心架构（v4.0 三层架构）
3. 三层定价体系（v4.0 新增，v7.0 增强，v7.1：反 Spoofing 微观价格）
4. 两阶段策略（v4.0 新增，v7.0 增强：阶段回退机制）
5. Avellaneda-Stoikov 模型（v7.1 重构：绝对小时时间因子 + γ 生命周期分档）
6. 挂单梯度设计（v4.0 重构）
7. 算法设计（v7.0 定位调整：CPMM 降级为辅助参考）
8. 系统集成（v7.1 增强：原子改单部分成交 fallback）
9. 管理员控制（v4.0 增强）
10. 全栈风控体系（v7.1 增强：LVR 防御 + 伯努利 σ + ONE_SIDE 折价抛售 + 自动复投重构）
11. 完整业务流程（v4.0 增强）
12. 数据结构设计（v4.0 增强）
13. 回测与模拟框架（v7.0 新增）
14. 实施路径（v7.0 更新）
15. 附录（v7.1：原子改单部分成交处理）

---

## 一、设计哲学

### 1.1 核心定位升级

```
┌─────────────────────────────────────────────────────────────────┐
│                    设计哲学 (v4.0 升级)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│           AMM 不是撮合引擎的一部分                               │
│           AMM 是一个"超级机器人用户"                             │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  【v4.0 角色升级】                                               │
│  ──────────────────                                             │
│  从 "流动性架构师" → "流动性补贴的管理者"                       │
│                                                                 │
│  冷启动阶段的核心目标函数 **并非利润最大化**，                   │
│  而是在 **可计算的预算范围内**，通过"做市成本"购买:            │
│                                                                 │
│    1. 可交易性 (Tradability) - 确保随时有对手盘                 │
│    2. 价格发现 (Price Discovery) - 引导价格收敛至公允价值       │
│    3. 盘口质量 (Quality) - 维持盘口深度与稳定性                 │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  【v4.0 设计原则】                                               │
│  ──────────────────                                             │
│  1. 补贴预算化: 将冷启动亏损视为"购买流动性"的必要成本         │
│  2. 分阶段演进: 从探索期过渡到收敛期                            │
│  3. 风控为王: 基于预算的硬熔断机制                              │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  【架构原则（v7.1 修订）】                                       │
│  ──────────────────                                             │
│  1. 独立性: AMM 作为外部服务（Sidecar Service）存在             │
│  2. 业务非侵入: 不修改撮合核心算法(价格-时间优先/四场景清算)    │
│     ⚠️ 但需要撮合引擎提供基础设施扩展                          │
│     (见接口契约v1.3 §3 Impact Matrix: 8项改动)                  │
│  3. 标准+扩展接口: 常规操作用标准API,特权操作用AMM专用API       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 v4.0 核心目标函数

| 目标资产 | 定义 | 度量指标 |
|---------|------|---------|
| **可交易性** | 确保随时有对手盘 | 盘口存在率、响应时间 |
| **价格发现** | 引导价格收敛至公允价值 | 价格稳定性、Oracle偏差 |
| **盘口质量** | 维持盘口深度与稳定性 | 点差、深度、填充率 |

### 1.3 冷启动的经济学视角

```
┌─────────────────────────────────────────────────────────────────┐
│                   冷启动成本的经济学解读                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  传统观点: 做市商的目标是赚取买卖价差                            │
│                                                                 │
│  v4.0 观点: 冷启动阶段的"亏损"是购买流动性的"补贴"             │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  类比:                                                          │
│  • 用户获客成本 (CAC) - 花钱买用户                              │
│  • 做市补贴成本 (MSC) - 花钱买流动性                            │
│                                                                 │
│  关键问题:                                                      │
│  • 不是"能不能不亏损"，而是"如何让每一分钱都有价值"            │
│  • 亏损必须换来: 有效流动性 或 价格信息                         │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  补贴预算化:                                                    │
│  • 设定每日/每市场的亏损预算                                    │
│  • 超出预算自动熔断                                              │
│  • 亏损 ROI 可追踪 (换来多少成交量/用户)                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.4 为什么这样设计？（保留）

| 优势 | 说明 |
|------|------|
| 零侵入 | 撮合引擎代码零修改，降低系统风险 |
| 真正独立 | AMM可以独立部署、独立升级、独立回滚 |
| 复用现有机制 | AMM 只需挂卖单，通过标准 API 与撮合引擎交互 |
| 灵活策略 | 可以实现任意复杂的做市策略 |
| 易于测试 | 可以在测试环境单独验证AMM行为 |

### 1.5 关键洞察：解决冷启动的对手盘问题（保留）

```
┌─────────────────────────────────────────────────────────────────┐
│                    AMM 的核心价值                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  冷启动阶段的核心问题:                                           │
│  ────────────────────                                           │
│  • 用户想 Buy YES，但没有人 Sell YES                            │
│  • 用户想 Buy NO，但没有人 Sell NO                              │
│  • 市场无法形成初始价格（定概率）                                │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  AMM 的解决方案:                                                 │
│  ──────────────                                                 │
│  AMM 通过标准 API 挂出 Sell YES 和 Sell NO 订单                 │
│                                                                 │
│    → 用户可以 Buy YES（有对手盘了）                             │
│    → 用户可以 Buy NO（有对手盘了）                              │
│    → 市场有了初始流动性和定价                                   │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  v4.0 关注的核心问题:                                            │
│  ──────────────────                                             │
│  1. 定价: 三层定价体系 (外部锚定 + 微观价格 + 后验学习)         │
│  2. 策略: 探索—收敛两阶段策略                                   │
│  3. 报价: Avellaneda-Stoikov 模型 + 非对称梯度                  │
│  4. 风控: 全栈三道防线                                          │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  AMM 不需要关心:                                                 │
│  ────────────────                                               │
│  • 撮合引擎内部如何处理订单（单账本/双账本）                     │
│  • 订单转换逻辑（NO 转 Synthetic YES 等）                       │
│  • 具体撮合场景（Mint/Transfer/Burn）                           │
│                                                                 │
│  这些对 AMM 完全透明，AMM 只需通过标准 API 交互。               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、核心架构

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        AMM 系统架构 (v5.0)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                     核心交易系统                          │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │                    撮合引擎                       │    │    │
│  │  │                                                  │    │    │
│  │  │    ┌──────────────────────────────────────┐     │    │    │
│  │  │    │            订单簿 (黑盒)              │     │    │    │
│  │  │    │                                      │     │    │    │
│  │  │    │   AMM 的 Sell YES / Sell NO 订单    │     │    │    │
│  │  │    │              ↓                       │     │    │    │
│  │  │    │   等待用户 Buy YES / Buy NO 成交    │     │    │    │
│  │  │    │                                      │     │    │    │
│  │  │    │   (内部实现对 AMM 透明)              │     │    │    │
│  │  │    └──────────────────────────────────────┘     │    │    │
│  │  │                                                  │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  │                         ▲                               │    │
│  │                         │ 标准 API                      │    │
│  │                         │ (下单/撤单/改单/查询)         │    │
│  └─────────────────────────┼───────────────────────────────┘    │
│                            │                                    │
│  ══════════════════════════╪════════════════════════════════    │
│                            │                                    │
│  ┌─────────────────────────┼───────────────────────────────┐    │
│  │                         ▼                               │    │
│  │              AMM 独立服务 (Sidecar)                      │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │                                                  │    │    │
│  │  │  ┌───────────┐  ┌───────────┐  ┌───────────┐    │    │    │
│  │  │  │  Market   │  │ Strategy  │  │  Order    │    │    │    │
│  │  │  │ Listener  │──▶│  Engine   │──▶│ Manager   │    │    │    │
│  │  │  │  成交监听 │  │  定价策略 │  │  订单管理 │    │    │    │
│  │  │  └───────────┘  └───────────┘  └───────────┘    │    │    │
│  │  │        │              │              │           │    │    │
│  │  │        │      ┌───────┴───────┐      │           │    │    │
│  │  │        │      │   风险控制     │      │           │    │    │
│  │  │        │      │ • 库存平衡    │      │           │    │    │
│  │  │        │      │ • 点差管理    │      │           │    │    │
│  │  │        │      │ • 套利防护    │      │           │    │    │
│  │  │        │      └───────────────┘      │           │    │    │
│  │  │        └──────────────┼──────────────┘           │    │    │
│  │  │                       ▼                          │    │    │
│  │  │            ┌─────────────────────┐               │    │    │
│  │  │            │  Redis (主存储)      │               │    │    │
│  │  │            │  库存 + 挂单状态     │               │    │    │
│  │  │            └─────────────────────┘               │    │    │
│  │  │                                                  │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  │                         ▲                               │    │
│  │            ┌────────────┴────────────┐                  │    │
│  │            │        管理后台          │                  │    │
│  │            │  • 启用/关闭            │                  │    │
│  │            │  • 注资/提取            │                  │    │
│  │            │  • 参数配置            │                  │    │
│  │            └─────────────────────────┘                  │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 v4.0 三层模块架构

```
┌─────────────────────────────────────────────────────────────────┐
│                   AMM v4.0 三层模块架构                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Connector Layer (连接层)                    │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • WebSocket/REST 交互封装                               │   │
│  │  • API 限制处理 (Rate Limit、重连)                       │   │
│  │  • 订单状态追踪                                          │   │
│  │  • 市场数据订阅与解析                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓ ↑                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Strategy Layer (策略层)                     │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • 纯逻辑层，无 I/O 操作                                 │   │
│  │  • 输入: MarketState (OrderBook, Trades, Inventory)      │   │
│  │  • 输出: OrderIntent[] (Place, Cancel, Modify)          │   │
│  │  • 核心组件:                                             │   │
│  │    - ThreeLayerPricing (三层定价)                        │   │
│  │    - PhaseManager (阶段管理)                             │   │
│  │    - ASEngine (A-S 报价引擎)                             │   │
│  │    - GradientEngine (梯度计算)                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓ ↑                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │          Risk Middleware Layer (风控中间件层)            │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • 独立于策略，拦截所有订单指令                          │   │
│  │  • 决策: 放行 / 修改参数 / 拒绝                         │   │
│  │  • 核心组件:                                             │   │
│  │    - DefenseStack (三道防线)                             │   │
│  │    - BudgetManager (预算管理)                            │   │
│  │    - AuditLogger (决策留痕)                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 组件依赖关系

```
                    ┌─────────────┐
                    │ AMM Service │
                    └──────┬──────┘
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
    ┌──────────┐    ┌──────────┐    ┌──────────────┐
    │Connector │    │ Strategy │    │Risk Middleware│
    └────┬─────┘    └────┬─────┘    └──────┬───────┘
         │               │                  │
    ┌────┴────┐    ┌─────┴─────────────────┴─────┐
    │WebSocket│    │                              │
    │  REST   │    ▼                              ▼
    └─────────┘ ┌──────────┐ ┌──────────┐ ┌─────────────┐
                │3-Layer   │ │PhaseMan. │ │DefenseStack │
                │ Pricing  │ │          │ │             │
                └────┬─────┘ └────┬─────┘ └──────┬──────┘
                     │            │              │
                ┌────┴────┐ ┌─────┴─────┐ ┌──────┴──────┐
                │ASEngine │ │ Gradient  │ │BudgetManager│
                │         │ │  Engine   │ │             │
                └─────────┘ └───────────┘ └─────────────┘
```

### 2.4 核心组件说明

| 组件 | 职责 | 技术建议 |
|------|------|----------|
| Market Listener | 订阅成交事件流，监听订单簿变化 | Kafka/Redis Subscribe |
| Strategy Engine | 基于库存计算目标挂单价格和数量 | 纯算法模块，**必须从Redis读取** |
| Order Manager | 差量更新挂单，发送下单/撤单/改单指令 | API Client，支持原子改单 |
| Redis | **主存储**：实时库存、当前挂单状态 | 毫秒级读写，策略引擎唯一数据源 |
| PostgreSQL | **备份存储**：持久化、审计日志、对账 | 异步写入，不阻塞交易流程 |
| **ThreeLayerPricing** | **v4.0**: 三层定价引擎 | 外部锚定 + 微观价格 + 后验学习 |
| **PhaseManager** | **v4.0**: 阶段管理器 | 探索期 ↔ 收敛期切换 |
| **ASEngine** | **v4.0**: A-S 报价引擎 | 保留价格 + 非对称梯度 |
| **DefenseStack** | **v4.0**: 三道防线风控 | 预算熔断 + 库存阈值 + 微观结构 |

> ⚠️ **v3.0 架构变更**：策略引擎必须直接从 Redis 读取库存进行计算，不能读 PostgreSQL。毫秒级的做市策略等不起磁盘 IO。

### 2.5 AMM账户模型

```
┌─────────────────────────────────────────────────────────────────┐
│                        AMM 账户模型                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  AMM 在系统中是一个特殊用户:                                     │
│                                                                 │
│  User {                                                         │
│    id: "AMM_SYSTEM_001",                                        │
│    type: "AMM",              // 特殊用户类型                     │
│    balance: 100000,          // 可用余额（美分）= $1000          │
│    frozenBalance: 50000,     // 冻结余额（挂单占用，美分）       │
│  }                                                              │
│                                                                 │
│  AMM 的持仓和普通用户一样:                                       │
│                                                                 │
│  Position {                                                     │
│    userId: "AMM_SYSTEM_001",                                    │
│    marketId: "market_001",                                      │
│    side: "YES",                                                 │
│    shares: 800,              // AMM 持有的 Yes 份数              │
│  }                                                              │
│                                                                 │
│  Position {                                                     │
│    userId: "AMM_SYSTEM_001",                                    │
│    marketId: "market_001",                                      │
│    side: "NO",                                                  │
│    shares: 1200,             // AMM 持有的 No 份数               │
│  }                                                              │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  关键点: 撮合引擎完全不知道这是 AMM，它只看到:                    │
│         "有一个用户在不停地挂卖单"                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、三层定价体系 (v4.0 新增)

### 3.1 设计理念

不要将单一来源视为真理，而是构建一个加权信号系统。

```
┌─────────────────────────────────────────────────────────────────┐
│                三层参考价体系 (3-Layer Pricing Stack)            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 1: 外部锚定价 (Anchor / Prior)                    │   │
│  │  ─────────────────────────────────────────────           │   │
│  │  来源: 外部交易所价格、OTC成交价、民调概率                │   │
│  │  作用: t=0 时刻的"先验概率"，划定初始报价上下边界        │   │
│  │  权重: 仅在初始化阶段使用，随后快速衰减                   │   │
│  │  公式: weight_anchor = w₀ × max(0, 1 - t/τ)              │   │
│  │        τ = 衰减时间常数 (默认 1 小时)                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 2: 簿内微观价 (Microprice / Order-book Signal)    │   │
│  │  ─────────────────────────────────────────────           │   │
│  │  公式: P_micro = (V_b × P_a + V_a × P_b) / (V_b + V_a)   │   │
│  │        V_a = Ask 侧挂单量, V_b = Bid 侧挂单量            │   │
│  │        P_a = Best Ask, P_b = Best Bid                    │   │
│  │  作用: 捕捉毫秒级微观供需压力                             │   │
│  │  优势: 比中间价更能预测未来1秒内的价格走势               │   │
│  │  前提: 盘口深度 ≥ 最小深度要求 (v7.0: 非 AMM 深度)      │   │
│  │                                                          │   │
│  │  ⚠️ v7.1 反 Spoofing 防护:                                │   │
│  │  • 只计算 Best 前 3 档挂单量，过滤远价深水区虚假意图      │   │
│  │  • 距 Best Bid/Ask 越远的挂单，权重指数衰减               │   │
│  │    权重: w_i = e^(-λ × distance_i), λ=0.5                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Layer 3: 交易驱动的后验价 (Posterior / Learning)        │   │
│  │  ─────────────────────────────────────────────           │   │
│  │  逻辑: 这是最真实的信号                                  │   │
│  │  机制: 根据成交方向、强度、被打中频率更新内部公允价      │   │
│  │  公式: P_post(t) = P_post(t-1) + α × (P_trade - P_post)  │   │
│  │        α = 学习率 (默认 0.1)                             │   │
│  │  关键: 如果卖单被连续吃掉，立即上调中心价                │   │
│  │        （而非仅补充卖单，那是送钱）                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 加权公允价格计算

```python
class ThreeLayerPricing:
    """三层定价引擎"""

    def __init__(self, config: ThreeLayerPricingConfig):
        self.config = config
        self.posterior_price = None  # 后验价格，需要初始化
        self._recent_trade_times = []  # v7.0: 用于自适应学习率

    def calculate_fair_price(
        self,
        anchor_price: int,          # Layer 1: 外部锚定价（美分）
        microprice: int,            # Layer 2: 簿内微观价（美分）
        time_since_start_ms: int,   # 距启动的时间（毫秒）
        non_amm_depth: int = 0      # v7.0: 非 AMM 盘口深度（份数）
    ) -> int:
        """
        计算三层加权公允价格（v7.0: 修复微观价格循环引用）

        Returns:
            fair_price: 加权公允价格（美分）
        """
        # Layer 1 权重：随时间指数衰减
        decay_ratio = time_since_start_ms / self.config.anchor_decay_ms
        anchor_weight = self.config.anchor_initial_weight * max(0, 1 - decay_ratio)

        # v7.0: Layer 2 权重：根据非 AMM 盘口深度动态调整
        # 修复循环引用: 冷启动阶段盘口几乎全是 AMM 自己的挂单，
        # 微观价格反映的是 AMM 自己的报价，形成自我循环。
        # 仅当非 AMM 挂单达到最小深度要求时，才激活微观价格。
        if non_amm_depth >= self.config.microprice_min_depth:
            micro_weight = self.config.microprice_weight
        else:
            micro_weight = 0.0  # 深度不足，禁用微观价格

        # Layer 3 权重：剩余权重
        posterior_weight = 1.0 - anchor_weight - micro_weight

        # 如果后验价格未初始化，使用锚定价
        if self.posterior_price is None:
            self.posterior_price = anchor_price

        # 加权计算
        fair_price = (
            anchor_price * anchor_weight +
            microprice * micro_weight +
            self.posterior_price * posterior_weight
        )

        return int(fair_price)

    def update_posterior(self, trade_price: int, trade_direction: str):
        """
        根据成交更新后验价格（v7.0: 自适应学习率）

        Args:
            trade_price: 成交价格（美分）
            trade_direction: 'BUY' 或 'SELL'（从用户视角）
        """
        if self.posterior_price is None:
            self.posterior_price = trade_price
            return

        # v7.0: 自适应学习率
        # 成交稀疏时提高 α 快速跟踪，成交密集时降低 α 平滑噪声
        alpha = self._adaptive_learning_rate()

        if trade_direction == 'BUY':
            # 用户买入，说明我们卖便宜了，上调后验价
            adjustment = alpha * (trade_price - self.posterior_price + 1)
        else:
            # 用户卖出，说明我们买贵了，下调后验价
            adjustment = alpha * (trade_price - self.posterior_price - 1)

        self.posterior_price = int(self.posterior_price + adjustment)

        # 边界保护
        self.posterior_price = max(5, min(95, self.posterior_price))

        # 记录成交时间用于自适应学习率计算
        self._recent_trade_times.append(current_time_ms())

    def _adaptive_learning_rate(self) -> float:
        """
        v7.0: 自适应学习率计算

        公式: α = base_α / sqrt(trades_per_minute + 1)

        效果:
          - 0 笔/分钟 → α = base_α (如 0.15)
          - 3 笔/分钟 → α = base_α / 2 (如 0.075)
          - 15 笔/分钟 → α = base_α / 4 (如 0.0375)

        原因:
          - 冷启动阶段成交稀疏，每笔成交信息量大，需要快速跟踪
          - 收敛期成交密集，单笔成交噪声大，需要平滑处理
        """
        import math

        # 计算最近 1 分钟内的成交笔数
        cutoff = current_time_ms() - 60000
        self._recent_trade_times = [
            t for t in self._recent_trade_times if t >= cutoff
        ]
        trades_per_minute = len(self._recent_trade_times)

        alpha = self.config.base_learning_rate / math.sqrt(trades_per_minute + 1)

        # 下限保护: 不低于 0.02，避免完全不学习
        # 上限保护: 不高于 0.3，避免单笔成交造成价格跳变
        return max(0.02, min(0.3, alpha))


class ThreeLayerPricingConfig:
    """三层定价配置（v7.0 增强）"""

    # Layer 1: 外部锚定价
    anchor_initial_weight: float = 0.7    # 初始权重 70%
    anchor_decay_ms: int = 3600000        # 衰减时间 1 小时

    # Layer 2: 簿内微观价
    microprice_weight: float = 0.2        # 固定权重 20%
    microprice_min_depth: int = 10        # 最小深度要求（份）

    # Layer 3: 后验学习价 (v7.0: 自适应学习率)
    base_learning_rate: float = 0.15      # 基础学习率 (v7.0: 替代固定 0.1)
    # 实际 α = base / sqrt(trades_per_minute + 1)
    # 0笔/分钟 → α=0.15, 3笔 → α≈0.075, 15笔 → α≈0.0375
```

### 3.3 微观价格计算示例

```
场景: 当前盘口状态

       Bids (买单)          |         Asks (卖单)
  ─────────────────────────|─────────────────────────
   价格    数量              |    价格    数量
   48      100               |    52      50
   47      150               |    53      80
   46      200               |    54      120

Best Bid: P_b = 48, V_b = 100
Best Ask: P_a = 52, V_a = 50

中间价 (Mid Price):
  Mid = (48 + 52) / 2 = 50

微观价格 (Microprice):
  P_micro = (V_b × P_a + V_a × P_b) / (V_b + V_a)
          = (100 × 52 + 50 × 48) / (100 + 50)
          = (5200 + 2400) / 150
          = 7600 / 150
          = 50.67 ≈ 51

解读:
  微观价格 (51) > 中间价 (50)
  → Bid 侧挂单量更大，说明买压更强
  → 预测短期内价格可能上涨
  → AMM 应该稍微上调卖单价格
```

---

## 四、探索—收敛两阶段策略 (v4.0 新增)

### 4.1 两阶段概述

```
┌─────────────────────────────────────────────────────────────────┐
│              探索—收敛两阶段策略 (Exploration & Stabilization)   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   时间轴:                                                       │
│   ═══════════════════════════════════════════════════════════   │
│   t=0                                                    t=T    │
│    │←─────── 探索期 ────────→│←────── 收敛期 ────────→│        │
│    │                         │                         │        │
│    │  宽点差 + 小单          │  窄点差 + 正常单        │        │
│    │  线性梯度               │  几何梯度               │        │
│    │  高频撤单               │  事件驱动撤单           │        │
│    │                         │                         │        │
│    │  目标: 探测真实需求     │  目标: 提供优质体验     │        │
│    │  预算: 信息获取成本     │  预算: 流动性维护成本   │        │
│                                                                 │
│   阶段切换触发条件 (满足任一):                                   │
│   ─────────────────────────────────────────                     │
│   • 累计成交量 ≥ 阈值 (如 200 份)                               │
│   • 价格稳定窗口内波动 < 阈值 (如 15分钟内 < 3%)               │
│   • 探索期时间到期 (如 1 小时)                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 阶段 1: 探索期 (Exploration)

**行为特征:**

| 维度 | 设置 | 原因 |
|------|------|------|
| 点差 | 宽 (5-10 美分) | 防止被套利，降低试错成本 |
| 单量 | 小 (基准的 25%) | 限制单笔亏损 |
| 梯度 | 线性 | 风险线性可控，便于人工核查 |
| 撤单 | 高频 (10-30秒) | 快速响应市场变化 |

**探索期参数:**

```python
class ExplorationConfig:
    """探索期配置"""

    # 点差设置
    spread: int = 5                      # 宽点差 5 美分

    # 数量设置
    qty_ratio: float = 0.25              # 正常量的 25%

    # 梯度设置
    gradient_type: str = "LINEAR"        # 线性梯度
    linear_step: int = 1                 # 每档递增 1 美分
    levels: int = 5                      # 5 档

    # 撤单周期
    cancel_interval_ms: int = 20000      # 20 秒

    # 退出条件
    max_duration_ms: int = 3600000       # 最长 1 小时
    min_volume: int = 200                # 最少成交 200 份
    price_stability_window_ms: int = 900000  # 稳定窗口 15 分钟
    price_stability_threshold: float = 0.03  # 波动 < 3% 视为稳定
```

**探索期挂单示例:**

```
假设: fair_price = 50 美分, spread = 5 美分, qty = 25 份 (正常的25%)

Sell YES 阶梯 (线性, 倒金字塔数量):
┌────────┬────────┬────────┐
│ 档位   │  价格  │  数量  │
├────────┼────────┼────────┤
│  1     │  55    │   25   │
│  2     │  56    │   30   │
│  3     │  57    │   35   │
│  4     │  58    │   40   │
│  5     │  59    │   45   │
└────────┴────────┴────────┘

Sell NO 阶梯 (对应 Buy YES 的对手盘):
YES价格 + NO价格 = 100
┌────────┬──────────┬──────────┬────────┐
│ 档位   │ YES价格  │ NO价格   │  数量  │
├────────┼──────────┼──────────┼────────┤
│  1     │  45      │  55      │   25   │
│  2     │  44      │  56      │   30   │
│  3     │  43      │  57      │   35   │
│  4     │  42      │  58      │   40   │
│  5     │  41      │  59      │   45   │
└────────┴──────────┴──────────┴────────┘
```

### 4.3 阶段 2: 收敛期 (Stabilization)

**行为特征:**

| 维度 | 设置 | 原因 |
|------|------|------|
| 点差 | 窄 (1-3 美分) | 提供优质交易体验 |
| 单量 | 正常 (100%) | 提供充足流动性 |
| 梯度 | 几何 | 资金效率高，尾部风险保护 |
| 撤单 | 事件驱动 | 减少不必要操作 |

**收敛期参数:**

```python
class StabilizationConfig:
    """收敛期配置"""

    # 点差设置
    spread: int = 2                      # 窄点差 2 美分

    # 数量设置
    qty_ratio: float = 1.0               # 正常量 100%

    # 梯度设置
    gradient_type: str = "GEOMETRIC"     # 几何梯度
    geometric_ratio: float = 1.05        # 每档价格 × 1.05
    levels: int = 5                      # 5 档
    qty_decay: float = 0.7               # 数量衰减系数

    # 撤单触发
    cancel_on_trade: bool = True         # 成交后重新挂单
    cancel_on_price_move: float = 0.02   # 价格移动 2% 后重挂
    max_order_age_ms: int = 300000       # 最长挂单时间 5 分钟
```

**收敛期挂单示例:**

```
假设: fair_price = 50 美分, spread = 2 美分, base_qty = 100 份

Sell YES 阶梯 (几何, 指数衰减数量):
价格公式: P_i = 52 × 1.05^i
数量公式: Q_i = 100 × 0.7^i

┌────────┬────────┬────────┐
│ 档位   │  价格  │  数量  │
├────────┼────────┼────────┤
│  1     │  52    │  100   │  ← 最佳报价，数量最大
│  2     │  55    │   70   │
│  3     │  58    │   49   │
│  4     │  61    │   34   │
│  5     │  64    │   24   │  ← 尾部保护，防Flash Crash
└────────┴────────┴────────┘

特点:
• 资金效率高：5 档覆盖 52-64 的价格区间 (24%)
• 尾部保护：即使价格暴涨到 64，仍有 24 份流动性
• 鼓励小单：第一档量最大，大单需穿越多档
```

### 4.4 阶段管理器

```python
class PhaseManager:
    """阶段管理器"""

    def __init__(
        self,
        exploration_config: ExplorationConfig,
        stabilization_config: StabilizationConfig,
        rollback_config: 'PhaseRollbackConfig' = None  # v7.0: 回退配置
    ):
        self.exploration = exploration_config
        self.stabilization = stabilization_config
        self.config_rollback = rollback_config or PhaseRollbackConfig()
        self.current_phase = "EXPLORATION"
        self.start_time_ms = current_time_ms()
        self.total_volume = 0
        self.price_history = []

    def get_current_config(self) -> dict:
        """获取当前阶段的配置"""
        if self.current_phase == "EXPLORATION":
            return {
                'spread': self.exploration.spread,
                'qty_ratio': self.exploration.qty_ratio,
                'gradient_type': self.exploration.gradient_type,
                'cancel_interval_ms': self.exploration.cancel_interval_ms
            }
        else:
            return {
                'spread': self.stabilization.spread,
                'qty_ratio': self.stabilization.qty_ratio,
                'gradient_type': self.stabilization.gradient_type,
                'cancel_interval_ms': None  # 事件驱动
            }

    def on_trade(self, qty: int, price: int):
        """成交回调"""
        self.total_volume += qty
        self.price_history.append({
            'time': current_time_ms(),
            'price': price
        })
        self._check_phase_transition()

    def _check_phase_transition(self):
        """检查是否应该切换阶段"""
        if self.current_phase != "EXPLORATION":
            return

        elapsed_ms = current_time_ms() - self.start_time_ms

        # 条件 1: 时间到期
        if elapsed_ms >= self.exploration.max_duration_ms:
            self._transition_to_stabilization("TIME_EXPIRED")
            return

        # 条件 2: 成交量达标
        if self.total_volume >= self.exploration.min_volume:
            self._transition_to_stabilization("VOLUME_REACHED")
            return

        # 条件 3: 价格稳定
        if self._is_price_stable():
            self._transition_to_stabilization("PRICE_STABLE")
            return

    def _is_price_stable(self) -> bool:
        """检查价格是否稳定"""
        window_ms = self.exploration.price_stability_window_ms
        threshold = self.exploration.price_stability_threshold

        # 获取窗口内的价格
        cutoff = current_time_ms() - window_ms
        window_prices = [
            p['price'] for p in self.price_history
            if p['time'] >= cutoff
        ]

        if len(window_prices) < 10:
            return False

        max_p = max(window_prices)
        min_p = min(window_prices)
        mid_p = (max_p + min_p) / 2

        volatility = (max_p - min_p) / mid_p
        return volatility < threshold

    def _transition_to_stabilization(self, reason: str):
        """切换到收敛期"""
        self.current_phase = "STABILIZATION"
        self._stabilization_start_time = current_time_ms()
        log_info(f"Phase transition: EXPLORATION → STABILIZATION, reason={reason}")

    # ════════════════════════════════════════════════════════
    # v7.0 新增: 阶段回退机制 (Emergency Rollback)
    # ════════════════════════════════════════════════════════

    def check_emergency_rollback(self, recent_volatility: float, daily_pnl: int):
        """
        v7.0: 检查是否需要从收敛期回退到紧急探索期

        触发条件 (满足任一):
        1. 价格剧烈波动: 5分钟内波动 > 10%
        2. 单日亏损超过预算的 50%
        3. 库存在短时间内单向急剧变化

        回退后行为:
        - 立即切换到探索期的宽点差+小单量参数
        - 设置冷却期 (默认 10 分钟)，防止频繁切换
        - 冷却期后如条件满足，可再次进入收敛期
        """
        if self.current_phase != "STABILIZATION":
            return

        # 冷却期检查: 防止频繁在两个阶段间震荡
        if hasattr(self, '_last_rollback_time'):
            cooldown_ms = self.config_rollback.cooldown_ms
            if current_time_ms() - self._last_rollback_time < cooldown_ms:
                return

        should_rollback = False
        reason = ""

        # 条件 1: 价格剧烈波动
        if recent_volatility > self.config_rollback.volatility_threshold:
            should_rollback = True
            reason = f"HIGH_VOLATILITY({recent_volatility:.2%})"

        # 条件 2: 单日亏损超过预算 50%
        if daily_pnl < -self.config_rollback.pnl_rollback_threshold:
            should_rollback = True
            reason = f"EXCESSIVE_LOSS({daily_pnl})"

        if should_rollback:
            self._rollback_to_exploration(reason)

    def _rollback_to_exploration(self, reason: str):
        """回退到紧急探索期"""
        self.current_phase = "EXPLORATION"
        self._last_rollback_time = current_time_ms()
        # 重置成交量和价格历史，允许重新进入收敛期
        self.total_volume = 0
        self.price_history = []
        self.start_time_ms = current_time_ms()
        log_warn(f"EMERGENCY ROLLBACK: STABILIZATION → EXPLORATION, reason={reason}")


class PhaseRollbackConfig:
    """v7.0: 阶段回退配置"""
    volatility_threshold: float = 0.10     # 5分钟波动 > 10% 触发回退
    pnl_rollback_threshold: int = 50000    # 亏损超过 $500（预算50%）触发回退
    cooldown_ms: int = 600000              # 回退冷却期 10 分钟
```

---

## 五、Avellaneda-Stoikov 模型 (v4.0 新增)

### 5.1 保留价格 (Reservation Price)

做市商的核心任务是管理库存风险。Avellaneda-Stoikov 模型提供了数学框架。

```
┌─────────────────────────────────────────────────────────────────┐
│                保留价格公式 (Reservation Price)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  核心公式 (v7.1 重构):                                          │
│  ═════════════════════                                          │
│                                                                 │
│       r(s, q, σ, h) = s - q · γ · σ² · τ(h)                    │
│                                                                 │
│       τ(h) = h / (h + κ)         (时间衰减函数)                 │
│                                                                 │
│  参数说明:                                                      │
│  ──────────                                                     │
│    r = 保留价格 (Reservation Price)                             │
│    s = 市场公允价格 (来自三层定价)                              │
│    q = 库存偏斜 = (YES - NO) / (YES + NO)，范围 [-1, 1]        │
│    γ = 风险厌恶系数 (v7.1: 按市场生命周期分档)                  │
│    σ = 价格波动率 (v7.1: 美分单位，伯努利衰减)                  │
│    h = 距结算剩余小时数 (绝对值，如 720h, 48h, 2h)              │
│    κ = 时间平滑常数 (默认 24h)，控制衰减曲线的"拐点"           │
│    τ(h) = 时间因子，范围 (0, 1)，h→∞ 时趋近 1                  │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  v7.1 时间因子重构说明:                                         │
│  ────────────────────────                                       │
│  旧公式 (T-l) 将时间归一化到 [0,1]，存在两个问题:              │
│  ① 1天市场和6个月市场的 (T-l)=0.5 含义完全不同                  │
│  ② 长期市场的 (T-l) 变化极慢，短期市场变化极快，γ 无法通用     │
│                                                                 │
│  新方案: τ(h) = h/(h+κ) 双曲函数                                │
│  ① h 用绝对小时，消除市场长度差异                                │
│  ② κ=24h: h>24h 时 τ>0.5，调整充分; h<24h 时 τ 快速衰减        │
│  ③ γ 按市场生命周期分档，进一步适配不同周期                      │
│                                                                 │
│  核心直觉:                                                      │
│  ──────────                                                     │
│  当你持有过多某种资产时，你的"心理卖价"和"心理买价"都应低于    │
│  市场价。这会诱导市场买走你的库存，同时你也更难买入新库存。     │
│                                                                 │
│  时间因子含义 (新):                                              │
│  ──────────────────                                              │
│  • h >> κ (远离结算): τ ≈ 1，调整幅度充分                       │
│  • h = κ (距结算 1 天): τ = 0.5，调整减半                       │
│  • h → 0 (临近结算): τ → 0，调整消失，Oracle Guard 接管         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 v7.1 参数标定：时间因子重构 + 生命周期分档

> ⚠️ **v7.0 → v7.1 重要修正**：
> 1. **σ 量纲**：从无量纲 log-returns 改为绝对美分（伯努利方差衰减，详见 10.8 节）
> 2. **时间因子**：从归一化 (T-l) ∈ [0,1] 改为绝对小时双曲衰减 τ(h) = h/(h+κ)
> 3. **γ 分档**：按市场总生命周期分三档，不再使用单一常数
>
> **γ 分档策略**：
>
> | 市场生命周期 | γ 推荐值 | 说明 |
> |-------------|---------|------|
> | 短期 (< 7 天) | 2.0 ~ 3.0 | 时间紧迫，需要快速卸载库存 |
> | 中期 (7 ~ 90 天) | 1.0 ~ 2.0 | 标准做市场景，推荐起步 γ=1.5 |
> | 长期 (> 90 天) | 0.5 ~ 1.0 | 时间充裕，过度调整会损失利润 |

```
场景: 预测市场 "某候选人是否当选"
(v7.1: σ 量纲美分 + 时间因子 τ(h) = h/(h+κ))

═════ 示例 1: 中期市场标准场景 ═════

已知条件:
  s = 50 美分 (三层定价得出的公允价)
  YES库存 = 700 份, NO库存 = 300 份
  q = (700 - 300) / (700 + 300) = 0.4 (偏向 YES)
  γ = 1.5 (中期市场推荐起步值)
  σ = 3 美分 (伯努利方差衰减后，P=50 处)
  h = 720 小时 (距结算 30 天)
  κ = 24 小时 (时间平滑常数)

计算:
  τ(h) = 720 / (720 + 24) = 0.968 (远离结算，时间因子接近 1)
  r = s - q · γ · σ² · τ(h)
    = 50 - 0.4 × 1.5 × 9 × 0.968
    = 50 - 5.23
    = 44.77 ≈ 45 美分

  → 保留价格 (45) 低于公允价格 (50)，调整 5 美分
  → Sell YES 价格 = 45 + spread/2 = 46 (激进卖出)
  → Buy YES 价格 = 45 - spread/2 = 44 (保守买入)
  → 效果: 诱导市场买走多余的 YES 库存

═════ 示例 2: 同样库存，但接近结算 (24h) ═════

  h = 24 小时, κ = 24 小时
  τ(h) = 24 / (24 + 24) = 0.5

  r = 50 - 0.4 × 1.5 × 9 × 0.5
    = 50 - 2.7
    = 47.3 ≈ 47 美分

  → 调整减半（从 5→3 美分），Oracle Guard 的结算前缩量接管风控

═════ 示例 3: 极值价格区 (P=10 美分, 中期) ═════

  伯努利因子: W = 10 × 90 / 2500 = 0.36
  σ_final = 3 × sqrt(0.36) = 3 × 0.6 = 1.8 美分
  h = 720h, τ = 0.968

  r = 10 - 0.4 × 1.5 × 3.24 × 0.968
    = 10 - 1.88
    = 8.12 ≈ 8 美分

  → 在低价区，伯努利衰减自动收缩 σ，调整幅度适中

═════ 示例 4: 短期市场 (3 天, γ=2.5) ═════

  h = 48 小时 (距结算 2 天), κ = 24
  τ(h) = 48 / (48 + 24) = 0.667
  γ = 2.5 (短期市场分档)

  r = 50 - 0.4 × 2.5 × 9 × 0.667
    = 50 - 6.0
    = 44 美分

  → 短期市场 γ 更高，即使 τ 较低，仍有足够调整力度

═════ 示例 5: 临近结算 (2h) ═════

  h = 2 小时, κ = 24
  τ(h) = 2 / (2 + 24) = 0.077

  r = 50 - 0.4 × 1.5 × 9 × 0.077
    = 50 - 0.42 → 应用最小调整: 49 美分

  → 临近结算 τ 快速衰减，Oracle Guard 完全接管
```

### 5.3 非对称梯度 (Inventory Skewing)

```
┌─────────────────────────────────────────────────────────────────┐
│                    非对称梯度调整 (Skewing)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: 做市商 YES 库存过高 (q > 0)                               │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  【卖单侧 (Sell YES) → 更激进】                                 │
│  ──────────────────────────────                                 │
│  • 点差收窄：ask_spread = base × (1 - skew × q)                 │
│  • 数量增加：ask_qty = base × (1 + qty_skew × q)                │
│  • 目的：快速卖出多余的 YES 库存                                │
│                                                                 │
│  【买单侧 (Buy YES / Sell NO) → 更保守】                        │
│  ──────────────────────────────────────                         │
│  • 点差放宽：bid_spread = base × (1 + skew × q)                 │
│  • 数量减少：bid_qty = base × (1 - qty_skew × q)                │
│  • 目的：避免继续累积 YES 库存                                  │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  生存法则:                                                      │
│  ──────────                                                     │
│  ★ 绝大多数破产的做市商都是因为在单边行情中死板地双边对等挂单   │
│  ★ 非对称梯度是生存的第一法则                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 A-S 引擎实现

```python
class AvellanedaStoikovEngine:
    """Avellaneda-Stoikov 做市引擎"""

    def __init__(self, config: ASConfig):
        self.config = config

    def calculate_reservation_price(
        self,
        fair_price: int,
        yes_inventory: int,
        no_inventory: int,
        volatility: float,
        hours_remaining: float,
        market_lifecycle_days: int = 30
    ) -> int:
        """
        计算保留价格 (v7.1: 绝对小时 + 生命周期分档)

        Args:
            fair_price: 公允价格（美分）
            yes_inventory: YES 库存
            no_inventory: NO 库存
            volatility: 波动率（美分，伯努利衰减后）
            hours_remaining: 距结算剩余小时数（绝对值）
            market_lifecycle_days: 市场总生命周期（天），用于 γ 分档

        Returns:
            保留价格（美分）
        """
        total = yes_inventory + no_inventory
        if total == 0:
            return fair_price

        # 库存偏斜: YES 多为正，NO 多为负
        q = (yes_inventory - no_inventory) / total

        # v7.1: γ 按市场生命周期分档
        gamma = self._get_tiered_gamma(market_lifecycle_days)

        # v7.1: 时间因子 τ(h) = h / (h + κ)，双曲衰减
        kappa = self.config.time_smoothing_kappa
        tau = hours_remaining / (hours_remaining + kappa) if hours_remaining > 0 else 0.0

        # A-S 公式: r = s - q · γ · σ² · τ(h)
        adjustment = q * gamma * (volatility ** 2) * tau

        # v7.0: 最小调整量保护，避免 σ² 过小导致调整为零
        if abs(adjustment) < self.config.min_adjustment and abs(q) > 0.1:
            adjustment = self.config.min_adjustment * (1 if q > 0 else -1)

        reservation_price = fair_price - int(adjustment)

        # 边界保护
        return max(self.config.min_price,
                   min(self.config.max_price, reservation_price))

    def _get_tiered_gamma(self, lifecycle_days: int) -> float:
        """
        v7.1: 按市场生命周期分档选择 γ

        短期 (< 7天): γ = gamma_short (激进卸库存)
        中期 (7~90天): γ = gamma_mid (标准做市)
        长期 (> 90天): γ = gamma_long (保守，避免过度调整)
        """
        if lifecycle_days < 7:
            return self.config.gamma_short
        elif lifecycle_days <= 90:
            return self.config.gamma_mid
        else:
            return self.config.gamma_long

    def calculate_asymmetric_quotes(
        self,
        reservation_price: int,
        inventory_skew: float,
        base_spread: int,
        base_qty: int
    ) -> dict:
        """
        计算非对称报价

        Args:
            reservation_price: 保留价格（美分）
            inventory_skew: 库存偏斜 [-1, 1]
            base_spread: 基础点差（美分）
            base_qty: 基础数量（份）

        Returns:
            {
                'ask_price': int,
                'ask_qty': int,
                'bid_price': int,
                'bid_qty': int
            }
        """
        skew = self.config.spread_skew_factor
        qty_skew = self.config.qty_skew_factor

        # 点差调整
        ask_spread = int(base_spread * (1 - skew * inventory_skew))
        bid_spread = int(base_spread * (1 + skew * inventory_skew))

        # 数量调整
        ask_qty = int(base_qty * (1 + qty_skew * inventory_skew))
        bid_qty = int(base_qty * (1 - qty_skew * inventory_skew))

        # 最小值保护
        ask_spread = max(1, ask_spread)
        bid_spread = max(1, bid_spread)
        ask_qty = max(1, ask_qty)
        bid_qty = max(1, bid_qty)

        return {
            'ask_price': reservation_price + ask_spread,
            'ask_qty': ask_qty,
            'bid_price': reservation_price - bid_spread,
            'bid_qty': bid_qty
        }


class ASConfig:
    """A-S 配置（v7.1 参数标定：σ 量纲为美分 + 绝对小时时间因子 + γ 分档）"""

    # v7.1: γ 生命周期分档 (替代单一 risk_aversion)
    gamma_short: float = 2.5             # 短期市场 (< 7天)：激进卸库存
    gamma_mid: float = 1.5               # 中期市场 (7~90天)：标准做市，推荐起步值
    gamma_long: float = 0.8              # 长期市场 (> 90天)：保守，避免过度调整

    # v7.1: 时间平滑常数 (κ)
    time_smoothing_kappa: float = 24.0   # 单位: 小时。τ(h)=h/(h+κ)，κ=24 时 h=24h 处 τ=0.5

    spread_skew_factor: float = 0.5      # 点差偏斜因子
    qty_skew_factor: float = 0.3         # 数量偏斜因子
    min_price: int = 5                   # 最低价格 5 美分
    max_price: int = 95                  # 最高价格 95 美分
    min_adjustment: int = 1              # v7.0: 最小调整量 1 美分，防止 σ² 过小导致调整为零
```

### 5.5 非对称调整示例

```
场景: YES 库存偏多

输入:
  reservation_price = 50
  inventory_skew = 0.4 (YES 偏多)
  base_spread = 2
  base_qty = 100
  spread_skew_factor = 0.5
  qty_skew_factor = 0.3

计算:
  ask_spread = 2 × (1 - 0.5 × 0.4) = 2 × 0.8 = 1.6 → 2
  bid_spread = 2 × (1 + 0.5 × 0.4) = 2 × 1.2 = 2.4 → 2
  ask_qty = 100 × (1 + 0.3 × 0.4) = 100 × 1.12 = 112
  bid_qty = 100 × (1 - 0.3 × 0.4) = 100 × 0.88 = 88

结果:
  Sell YES: 价格 = 52, 数量 = 112 (更激进)
  Buy YES:  价格 = 48, 数量 = 88  (更保守)

盘口表现:
  ┌──────────────────────────────────────────────┐
  │  Buy YES (Bid)    │   Sell YES (Ask)         │
  ├───────────────────┼──────────────────────────┤
  │  48 × 88 份       │   52 × 112 份            │
  │  (保守, 量少)      │   (激进, 量大)           │
  └──────────────────────────────────────────────┘
```

---

## 六、挂单梯度设计 (v4.0 重构)

### 6.1 两种梯度对比

```
┌─────────────────────────────────────────────────────────────────┐
│                    挂单梯度设计对比 (v4.0)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  线性/固定梯度 (Arithmetic) - 探索期首选                        │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  公式: P_i = P_base + i × ΔP                                   │
│  示例: 50, 51, 52, 53, 54 (ΔP = 1 美分)                        │
│                                                                 │
│  优势:                                                          │
│    ✓ 可解释性强，人工核查简单                                   │
│    ✓ 风险线性可控                                               │
│    ✓ 亏损可精确计算                                             │
│                                                                 │
│  数量策略: 倒金字塔 (越远越大)                                  │
│    → 防止价格轻易击穿防线                                       │
│                                                                 │
│  ┌────────┬────────┬──────────────────────────────────────┐    │
│  │ 档位   │  价格  │  数量                                │    │
│  ├────────┼────────┼──────────────────────────────────────┤    │
│  │  1     │  51    │   50份 ██████████                    │    │
│  │  2     │  52    │   60份 ████████████                  │    │
│  │  3     │  53    │   70份 ██████████████                │    │
│  │  4     │  54    │   80份 ████████████████              │    │
│  │  5     │  55    │   90份 ██████████████████            │    │
│  └────────┴────────┴──────────────────────────────────────┘    │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  几何梯度 (Geometric) - 收敛期首选                              │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  公式: P_i = P_base × r^i                                      │
│  示例: 51, 53, 56, 59, 62 (r ≈ 1.05)                           │
│                                                                 │
│  优势:                                                          │
│    ✓ 资金效率极高                                               │
│    ✓ 覆盖极大价格范围                                           │
│    ✓ 尾部风险保护 (Flash Crash)                                │
│                                                                 │
│  数量策略: 指数衰减 (越远越小)                                  │
│    → 鼓励小单快速成交                                           │
│                                                                 │
│  ┌────────┬────────┬──────────────────────────────────────┐    │
│  │ 档位   │  价格  │  数量                                │    │
│  ├────────┼────────┼──────────────────────────────────────┤    │
│  │  1     │  52    │  100份 ████████████████████████      │    │
│  │  2     │  55    │   70份 ██████████████████            │    │
│  │  3     │  58    │   49份 ████████████                  │    │
│  │  4     │  61    │   34份 ████████                      │    │
│  │  5     │  64    │   24份 ██████                        │    │
│  └────────┴────────┴──────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 梯度引擎实现

```python
class GradientEngine:
    """梯度计算引擎"""

    def __init__(self, config: GradientConfig):
        self.config = config

    def generate_ladder(
        self,
        center_price: int,
        side: str,  # 'ASK' or 'BID'
        base_qty: int,
        phase: str  # 'EXPLORATION' or 'STABILIZATION'
    ) -> list:
        """
        生成挂单阶梯

        Returns:
            [(price, qty), ...]
        """
        if phase == "EXPLORATION":
            return self._linear_ladder(center_price, side, base_qty)
        else:
            return self._geometric_ladder(center_price, side, base_qty)

    def _linear_ladder(self, center: int, side: str, base_qty: int) -> list:
        """
        线性梯度 + 倒金字塔数量

        探索期使用: 风险线性可控
        """
        ladder = []
        step = self.config.linear_step
        levels = self.config.linear_levels
        qty_increase = self.config.linear_qty_increase  # 每档增加比例

        for i in range(levels):
            if side == 'ASK':
                price = center + (i + 1) * step
            else:  # BID
                price = center - (i + 1) * step

            # 倒金字塔: 越远数量越大
            qty = int(base_qty * (1 + i * qty_increase))
            ladder.append((price, qty))

        return ladder

    def _geometric_ladder(self, center: int, side: str, base_qty: int) -> list:
        """
        几何梯度 + 指数衰减数量

        收敛期使用: 资金效率高，尾部保护
        """
        ladder = []
        ratio = self.config.geometric_ratio
        levels = self.config.geometric_levels
        decay = self.config.qty_decay

        for i in range(levels):
            if side == 'ASK':
                price = int(center * (ratio ** (i + 1)))
            else:  # BID
                price = int(center / (ratio ** (i + 1)))

            # 指数衰减: 越远数量越小
            qty = int(base_qty * (decay ** i))
            qty = max(1, qty)  # 最小 1 份
            ladder.append((price, qty))

        return ladder


class GradientConfig:
    """梯度配置"""

    # 线性梯度 (探索期)
    linear_step: int = 1                 # 每档递增 1 美分
    linear_levels: int = 5               # 5 档
    linear_qty_increase: float = 0.2     # 每档数量增加 20%

    # 几何梯度 (收敛期)
    geometric_ratio: float = 1.05        # 价格倍率
    geometric_levels: int = 5            # 5 档
    qty_decay: float = 0.7               # 数量衰减系数
```

### 6.3 完整挂单流程

```
AMM 挂单决策流程:

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. 获取公允价格                                                │
│     fair_price = ThreeLayerPricing.calculate()                 │
│                                                                 │
│  2. 计算保留价格                                                │
│     reservation_price = ASEngine.calculate_reservation_price() │
│                                                                 │
│  3. 获取当前阶段                                                │
│     phase = PhaseManager.current_phase                         │
│                                                                 │
│  4. 计算非对称报价                                              │
│     quotes = ASEngine.calculate_asymmetric_quotes()            │
│                                                                 │
│  5. 生成挂单阶梯                                                │
│     ask_ladder = GradientEngine.generate_ladder('ASK', phase)  │
│     bid_ladder = GradientEngine.generate_ladder('BID', phase)  │
│                                                                 │
│  6. 风控检查                                                    │
│     defense_result = DefenseStack.check_all_defenses()         │
│     if defense_result.action == 'KILL':                        │
│         cancel_all_orders()                                    │
│         return                                                 │
│     elif defense_result.action == 'ONE_SIDE':                  │
│         // v7.1: 折价抛售 —— 只挂平仓单，价格 = 保留价 - 折价  │
│         discount = defense_result.params['distress_discount']  │
│         heavy = defense_result.params['heavy_side']            │
│         // 如 heavy='YES': 只挂 Sell YES，价格下调 discount    │
│     elif defense_result.action == 'WIDEN_SPREAD':              │
│         // 扩大点差                                            │
│                                                                 │
│  7. 提交订单                                                    │
│     Connector.place_orders(ask_ladder + bid_ladder)            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 七、算法设计（CPMM 参考定价，v7.0 定位调整）

> ⚠️ **v7.0 定位调整**：CPMM 在本系统中**不是主定价引擎**，而是**辅助参考工具**。
>
> **主定价引擎**：A-S 保留价格 + 三层定价体系（第三章 + 第五章）
>
> **CPMM 的角色**：
> 1. **初始化参考**：根据目标概率计算初始库存分配比例（Y, N）
> 2. **理论校验**：作为 sanity check，验证三层定价的输出是否在合理范围内
> 3. **整数化基础**：提供与"全链路整数化"兼容的价格计算工具（SafeMath 库）
>
> **为什么不以 CPMM 为主引擎？**
> CPMM 的定价完全由库存池比例驱动，缺乏对外部信息（锚定价）、微观结构（订单簿信号）和风险管理（库存偏斜惩罚）的建模能力。在冷启动阶段，A-S + 三层定价能更灵活地平衡"价格发现"和"成本控制"。

### 7.1 CPMM 参考定价算法

对于预测市场的整数化价格计算，CPMM（Constant Product Market Maker）提供了与"全链路整数化"架构兼容的参考工具。

```
┌─────────────────────────────────────────────────────────────────┐
│          为什么参考定价选 CPMM，而不是 LMSR？                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  LMSR (对数市场评分规则):                                        │
│  ─────────────────────────                                      │
│  Price = e^(q/b) / (e^(q_yes/b) + e^(q_no/b))                   │
│                                                                 │
│  问题:                                                          │
│  ✗ 涉及 e^x 和 ln(x) 运算                                       │
│  ✗ 无法用整数精确表示                                           │
│  ✗ 与"全链路整数化"原则冲突                                     │
│  ✗ 高精度浮点运算消耗算力                                       │
│                                                                 │
│  CPMM (恒定乘积做市商):                                          │
│  ─────────────────────────                                      │
│  Price_Yes = N / (Y + N)                                        │
│                                                                 │
│  优势:                                                          │
│  ✓ 只涉及乘法和除法                                             │
│  ✓ 完美支持整数运算: N * 100 / (Y + N)                          │
│  ✓ 计算速度比对数函数快几个数量级                               │
│  ✓ 无精度隐患                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 为什么选择 CPMM 作为参考定价？

| 对比维度 | LMSR | CPMM |
|----------|------|------|
| 复杂度 | 涉及指数和对数运算 | 简单的乘除法 |
| 工程成熟度 | 学术界常用 | Uniswap/Polymarket 验证 |
| 价格公式 | e^(q/b) 相关 | 简单比例 N/(Y+N) |
| 滑点特性 | 可控但计算复杂 | 直观，大单滑点大 |
| 实现难度 | 较高 | 较低 |

```
┌─────────────────────────────────────────────────────────────────┐
│                         CPMM 算法                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  状态变量:                                                       │
│  ──────────                                                     │
│  Y = AMM 持有的 Yes 库存（份数）                                 │
│  N = AMM 持有的 No 库存（份数）                                  │
│  K = Y × N = 恒定乘积                                           │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  价格公式:                                                       │
│  ──────────                                                     │
│                      N                                          │
│  Price_Yes = ─────────── = N / (Y + N)                          │
│                  Y + N                                          │
│                                                                 │
│                      Y                                          │
│  Price_No  = ─────────── = Y / (Y + N)                          │
│                  Y + N                                          │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  性质验证:                                                       │
│  ──────────                                                     │
│  Price_Yes + Price_No = N/(Y+N) + Y/(Y+N) = 1.0  ✓              │
│                                                                 │
│  完美符合预测市场的恒等式要求！                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 CPMM 价格计算示例（用于初始化参考）

```
场景: AMM 初始化
────────────────────
初始库存: Y = 1000, N = 1000
恒定乘积: K = 1000 × 1000 = 1,000,000

初始价格:
  Price_Yes = 1000 / (1000 + 1000) = 0.50 (50%)
  Price_No  = 1000 / (1000 + 1000) = 0.50 (50%)

────────────────────────────────────────────────────

场景: 用户买入 100 份 Yes
────────────────────────────
AMM 卖出 100 份 Yes:
  新 Y = 1000 - 100 = 900
  
为保持 K 不变（简化模型）:
  新 N = K / 新Y = 1,000,000 / 900 ≈ 1111
  (实际上 AMM 会收到用户的现金，转换为 No 库存)

新价格:
  Price_Yes = 1111 / (900 + 1111) ≈ 0.55 (55%)
  Price_No  = 900 / (900 + 1111) ≈ 0.45 (45%)

价格上涨了！反映了市场对 Yes 的需求增加。
```

### 7.4 整数化价格计算（v3.1 修正 - 美分制）

> ⚠️ **v3.1 重要变更**：与撮合引擎 v4.0 对齐，全面采用**美分制**（1-99），取代基点制。
> ⚠️ **v3.0 保留**：向上取整 (Ceiling) 处理卖单价格，保护 AMM 利益。

```
┌─────────────────────────────────────────────────────────────────┐
│              整数化价格计算（v3.1 美分制 + 取整修正）              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  存储单位: 美分 (Cents) - 对齐撮合引擎 v4.0                      │
│  ──────────────────────────────────────────────                 │
│  100 美分 = 100% = $1.00                                        │
│  50  美分 = 50%  = $0.50                                        │
│  价格范围: 1-99 美分（对应 $0.01 - $0.99）                       │
│                                                                 │
│  库存存储:                                                       │
│  ──────────                                                     │
│  Y: int64  // Yes 库存（份数）                                   │
│  N: int64  // No 库存（份数）                                    │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  ⚠️ v3.0 保留: 卖价向上取整，保护做市商                          │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  公允价格计算（整数版，美分）:                                    │
│  ──────────────────────────────                                 │
│  Fair_Yes = N * 100 / (Y + N)   // 向下取整（默认）              │
│  Fair_No  = Y * 100 / (Y + N)   // 向下取整（默认）              │
│                                                                 │
│  卖单价格计算（向上取整，美分）:                                  │
│  ──────────────────────────────                                 │
│  Ask_Yes = ceil_div(N * 100 * (100 + spread/2), (Y+N) * 100)    │
│  Ask_No  = ceil_div(Y * 100 * (100 + spread/2), (Y+N) * 100)    │
│                                                                 │
│  简化公式（spread 单位为美分）:                                   │
│  Ask_Yes = ceil_div(N * (100 + spread/2), (Y + N))              │
│  Ask_No  = ceil_div(Y * (100 + spread/2), (Y + N))              │
│                                                                 │
│  向上取整除法实现:                                               │
│  ────────────────                                               │
│  ceil_div(a, b) = (a + b - 1) / b                               │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  示例:                                                          │
│  ──────                                                         │
│  Y = 400, N = 600, spread = 2 美分 (2%)                         │
│                                                                 │
│  公允价格:                                                       │
│  Fair_Yes = 600 * 100 / 1000 = 60 美分 (60%)                    │
│                                                                 │
│  计算卖价:                                                       │
│  Ask_Yes = ceil_div(600 * (100 + 1), 1000)                      │
│          = ceil_div(600 * 101, 1000)                            │
│          = ceil_div(60600, 1000) = 61 美分                      │
│                                                                 │
│  原则: 作为卖方，价格应该向上取整保护自己                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.5 SafeMath 库封装（v3.1 美分制）

```python
class SafeMath:
    """
    专门处理 AMM 价格计算的安全数学库（v3.1 美分制）

    与撮合引擎 v4.0 对齐，使用美分 (1-99) 作为价格单位
    确保卖方利益不因取整而受损
    """

    @staticmethod
    def floor_div(a: int, b: int) -> int:
        """向下取整除法 - 用于买价计算"""
        return a // b

    @staticmethod
    def ceil_div(a: int, b: int) -> int:
        """向上取整除法 - 用于卖价计算"""
        return (a + b - 1) // b

    @staticmethod
    def calculate_ask_price(inventory_self: int, inventory_other: int,
                           spread_cents: int) -> int:
        """
        计算卖出价格（向上取整，美分制）

        Args:
            inventory_self: 要卖出的合约类型库存
            inventory_other: 对方合约类型库存
            spread_cents: 点差（美分，例如 2 = 2%）

        Returns:
            卖出价格（美分，范围 1-99）
        """
        total = inventory_self + inventory_other
        if total == 0:
            return 50  # 默认 50 美分 (50%)

        # 公允价格 = other * 100 / total（美分）
        # 卖价 = 公允价格 * (1 + spread/2/100)
        # 简化: other * (100 + spread/2) / total

        half_spread = spread_cents // 2
        numerator = inventory_other * (100 + half_spread)
        denominator = total

        # 向上取整保护卖方
        price = SafeMath.ceil_div(numerator, denominator)

        # 确保价格在有效范围内
        return max(1, min(99, price))
```

---

## 附录E：挂单策略（v3.0 保留，已由第六章重构）

### E.1 核心策略：单边卖单（利用跨账本撮合）

关键优化：AMM 只需要挂卖单，不需要挂买单。

```
┌─────────────────────────────────────────────────────────────────┐
│                 单边卖单策略（资金效率最优）                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  传统做法（资金效率低）:                                         │
│  ────────────────────────                                       │
│  AMM 需要在四个方向挂单:                                         │
│    Buy Yes  @ 0.49  (冻结现金)                                  │
│    Sell Yes @ 0.51  (冻结Yes持仓)                               │
│    Buy No   @ 0.49  (冻结现金)                                  │
│    Sell No  @ 0.51  (冻结No持仓)                                │
│                                                                 │
│  问题: 资金被双重冻结，效率低下                                  │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  优化做法（利用跨账本撮合）:                                     │
│  ────────────────────────────                                   │
│  AMM 只需要挂两边的卖单:                                         │
│    Sell Yes @ 0.51, 0.52, 0.53...                               │
│    Sell No  @ 0.51, 0.52, 0.53...                               │
│                                                                 │
│  为什么这就够了？                                                │
│  ─────────────────                                              │
│  根据跨账本撮合原理:                                             │
│                                                                 │
│    用户想买Yes → 直接吃 Sell Yes @ 0.51          ✓              │
│    用户想买No  → 直接吃 Sell No  @ 0.51          ✓              │
│    用户想卖Yes → 等效买No  → 吃 Sell No          ✓              │
│    用户想卖No  → 等效买Yes → 吃 Sell Yes         ✓              │
│                                                                 │
│  四个方向全部覆盖！                                              │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  进一步优化：根据库存偏差只挂单边                                │
│  ─────────────────────────────────                              │
│  当库存严重失衡时，可以只挂一边:                                 │
│                                                                 │
│  场景: Y=300, N=700 (Yes 库存少)                                │
│  策略: 只挂 Sell No，不挂 Sell Yes                              │
│  原因:                                                          │
│    - 继续卖 Yes 会加剧失衡                                      │
│    - 用户买 Yes 可以通过跨账本吃 Sell No                        │
│    - 保护 AMM 避免过度单边风险                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### E.2 阶梯挂单策略

AMM 不只挂一个价格，而是挂出阶梯流动性，提供不同深度的报价：

```
┌─────────────────────────────────────────────────────────────────┐
│                        阶梯挂单策略                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  当前公允价格: Yes = 50%, No = 50%                               │
│  点差配置: 2%                                                    │
│  阶梯数: 5                                                       │
│  每阶数量: 100 份                                                │
│                                                                 │
│  AMM 挂单 (Sell Yes):                                           │
│  ──────────────────────                                         │
│  ┌────────┬────────┬──────────────────────────────────────┐    │
│  │  价格  │  数量  │  说明                                │    │
│  ├────────┼────────┼──────────────────────────────────────┤    │
│  │  0.51  │ 100份  │  最优卖价，最先被吃                  │    │
│  │  0.52  │ 100份  │  第二档                              │    │
│  │  0.53  │ 100份  │  第三档                              │    │
│  │  0.54  │ 100份  │  第四档                              │    │
│  │  0.55  │ 100份  │  第五档                              │    │
│  └────────┴────────┴──────────────────────────────────────┘    │
│                                                                 │
│  AMM 挂单 (Sell No):                                            │
│  ──────────────────────                                         │
│  ┌────────┬────────┬──────────────────────────────────────┐    │
│  │  价格  │  数量  │  说明                                │    │
│  ├────────┼────────┼──────────────────────────────────────┤    │
│  │  0.51  │ 100份  │  最优卖价                            │    │
│  │  0.52  │ 100份  │  第二档                              │    │
│  │  0.53  │ 100份  │  第三档                              │    │
│  │  0.54  │ 100份  │  第四档                              │    │
│  │  0.55  │ 100份  │  第五档                              │    │
│  └────────┴────────┴──────────────────────────────────────┘    │
│                                                                 │
│  用户视角:                                                       │
│  ──────────                                                     │
│  买 Yes: 可以买 @ 0.51, 大单会滑到 0.55                          │
│  卖 Yes: 可以卖 @ 0.49 (= 1 - 0.51), 大单滑到 0.45               │
│  买 No:  可以买 @ 0.51                                          │
│  卖 No:  可以卖 @ 0.49                                          │
│                                                                 │
│  四个方向全覆盖！                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### E.3 动态再平衡（v3.0 优化：原子化改单）

当 AMM 的订单被成交后，需要重新计算价格并调整挂单。

> ⚠️ **v3.0 关键改进**：引入原子化改单 (Atomic Replace) 机制，解决"撤单-重挂"之间的竞态条件。

```
┌─────────────────────────────────────────────────────────────────┐
│                  动态再平衡流程 (v3.0 优化)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初始状态:                                                       │
│  ──────────                                                     │
│  Y = 1000, N = 1000                                             │
│  Fair_Yes = 50%                                                 │
│  AMM 挂单: Sell Yes @ 0.51, 0.52, 0.53...                       │
│                                                                 │
│  事件: 用户买入 100 份 Yes @ 0.51                                │
│  ──────────────────────────────────────────                     │
│                                                                 │
│  Step 1: 成交通知                                               │
│  ────────────────                                               │
│  Market Listener 收到 TradeEvent:                               │
│    maker: AMM, taker: User                                      │
│    side: Yes, price: 0.51, quantity: 100                        │
│                                                                 │
│  Step 2: 更新库存 (Redis)                                       │
│  ────────────────────────                                       │
│  AMM 卖出 100 Yes, 收到 51 美元                                  │
│  新库存: Y = 900, N = 1000 (现金可转换为 No)                     │
│                                                                 │
│  Step 3: 重新计算价格                                            │
│  ────────────────────                                           │
│  新 Fair_Yes = 1000 / (900 + 1000) ≈ 0.526 (52.6%)              │
│  新 Fair_No  = 900 / (900 + 1000) ≈ 0.474 (47.4%)               │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│  ⚠️ v3.0 改进: 使用原子化改单，而非 Cancel + Place               │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  Step 4: 原子化改单 (Atomic Replace)                            │
│  ────────────────────────────────────                           │
│  Order Manager 调用:                                             │
│    POST /api/orders/replace                                     │
│    {                                                            │
│      "oldOrderId": "order_001",                                 │
│      "newOrder": {                                              │
│        "side": "YES",                                           │
│        "direction": "SELL",                                     │
│        "price": 5400,  // 新价格                                │
│        "quantity": 100                                          │
│      }                                                          │
│    }                                                            │
│                                                                 │
│  撮合引擎原子执行:                                               │
│    ① 检查 oldOrderId 是否存在且未成交                           │
│    ② 如果存在: 撤销旧单 → 创建新单 (原子操作)                   │
│    ③ 如果不存在/已成交: 拒绝创建新单，返回错误                  │
│                                                                 │
│  新挂单状态:                                                     │
│  ──────────────                                                 │
│  Sell Yes: 0.54, 0.55, 0.56, 0.57, 0.58                         │
│  Sell No:  0.48, 0.49, 0.50, 0.51, 0.52                         │
│                                                                 │
│  价格向上移动，反映市场对 Yes 的需求！                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 为什么需要原子化改单？

```
┌─────────────────────────────────────────────────────────────────┐
│              非原子化改单的风险 (v2.0 问题)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  旧流程: Cancel old → Place new                                 │
│                                                                 │
│  风险场景 1: "裸奔"状态                                          │
│  ────────────────────────                                       │
│  T=0: AMM 发送撤单请求                                           │
│  T=1: 撤单成功，AMM 订单消失                                     │
│  T=2: 网络延迟，新单请求尚未到达                                 │
│  T=3: 此时 AMM 处于"裸奔"状态，无任何挂单                        │
│  T=4: 新单请求到达，创建成功                                     │
│                                                                 │
│  后果: T=2~T=4 期间，用户无法与 AMM 交易，流动性中断              │
│                                                                 │
│  风险场景 2: 重复成交                                            │
│  ────────────────────────                                       │
│  T=0: AMM 发送撤单请求                                           │
│  T=1: 撤单请求传输中，此时订单被吃掉                             │
│  T=2: 撤单失败（订单已不存在）                                   │
│  T=3: AMM 未收到失败通知，以为撤单成功                           │
│  T=4: AMM 挂出新单                                               │
│  T=5: 新单也被吃掉                                               │
│                                                                 │
│  后果: AMM 在短时间内成交了两笔，库存计算错误                     │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  v3.0 解决方案: 原子化改单                                       │
│  ────────────────────────────                                   │
│  - 撤旧单和挂新单作为一个原子操作                                │
│  - 如果旧单已成交/不存在，新单创建被拒绝                         │
│  - AMM 永远不会因网络延迟导致状态不一致                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### v7.1 新增：部分成交处理 (Partial Fill Handling)

> ⚠️ **v7.1 关键改进**：原子改单在遇到 **部分成交** 时存在死锁风险。
> 旧订单在 Replace 请求传输期间被部分成交，撮合引擎拒绝 Replace，
> 但此时旧订单已被部分消耗且被撤销，AMM 既没有旧单也没有新单。
>
> **解决方案**：
> 1. **撮合引擎侧**：Replace API 返回 `PARTIALLY_FILLED` 错误码 + `filledQty`
> 2. **AMM 侧**：Order Manager 实现 fallback 策略 —— 根据最新库存重新计算并下新单

```python
class OrderManager:
    """v7.1: 增强原子改单，支持部分成交 fallback"""

    async def atomic_replace_with_fallback(
        self,
        old_order_id: str,
        new_order: dict,
        market_state: dict
    ) -> dict:
        """
        原子改单 + 部分成交 fallback

        流程:
          1. 尝试原子 Replace
          2. 如果成功 → 返回新订单
          3. 如果 PARTIALLY_FILLED → 同步库存 → 重新计算 → 下新单
          4. 如果 ALREADY_FILLED → 同步库存 → 跳过（等下一个周期重新报价）
          5. 如果 NOT_FOUND → 告警，可能是幽灵订单
        """
        result = await self.connector.replace_order(old_order_id, new_order)

        if result['success']:
            return {'status': 'REPLACED', 'new_order_id': result['newOrderId']}

        error = result.get('error', '')

        if error == 'OLD_ORDER_PARTIALLY_FILLED':
            # ── 部分成交 fallback ──
            filled_qty = result['filledQty']

            # Step 1: 同步库存 (从 Redis 拉取最新持仓)
            await self._sync_inventory_from_redis()

            # Step 2: 记录部分成交事件（用于 PnL 追踪）
            self._record_partial_fill(old_order_id, filled_qty)

            # Step 3: 重新计算报价（基于更新后的库存）
            recalculated = self.strategy_engine.recalculate_quote(
                side=new_order['side'],
                direction=new_order['direction'],
                market_state=market_state
            )

            if recalculated is None:
                # 风控判定不应再挂单（如库存已极端偏斜）
                return {'status': 'SKIP_AFTER_PARTIAL', 'filled_qty': filled_qty}

            # Step 4: 下新单（注意: 这是独立的 Place，不是 Replace）
            place_result = await self.connector.place_order(recalculated)
            return {
                'status': 'FALLBACK_PLACED',
                'filled_qty': filled_qty,
                'new_order_id': place_result.get('orderId')
            }

        elif error == 'OLD_ORDER_ALREADY_FILLED':
            # ── 全部成交: 同步库存，等下一报价周期 ──
            await self._sync_inventory_from_redis()
            return {'status': 'FULLY_FILLED_SKIP'}

        elif error == 'OLD_ORDER_NOT_FOUND':
            # ── 幽灵订单: 告警 + 全量同步 ──
            self.alert_manager.warn(f'Ghost order detected: {old_order_id}')
            await self._full_state_reconciliation()
            return {'status': 'GHOST_ORDER_ALERT'}

        else:
            raise UnexpectedReplaceError(f'Unknown error: {error}')

    async def _sync_inventory_from_redis(self):
        """从 Redis 拉取最新库存，覆盖本地缓存"""
        positions = await self.connector.get_positions()
        self.state.update_inventory(positions)

    async def _full_state_reconciliation(self):
        """全量状态对账: 拉取所有活跃订单 + 持仓，修复本地状态"""
        active_orders = await self.connector.get_active_orders()
        positions = await self.connector.get_positions()
        self.state.reconcile(active_orders, positions)
```

### E.4 挂单数量分配策略

```
┌─────────────────────────────────────────────────────────────────┐
│                       挂单数量分配                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  策略1: 均匀分配                                                 │
│  ──────────────────                                             │
│  每个价格档位挂相同数量                                          │
│  优点: 简单                                                      │
│  缺点: 不够灵活                                                  │
│                                                                 │
│  策略2: 指数衰减                                                 │
│  ──────────────────                                             │
│  越靠近盘口数量越大，远离盘口数量越小                            │
│  例: 100, 80, 60, 40, 20                                        │
│  优点: 鼓励小单快速成交                                          │
│                                                                 │
│  策略3: 基于库存偏离度                                           │
│  ──────────────────────                                         │
│  当库存失衡时，减少弱势一方的挂单量                              │
│                                                                 │
│  例: Y = 300, N = 1700 (严重偏向 No)                            │
│      Sell Yes: 减少挂单量或扩大点差                             │
│      Sell No:  正常挂单                                         │
│                                                                 │
│  原因: 如果继续大量卖Yes，一旦Yes赢，AMM会亏很多                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 八、系统集成

### 8.1 与核心系统的接口（v3.1 美分制）

AMM 通过标准 API 与核心系统交互，**v3.0 新增原子改单接口**，**v3.1 价格单位改为美分**：

```
┌─────────────────────────────────────────────────────────────────┐
│                   AMM 使用的标准接口 (v3.1 美分制)                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 下单接口                                                     │
│  ────────────                                                   │
│  POST /api/orders                                               │
│  {                                                              │
│    "userId": "AMM_SYSTEM_001",                                  │
│    "marketId": "market_001",                                    │
│    "side": "YES",                                               │
│    "direction": "SELL",                                         │
│    "price": 51,         // 美分 (1-99)                          │
│    "quantity": 100                                              │
│  }                                                              │
│                                                                 │
│  2. 撤单接口                                                     │
│  ────────────                                                   │
│  DELETE /api/orders/{orderId}                                   │
│                                                                 │
│  3. 批量撤单                                                     │
│  ────────────                                                   │
│  DELETE /api/orders/batch                                       │
│  {                                                              │
│    "userId": "AMM_SYSTEM_001",                                  │
│    "marketId": "market_001"                                     │
│  }                                                              │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│  ⚠️ v3.0 新增: 原子化改单接口                                    │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  4. 原子改单接口 (Atomic Replace) ⭐ NEW                         │
│  ────────────────────────────────────                           │
│  POST /api/orders/replace                                       │
│  {                                                              │
│    "oldOrderId": "order_12345",    // 要替换的旧订单ID          │
│    "newOrder": {                                                │
│      "userId": "AMM_SYSTEM_001",                                │
│      "marketId": "market_001",                                  │
│      "side": "YES",                                             │
│      "direction": "SELL",                                       │
│      "price": 54,                  // 新价格（美分）            │
│      "quantity": 100                                            │
│    }                                                            │
│  }                                                              │
│                                                                 │
│  响应:                                                          │
│  成功: { "success": true, "newOrderId": "order_12346" }         │
│  失败: { "success": false, "error": "OLD_ORDER_NOT_FOUND" }     │
│        { "success": false, "error": "OLD_ORDER_ALREADY_FILLED" }│
│                                                                 │
│  ⚠️ v7.1 新增: 部分成交响应                                     │
│  部分成交:                                                      │
│  {                                                              │
│    "success": false,                                            │
│    "error": "OLD_ORDER_PARTIALLY_FILLED",                       │
│    "filledQty": 30,          // 旧订单已成交数量                │
│    "remainingQty": 70,       // 旧订单剩余数量（已被撤销）      │
│    "newOrderId": null        // 新订单未创建                    │
│  }                                                              │
│                                                                 │
│  语义:                                                          │
│  "请把订单 A 修改为订单 B"                                       │
│  如果订单 A 已经全部成交或不存在，则拒绝创建订单 B               │
│  如果订单 A 已部分成交，撤销剩余部分，返回已成交量，            │
│  拒绝创建订单 B（由 AMM 根据新库存状态重新决策）                │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  5. 查询持仓                                                     │
│  ────────────                                                   │
│  GET /api/positions?userId=AMM_SYSTEM_001&marketId=market_001   │
│                                                                 │
│  6. 查询余额                                                     │
│  ────────────                                                   │
│  GET /api/accounts/AMM_SYSTEM_001                               │
│                                                                 │
│  7. 订阅成交事件                                                 │
│  ────────────────                                               │
│  Kafka Topic: trade_events                                      │
│  Filter: maker_user_id = "AMM_SYSTEM_001"                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 初始化流程（铸造合约）

```
┌─────────────────────────────────────────────────────────────────┐
│                       AMM 初始化铸造                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  管理员操作: 为 Market #001 启用 AMM，注入 $1000                 │
│                                                                 │
│  方案A: 通过跨账本买单铸造 (推荐)                                │
│  ────────────────────────────                                   │
│  AMM 同时下两个买单:                                             │
│    Buy Yes @ 0.50 × 1000份                                      │
│    Buy No  @ 0.50 × 1000份                                      │
│                                                                 │
│  由于 0.50 + 0.50 = 1.00，满足跨账本条件                         │
│  两个买单互相撮合，AMM 获得:                                     │
│    1000 份 Yes                                                  │
│    1000 份 No                                                   │
│  支付: $1000 (进入托管账户)                                      │
│                                                                 │
│  方案B: 系统内部铸造（需要特殊接口）                             │
│  ────────────────────────────────                               │
│  POST /api/admin/amm/mint                                       │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "ammUserId": "AMM_SYSTEM_001",                               │
│    "funding": 100000,       // $1000（美分）                    │
│    "shares": 1000           // 铸造 1000 对 Yes+No              │
│  }                                                              │
│                                                                 │
│  系统执行:                                                       │
│  1. 从 AMM 账户扣除 $1000                                        │
│  2. 向托管账户存入 $1000                                         │
│  3. 给 AMM 创建 1000 份 Yes 持仓                                 │
│  4. 给 AMM 创建 1000 份 No 持仓                                  │
│                                                                 │
│  推荐: 方案A 更符合"非侵入"原则                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.3 事件驱动更新

```
┌─────────────────────────────────────────────────────────────────┐
│                       事件驱动架构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                 ┌─────────────────────┐                         │
│                 │   Kafka / Redis     │                         │
│                 │   trade_events      │                         │
│                 └──────────┬──────────┘                         │
│                            │                                    │
│                            ▼                                    │
│                 ┌─────────────────────┐                         │
│                 │   Market Listener   │                         │
│                 │                     │                         │
│                 │   Filter:           │                         │
│                 │   maker = AMM       │                         │
│                 └──────────┬──────────┘                         │
│                            │                                    │
│                            ▼                                    │
│       ┌─────────────────────────────────────┐                   │
│       │         Strategy Engine             │                   │
│       │                                     │                   │
│       │  1. 从 Redis 读取库存 (Y, N)        │ ◀── 必须从Redis   │
│       │  2. 重新计算公允价格                │                   │
│       │  3. 生成新的目标挂单列表            │                   │
│       └──────────────────┬──────────────────┘                   │
│                          │                                      │
│                          ▼                                      │
│       ┌─────────────────────────────────────┐                   │
│       │         Order Manager               │                   │
│       │                                     │                   │
│       │  1. 对比当前挂单 vs 目标挂单        │                   │
│       │  2. 计算差量                        │                   │
│       │  3. 调用原子改单 API (v3.0)         │ ◀── 原子操作      │
│       └─────────────────────────────────────┘                   │
│                                                                 │
│  延迟要求: 毫秒级                                                │
│  建议: AMM 服务与撮合引擎部署在同一内网                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.4 手续费处理机制（v3.2 新增）

> ⚠️ **v3.2 新增**：明确 AMM 的手续费处理规则，与撮合引擎 v4.0 第 3.6 节对齐。

```
┌─────────────────────────────────────────────────────────────────┐
│                   AMM 手续费处理机制                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  核心规则:                                                       │
│  ──────────                                                     │
│  1. AMM 始终是 Maker（挂单等待被吃）                             │
│  2. AMM 正常支付 Maker Fee                                       │
│  3. 撮合引擎无需对 AMM 做任何特殊处理                            │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  角色判定:                                                       │
│  ──────────                                                     │
│  AMM 定位是"冷启动阶段提供流动性"                                │
│  AMM 只挂卖单等待被吃 → AMM 始终是 Maker                        │
│  用户来吃 AMM 的单 → 用户是 Taker                               │
│                                                                 │
│  成交示例:                                                       │
│  ──────────                                                     │
│  用户 Buy YES @ 65 美分 (Taker)                                 │
│       ↓ 吃掉                                                    │
│  AMM Sell YES @ 63 美分 (Maker)                                 │
│                                                                 │
│  成交价 = 63 美分 (Maker 价格)                                   │
│  AMM 收入 = 63 × 数量 - Maker Fee                               │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  手续费计算示例:                                                 │
│  ───────────────                                                │
│  假设 Maker Fee = 0.05% (5 万分之一)                            │
│  成交: 100 份 YES @ 63 美分                                     │
│                                                                 │
│  成交金额 = 63 × 100 = 6300 美分                                │
│  手续费 = 6300 × 5 / 10000 = 3.15 → 向上取整 = 4 美分           │
│  AMM 实际到账 = 6300 - 4 = 6296 美分                            │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  设计理由:                                                       │
│  ──────────                                                     │
│  1. 符合"AMM 是普通用户"的设计哲学                              │
│  2. 撮合引擎零侵入，无需特殊处理                                 │
│  3. Maker Fee 本来就低，对 AMM 影响较小                         │
│  4. 手续费可通过点差覆盖                                         │
│                                                                 │
│  建议配置:                                                       │
│  ──────────                                                     │
│  配置点差时考虑手续费因素:                                       │
│    实际点差 ≥ 期望点差 + Maker Fee Rate                         │
│                                                                 │
│  例: 期望点差 2%，Maker Fee 0.05%                               │
│      建议实际点差 ≥ 2.05%（可简化为 2%，手续费占比极小）         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**AMM 手续费追踪（内部记录）:**

```python
class AMMFeeTracker:
    """
    AMM 手续费追踪器（v3.2 新增）

    用于盈亏报表和审计，不影响撮合引擎逻辑
    """

    def __init__(self, market_id: str):
        self.market_id = market_id
        self.total_fees_paid = 0       # 累计支付手续费（美分）
        self.total_trades = 0          # 累计成交笔数
        self.fee_records = []          # 手续费明细

    def record_trade(self, trade_event: TradeEvent):
        """记录成交及对应手续费"""
        if trade_event.maker_id != AMM_USER_ID:
            return

        # 手续费已由撮合引擎扣除，这里只记录
        fee_amount = trade_event.maker_fee

        self.total_fees_paid += fee_amount
        self.total_trades += 1
        self.fee_records.append({
            "trade_id": trade_event.trade_id,
            "timestamp": trade_event.timestamp,
            "amount": trade_event.quantity * trade_event.price,
            "fee": fee_amount
        })

    def get_fee_summary(self) -> dict:
        """获取手续费汇总（v7.0: 修复精度问题）"""
        return {
            "market_id": self.market_id,
            "total_fees_paid": self.total_fees_paid,       # 美分
            "total_trades": self.total_trades,
            # v7.0: 使用浮点数保留精度，避免整数除法丢失信息
            "avg_fee_per_trade": round(self.total_fees_paid / self.total_trades, 2)
                                 if self.total_trades > 0 else 0.0,
            # 新增: 手续费占总成交额比例
            "fee_ratio": round(self.total_fees_paid /
                         sum(r['amount'] for r in self.fee_records), 4)
                         if self.fee_records else 0.0
        }
```

---

## 九、管理员控制（v4.0 增强）

### 9.1 控制接口

```
┌─────────────────────────────────────────────────────────────────┐
│                      管理员控制接口                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 启动 AMM                                                    │
│  ────────────                                                   │
│  POST /api/admin/amm/start                                      │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "initialFunding": 100000,     // 初始资金（美分）$1000       │
│    "initialProbability": 0.50,   // 初始概率 (可选)             │
│    "spread": 2,                  // 点差 2 美分 (2%)            │
│    "levels": 5,                  // 阶梯数                      │
│    "quantityPerLevel": 100,      // 每档数量                    │
│    "autoReinvest": true          // ⭐ v3.0: 启用自动复投       │
│  }                                                              │
│                                                                 │
│  2. 停止 AMM                                                    │
│  ────────────                                                   │
│  POST /api/admin/amm/stop                                       │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "mode": "SOFT"   // SOFT: 停止挂新单 | HARD: 立即撤所有单    │
│  }                                                              │
│                                                                 │
│  3. 追加资金                                                     │
│  ────────────                                                   │
│  POST /api/admin/amm/fund                                       │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "amount": 50000               // 追加 $500（美分）           │
│  }                                                              │
│                                                                 │
│  4. 提取资金                                                     │
│  ────────────                                                   │
│  POST /api/admin/amm/withdraw                                   │
│  {                                                              │
│    "marketId": "market_001"                                     │
│    // 执行 Merge: 把 Yes+No 配对销毁，换回现金                  │
│  }                                                              │
│                                                                 │
│  5. 调整参数                                                     │
│  ────────────                                                   │
│  PUT /api/admin/amm/config                                      │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "spread": 3,                  // 调整点差为 3 美分 (3%)      │
│    "maxExposure": 0.8,           // 最大敞口 80%                │
│    "autoReinvestThreshold": 50000,  // ⭐ v3.0: 复投阈值（美分）│
│    "minInventoryRatio": 0.2      // ⭐ v3.0: 最小库存比例       │
│  }                                                              │
│                                                                 │
│  6. 查询状态                                                     │
│  ────────────                                                   │
│  GET /api/admin/amm/status?marketId=market_001                  │
│                                                                 │
│  返回:                                                          │
│  {                                                              │
│    "marketId": "market_001",                                    │
│    "status": "RUNNING",                                         │
│    "inventory": { "yes": 850, "no": 1150 },                     │
│    "cash": 15000,                // ⭐ v3.0: 现金余额（美分）    │
│    "fairPrice": { "yes": 57, "no": 43 },  // 美分               │
│    "exposure": 0.30,             // 敞口比例                    │
│    "pnl": -1500,                 // 盈亏（美分）                 │
│    "activeOrders": 10,                                          │
│    "autoReinvest": {             // ⭐ v3.0: 自动复投状态       │
│      "enabled": true,                                           │
│      "lastMintAt": "2025-01-09T10:30:00Z",                      │
│      "totalMinted": 500                                         │
│    }                                                            │
│  }                                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.2 初始概率设置

```
┌─────────────────────────────────────────────────────────────────┐
│                      初始概率设置                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  并非所有事件都是 50/50 开局                                     │
│                                                                 │
│  场景: 管理员认为"川普胜选"的初始概率是 60%                      │
│                                                                 │
│  方法: 不平衡铸造                                                │
│  ──────────────────                                             │
│  初始资金: $1000                                                │
│  目标价格: Yes = 60%, No = 40%                                  │
│                                                                 │
│  根据公式 Price_Yes = N / (Y + N) = 0.60                        │
│  解得: N = 1.5 × Y                                              │
│                                                                 │
│  如果 Y + N 对应 $1000:                                         │
│    Y = 400 份 Yes                                               │
│    N = 600 份 No                                                │
│                                                                 │
│  验证:                                                          │
│  Price_Yes = 600 / (400 + 600) = 0.60  ✓                        │
│  Price_No  = 400 / (400 + 600) = 0.40  ✓                        │
│                                                                 │
│  实现方式:                                                       │
│  ──────────                                                     │
│  方案1: 先平衡铸造，再调整库存                                   │
│    1. 铸造 500 Yes + 500 No                                     │
│    2. AMM 内部"卖出" 100 Yes（不实际挂单）                       │
│    3. 库存变为 400 Yes + 600 No                                 │
│                                                                 │
│  方案2: 直接不平衡铸造（需要特殊接口）                           │
│    直接创建 400 Yes + 600 No 持仓                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.3 退出策略

```
┌─────────────────────────────────────────────────────────────────┐
│                       AMM 退出策略                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  场景: 市场已经热起来，有足够的自然用户，管理员想关闭 AMM        │
│                                                                 │
│  软退出 (SOFT STOP)                                             │
│  ──────────────────                                             │
│  1. AMM 停止挂新单                                               │
│  2. 现有挂单保留，等待被吃或手动撤单                             │
│  3. AMM 不再响应成交事件                                         │
│  4. 适合: 希望挂单自然消化，不造成市场波动                       │
│                                                                 │
│  硬退出 (HARD STOP)                                             │
│  ──────────────────                                             │
│  1. AMM 立即撤销所有挂单                                         │
│  2. 执行 Merge 操作:                                             │
│     - 把 min(Yes, No) 对合约销毁                                │
│     - 换回对应现金                                               │
│  3. 剩余的单边持仓:                                              │
│     - 可以挂单卖掉                                               │
│     - 或者持有到结算                                             │
│  4. 适合: 紧急情况，需要快速回收资金                             │
│                                                                 │
│  示例:                                                          │
│  ──────                                                         │
│  当前库存: 300 Yes + 700 No                                     │
│                                                                 │
│  Merge: 销毁 300 Yes + 300 No = 回收 $300                       │
│  剩余: 0 Yes + 400 No                                           │
│                                                                 │
│  选择:                                                          │
│  A. 持有 400 No 到结算                                          │
│     - 如果 No 赢: 获得 $400                                     │
│     - 如果 Yes 赢: 获得 $0                                      │
│  B. 挂单卖出 400 No                                             │
│     - 以市场价变现，锁定当前价值                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 十、全栈风控体系 (v4.0 重构)

### 10.1 三道防线架构

```
┌─────────────────────────────────────────────────────────────────┐
│                全栈式风控体系 (3-Layer Defense Stack)            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  第一道防线: 全局预算与熔断 (Global Budget & Kill Switch)       │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【补贴预算化】                                                 │
│  • 设定"单日最大亏损额" (Daily Loss Limit)                     │
│  • 示例: "今日允许亏损 1000 USDT 用于做市"                     │
│  • 触发后: 自动停止 或 降级为"只平仓不建仓"                    │
│                                                                 │
│  【异常熔断 (Kill Switch)】                                     │
│  • 价格跳变: 5分钟内价格波动 > 15%，暂停报价                   │
│  • API 错误: 错误率 > 10%，强制下线                            │
│  • 延迟过高: 延迟 > 100ms，暂停报价                            │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  第二道防线: 库存硬阈值 (Inventory Hard Limits)                 │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【阈值分层】                                                   │
│  ┌────────────────────────────────────────────────────────┐    │
│  │  0%       30%        60%        80%        100%        │    │
│  │  ├─────────┼──────────┼──────────┼──────────┤          │    │
│  │  │ 正常区  │ 警告区   │ 危险区   │ 禁止区   │          │    │
│  │  │         │ 扩点差   │ 单边报价 │ 全撤单   │          │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  【动作优先级】                                                 │
│  1. 加宽价差: 库存 ≥ 60%，Spread × 1.5                         │
│  2. 折价抛售: 库存 ≥ 80%，停止买入，只挂平仓单 (v7.1 改进)     │
│     - 价格 = 保留价 - distress_discount (0~5美分折价)          │
│     - 折价随超出 80% 的比例线性递增，到 90% 时折满 5 美分       │
│     - 目的: 主动降价甩货，而非消极等待                          │
│  3. Kill Switch: 库存 ≥ 90%，撤销所有订单，发警报              │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  第三道防线: 微观结构防护 (Micro-structure Protection)          │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【自成交预防 (STP)】                                           │
│  • 交易所级别: EXPIRE_TAKER 模式                                │
│  • 代码级别: 下单前检查是否会自成交                             │
│                                                                 │
│  【逆向选择监测 (VPIN)】                                        │
│  • 计算: VPIN = |sell_ratio - 0.5| × 2                         │
│  • 阈值: VPIN > 0.7 说明有知情交易者                           │
│  • 动作: 大幅下移买单 或 暂停报价                              │
│                                                                 │
│  【延迟防卫】                                                   │
│  • 检测 WebSocket 延迟                                          │
│  • 延迟 > 50ms 时撤单                                           │
│  • 原因: HFT 会利用延迟套利                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10.2 风控引擎实现

```python
class DefenseStack:
    """全栈风控引擎"""

    def __init__(self, config: DefenseStackConfig):
        self.config = config
        self.daily_pnl = 0
        self.trade_history = []
        self.price_history = []

    def check_all_defenses(self, market_state: dict) -> DefenseResult:
        """
        检查所有防线

        Returns:
            DefenseResult {
                action: 'NORMAL' | 'WIDEN_SPREAD' | 'ONE_SIDE' | 'HALT' | 'KILL',
                reason: str,
                params: dict
            }
        """
        # ════════════════════════════════════════════
        # 第一道防线: 全局预算与熔断
        # ════════════════════════════════════════════

        # 检查每日亏损
        if self.daily_pnl < -self.config.daily_loss_limit:
            return DefenseResult(
                action='KILL',
                reason='DAILY_LOSS_LIMIT',
                params={'pnl': self.daily_pnl}
            )

        # 检查价格跳变
        if self._detect_price_jump():
            return DefenseResult(
                action='HALT',
                reason='PRICE_JUMP',
                params={'volatility': self._calc_recent_volatility()}
            )

        # 检查 API 错误率
        if market_state.get('error_rate', 0) > self.config.api_error_threshold:
            return DefenseResult(
                action='HALT',
                reason='HIGH_ERROR_RATE',
                params={'error_rate': market_state['error_rate']}
            )

        # 检查延迟
        if market_state.get('latency_ms', 0) > self.config.max_latency_ms:
            return DefenseResult(
                action='HALT',
                reason='HIGH_LATENCY',
                params={'latency': market_state['latency_ms']}
            )

        # ════════════════════════════════════════════
        # 第二道防线: 库存硬阈值
        # ════════════════════════════════════════════

        inventory_ratio = self._calc_inventory_ratio(market_state)

        if inventory_ratio >= self.config.inventory_hard_limit:
            return DefenseResult(
                action='KILL',
                reason='INVENTORY_HARD_LIMIT',
                params={'ratio': inventory_ratio}
            )

        if inventory_ratio >= self.config.inventory_danger_threshold:
            # v7.1: 极端偏斜报价改进 —— 不再只是"公允价 + 宽点差"
            # 而是计算 distress_discount 折价，主动降价抛售多余库存
            excess_ratio = inventory_ratio - self.config.inventory_danger_threshold
            # 超出危险阈值越多，折价越深（线性递增，上限 distress_max_discount）
            distress_discount = min(
                self.config.distress_max_discount,
                int(excess_ratio / (self.config.inventory_hard_limit
                    - self.config.inventory_danger_threshold)
                    * self.config.distress_max_discount)
            )
            return DefenseResult(
                action='ONE_SIDE',
                reason='INVENTORY_DANGER',
                params={
                    'ratio': inventory_ratio,
                    'spread_multiplier': self.config.spread_multiplier_danger,
                    'distress_discount': distress_discount,  # v7.1: 折价美分数
                    'heavy_side': self._get_heavy_side(market_state)  # YES or NO
                }
            )

        if inventory_ratio >= self.config.inventory_warning_threshold:
            return DefenseResult(
                action='WIDEN_SPREAD',
                reason='INVENTORY_WARNING',
                params={
                    'ratio': inventory_ratio,
                    'spread_multiplier': self.config.spread_multiplier_warning
                }
            )

        # ════════════════════════════════════════════
        # v7.0 新增: 价格极值保护
        # ════════════════════════════════════════════
        fair_price = market_state.get('fair_price', 50)

        # 价格接近 0 或 100: 市场趋于确定性，做市风险极大
        if fair_price <= self.config.extreme_price_kill or \
           fair_price >= (100 - self.config.extreme_price_kill):
            return DefenseResult(
                action='KILL',
                reason='EXTREME_PRICE_KILL',
                params={'fair_price': fair_price}
            )

        if fair_price <= self.config.extreme_price_halt or \
           fair_price >= (100 - self.config.extreme_price_halt):
            return DefenseResult(
                action='WIDEN_SPREAD',
                reason='EXTREME_PRICE_WIDEN',
                params={
                    'fair_price': fair_price,
                    'spread_multiplier': self.config.extreme_spread_multiplier
                }
            )

        # ════════════════════════════════════════════
        # 第三道防线: 微观结构防护
        # ════════════════════════════════════════════

        # 检查 VPIN
        vpin = self._calculate_vpin()
        if vpin > self.config.vpin_threshold:
            return DefenseResult(
                action='WIDEN_SPREAD',
                reason='HIGH_VPIN',
                params={'vpin': vpin, 'spread_multiplier': 2.0}
            )

        # 所有检查通过
        return DefenseResult(action='NORMAL', reason=None, params={})

    def _detect_price_jump(self) -> bool:
        """检测价格跳变"""
        if len(self.price_history) < 2:
            return False

        window_ms = self.config.price_jump_window_ms
        cutoff = current_time_ms() - window_ms

        window_prices = [p for t, p in self.price_history if t >= cutoff]
        if len(window_prices) < 2:
            return False

        max_p = max(window_prices)
        min_p = min(window_prices)
        change = (max_p - min_p) / min_p

        return change > self.config.price_jump_threshold

    def _calculate_vpin(self) -> float:
        """
        计算 VPIN (Volume-Synchronized Probability of Informed Trading)

        简化实现: 计算窗口内卖单成交占比的偏离度
        """
        if len(self.trade_history) < self.config.vpin_window:
            return 0.0

        recent = self.trade_history[-self.config.vpin_window:]
        sell_vol = sum(t['qty'] for t in recent if t['side'] == 'SELL')
        total_vol = sum(t['qty'] for t in recent)

        if total_vol == 0:
            return 0.0

        sell_ratio = sell_vol / total_vol
        vpin = abs(sell_ratio - 0.5) * 2  # 映射到 [0, 1]

        return vpin

    def _calc_inventory_ratio(self, market_state: dict) -> float:
        """计算库存偏离比例"""
        yes_inv = market_state.get('yes_inventory', 0)
        no_inv = market_state.get('no_inventory', 0)
        total = yes_inv + no_inv
        if total == 0:
            return 0.0
        return abs(yes_inv - no_inv) / total

    def _get_heavy_side(self, market_state: dict) -> str:
        """v7.1: 判断哪一边库存偏重"""
        yes_inv = market_state.get('yes_inventory', 0)
        no_inv = market_state.get('no_inventory', 0)
        return 'YES' if yes_inv > no_inv else 'NO'


class DefenseStackConfig:
    """风控配置"""

    # 第一道防线: 全局预算
    daily_loss_limit: int = 100000          # $1000 (美分)
    price_jump_threshold: float = 0.15      # 15%
    price_jump_window_ms: int = 300000      # 5 分钟
    api_error_threshold: float = 0.10       # 10%
    max_latency_ms: int = 100               # 100ms

    # 第二道防线: 库存阈值
    inventory_warning_threshold: float = 0.60   # 60%
    inventory_danger_threshold: float = 0.80    # 80%
    inventory_hard_limit: float = 0.90          # 90%
    spread_multiplier_warning: float = 1.5
    spread_multiplier_danger: float = 3.0

    # v7.1 新增: ONE_SIDE 折价抛售参数
    distress_max_discount: int = 5              # 最大折价 5 美分（超出危险阈值→硬限制线性递增）

    # 第三道防线: 微观结构
    vpin_threshold: float = 0.70            # VPIN 警戒线
    vpin_window: int = 50                   # 计算窗口（笔数）

    # v7.0 新增: 价格极值保护
    extreme_price_kill: int = 5             # 价格 ≤ 5 或 ≥ 95 时，完全停止做市
    extreme_price_halt: int = 10            # 价格 ≤ 10 或 ≥ 90 时，大幅扩大点差
    extreme_spread_multiplier: float = 3.0  # 极值区点差放大倍数


@dataclass
class DefenseResult:
    """风控检查结果"""
    action: str      # NORMAL, WIDEN_SPREAD, ONE_SIDE, HALT, KILL
    reason: str
    params: dict
```

### 10.3 风控动作对照表

| 触发条件 | 动作 | 影响 |
|---------|------|------|
| 每日亏损超限 | KILL | 撤销所有订单，停止做市 |
| 价格跳变 > 15% | HALT | 暂停报价，等待人工确认 |
| API 错误率 > 10% | HALT | 暂停报价，等待恢复 |
| 延迟 > 100ms | HALT | 暂停报价，防止被套利 |
| 库存 ≥ 90% | KILL | 撤销所有订单，发警报 |
| 库存 ≥ 80% | ONE_SIDE | 只挂平仓单，点差 × 3 |
| 库存 ≥ 60% | WIDEN_SPREAD | 点差 × 1.5 |
| **价格 ≤ 5 或 ≥ 95** | **KILL** | **v7.0: 完全停止做市，市场已趋于确定性** |
| **价格 ≤ 10 或 ≥ 90** | **WIDEN_SPREAD** | **v7.0: 点差 × 3，降低极值区风险暴露** |
| VPIN > 0.7 | WIDEN_SPREAD | 点差 × 2，警惕知情交易者 |

### 10.4 风险类型分析（保留）

```
┌─────────────────────────────────────────────────────────────────┐
│                       AMM 风险分析                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  风险1: 方向性损失 (Directional Loss)                           │
│  ─────────────────────────────────────                          │
│  场景: 市场一边倒，所有用户都买 Yes                              │
│  v4.0 防护: 第二道防线 - 库存硬阈值                            │
│                                                                 │
│  风险2: LVR 损失 (Loss Versus Rebalancing) ⚠️ 关键风险          │
│  ─────────────────────────────────────────────────────          │
│  场景: 真实世界发生重大事件                                      │
│  v4.0 防护: 第一道防线 - 价格跳变熔断 + 第三道防线 - VPIN 检测 │
│                                                                 │
│  风险3: 流动性耗尽                                               │
│  ─────────────────────                                          │
│  场景: 库存被买光                                               │
│  v4.0 防护: 自动复投 + 库存预警                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10.5 库存管理：Auto-Merge 优先 + 严格复投（v7.1 重构）

> ⚠️ **v7.1 重构**：旧版自动复投存在"库存泥潭"陷阱——即使失衡度仅 55%，
> 铸造等量 YES+NO 后，市场会持续买走紧缺侧，留下冗余侧。
> 久而久之，AMM 现金耗尽，全部变为单边废头寸。
>
> **新策略**：Auto-Merge 优先于 Auto-Mint。优先配对销毁冗余头寸回收现金，
> 仅在双边同时枯竭时才铸造新对。

```python
def check_inventory_management(self):
    """
    库存管理主入口（v7.1 重构）

    优先级:
    1. Auto-Merge: 有冗余双边头寸时，配对销毁换回现金
    2. Auto-Mint:  只有双边同时枯竭 + 现金充足 + 失衡极低时才铸造
    """

    # ════ 阶段 1: Auto-Merge (优先) ════
    self._check_auto_merge()

    # ════ 阶段 2: Auto-Mint (严格条件) ════
    self._check_auto_mint()

def _check_auto_merge(self):
    """
    Auto-Merge: 自动配对销毁冗余头寸

    场景: YES=200, NO=800, 现金=100
    操作: 销毁 min(200, 800) = 200 对 → 回收 $200
    结果: YES=0, NO=600, 现金=300

    这比铸造新对（让 NO 从 800 变 900）有效得多。
    """
    if not self.config.autoMerge:
        return

    min_inventory = min(self.inventory.yes, self.inventory.no)

    # 只有当可配对数量 > 阈值时才执行 (避免频繁小额操作)
    if min_inventory < self.config.autoMergeMinPairs:
        return

    # 只有在现金不足时才需要 Merge 回血
    if self.inventory.cash >= self.config.autoReinvestThreshold:
        return

    # 保留一定基础库存，不全部销毁
    reserve = int(self.config.initialInventory * 0.1)  # 保留 10%
    merge_amount = max(0, min_inventory - reserve)

    if merge_amount > 0:
        self.trigger_merge(merge_amount)
        logger.info(f"Auto-merge: destroyed {merge_amount} pairs, "
                     f"recovered ${merge_amount} cash")

def _check_auto_mint(self):
    """
    Auto-Mint: 极严格条件下的铸造（v7.1 重构）

    触发条件 (必须全部满足):
    1. 双边库存同时低于最小水位 (不是只有一侧低)
    2. 现金充足
    3. 库存失衡度 < 30% (极严格，旧版是 60%)
    """
    if not self.config.autoReinvest:
        return

    # 条件 1: 现金充足
    if self.inventory.cash < self.config.autoReinvestThreshold:
        return

    # 条件 2: 双边同时低于最小水位 (v7.1: 不是"任一侧"，是"双侧同时")
    min_level = self.config.initialInventory * self.config.minInventoryRatio
    if self.inventory.yes >= min_level or self.inventory.no >= min_level:
        # 只要有一侧库存充足，就不铸造，依赖报价调整消化
        return

    # 条件 3: 失衡度极低 (v7.1: 从 60% 收严到 30%)
    total = self.inventory.yes + self.inventory.no
    if total > 0:
        imbalance = abs(self.inventory.yes - self.inventory.no) / total
        if imbalance > 0.30:
            logger.warn(f"Auto-mint skipped: imbalance={imbalance:.2%} > 30%, "
                         f"prefer Auto-Merge or price adjustment")
            return

    # 铸造
    max_from_cash = self.inventory.cash // 100
    need = self.config.initialInventory - min(self.inventory.yes, self.inventory.no)
    mint_amount = min(max_from_cash, need)

    if mint_amount > 0:
        self.trigger_mint(mint_amount)
        logger.info(f"Auto-mint: {mint_amount} pairs (strict conditions met)")
```

### 10.6 Oracle Guard 深度防御（v6.0 新增）

> ⚠️ **LVR (Loss Versus Rebalancing)** 是预测市场做市商面临的最核心风险。本节将 Oracle Guard 从简单的"校验器"升级为**"主动避险开关"**。

#### 10.6.1 为什么需要深度防御？

```
┌─────────────────────────────────────────────────────────────────┐
│                  LVR 风险的深层分析                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【知情交易者的套利优势】                                        │
│  ──────────────────────                                         │
│  重大事件（如比赛入球、政策发布）发生时：                        │
│  • 现实世界进展 快于 系统内价格更新                             │
│  • 知情交易者利用时间差，以"错误价格"清空你的库存               │
│  • 这就是"有毒流量 (Toxic Flow)"                                │
│                                                                 │
│  【LVR 的本质】                                                  │
│  ────────────                                                   │
│  • LVR = 因"价格发现滞后"付出的代价                             │
│  • 没有防御机制 = 向市场发放"免费期权"                          │
│                                                                 │
│  【预测市场的收敛特性】                                          │
│  ────────────────────                                           │
│  • 结算时间临近 → 价格对信息敏感度呈指数级增加                  │
│  • A-S 模型在平稳期有效，但极端行情需要更刚性的准入控制         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 10.6.2 四位一体的动态防御体系

```
┌─────────────────────────────────────────────────────────────────┐
│              Oracle Guard 四位一体防御架构 (v6.0)                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 1: 动态偏离度熔断 (Dynamic Deviation Threshold)           │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【问题】固定阈值无法适应不同市场状态                            │
│  【方案】基于波动率 σ 动态设定阈值                              │
│                                                                 │
│  公式: threshold = max(0.02, k × σ)                             │
│        k = 倍数因子 (建议 2.0)                                  │
│        σ = 市场波动率                                           │
│                                                                 │
│  当 |内部价 - Oracle价| / Oracle价 > threshold 时：             │
│    → 立即撤单，市场正处于剧烈价格发现阶段                       │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 2: 预言机陈旧度检查 (Staleness Guard)                     │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【问题】延迟数据比没有数据更危险                                │
│  【方案】设置最大允许延迟 max_oracle_lag = 3s                   │
│                                                                 │
│  如果 current_time - last_oracle_timestamp > max_oracle_lag：   │
│    → 进入"盲飞保护模式" (Passive Mode)                          │
│    → Spread 扩大 500%，或撤销所有靠近中价的挂单                 │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 3: 结算前夕阶梯缩量 (Time-to-Maturity Volume Scaling)     │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【问题】越接近结算，知情交易者优势越大                          │
│  【方案】阶梯式强制缩减挂单量                                    │
│                                                                 │
│  公式: max_order_size = base_size × (T - l)                     │
│                                                                 │
│  时间阶梯:                                                      │
│  ┌────────────────┬────────────────┬────────────────┐           │
│  │  距结算时间    │   缩量比例     │   说明         │           │
│  ├────────────────┼────────────────┼────────────────┤           │
│  │  > 24 小时     │   100%         │   正常运行     │           │
│  │  1 ~ 24 小时   │   50%          │   减半暴露     │           │
│  │  15分 ~ 1小时  │   20%          │   大幅缩减     │           │
│  │  < 15 分钟     │   5%           │   最小暴露     │           │
│  └────────────────┴────────────────┴────────────────┘           │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 4: 负反馈延迟挂单 (Post-Event Latency Delay)              │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【问题】价格跳空后双向收割                                      │
│  【方案】检测到 Oracle 价格跳空 > 5% 时，触发观察期             │
│                                                                 │
│  观察期行为 (默认 30 秒):                                       │
│  • 停止更新 Bid（买入价）                                       │
│  • 仅更新 Ask（卖出价）以防止被单边扫货                         │
│  • 待波动率平稳后恢复双向报价                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 10.6.3 Oracle Guard 引擎实现

```python
class OracleGuard:
    """
    Oracle Guard 深度防御引擎 (v6.0)

    四位一体防御：
    1. 动态偏离度熔断
    2. 预言机陈旧度检查
    3. 结算前夕阶梯缩量
    4. 负反馈延迟挂单
    """

    def __init__(self, config: OracleGuardConfig):
        self.config = config
        self.last_oracle_price = None
        self.last_oracle_time = None
        self.observation_mode_until = 0  # 观察期结束时间

    def check_oracle_safety(
        self,
        internal_mid_price: int,
        oracle_price: int,
        oracle_timestamp: int,
        market_volatility: float,
        time_to_expiry_ms: int
    ) -> OracleGuardResult:
        """
        Oracle 安全检查（主入口）

        Returns:
            OracleGuardResult {
                action: 'NORMAL' | 'WIDEN_SPREAD' | 'PASSIVE_MODE' |
                        'REDUCE_QTY' | 'ONE_SIDE_ONLY' | 'HALT',
                reason: str,
                params: dict
            }
        """
        current_time = current_time_ms()

        # ════════════════════════════════════════════
        # 检查 1: 预言机陈旧度
        # ════════════════════════════════════════════
        oracle_lag_ms = current_time - oracle_timestamp
        if oracle_lag_ms > self.config.max_oracle_lag_ms:
            return OracleGuardResult(
                action='PASSIVE_MODE',
                reason='ORACLE_STALE',
                params={
                    'lag_ms': oracle_lag_ms,
                    'spread_multiplier': 5.0  # 扩大 500%
                }
            )

        # ════════════════════════════════════════════
        # 检查 2: 动态偏离度
        # v7.1: 改为绝对美分差比较（σ 量纲已改为美分）
        # 旧 (v7.0): price_deviation = abs(internal - oracle) / oracle (百分比)
        # 新 (v7.1): price_diff_cents = abs(internal - oracle) (绝对美分)
        # ════════════════════════════════════════════
        price_diff_cents = abs(internal_mid_price - oracle_price)
        dynamic_threshold_cents = max(
            self.config.min_deviation_threshold_cents,
            self.config.deviation_multiplier * market_volatility  # volatility 单位已是美分
        )

        if price_diff_cents > dynamic_threshold_cents:
            return OracleGuardResult(
                action='HALT',
                reason='PRICE_DEVIATION',
                params={
                    'deviation_cents': price_diff_cents,
                    'threshold_cents': dynamic_threshold_cents
                }
            )

        # ════════════════════════════════════════════
        # 检查 3: 价格跳空 → 观察期
        # v7.1: 改为绝对美分跳空检测
        # ════════════════════════════════════════════
        if self.last_oracle_price is not None:
            price_gap_cents = abs(oracle_price - self.last_oracle_price)
            if price_gap_cents > self.config.gap_threshold_cents:
                self.observation_mode_until = current_time + self.config.observation_period_ms

        self.last_oracle_price = oracle_price
        self.last_oracle_time = oracle_timestamp

        # 在观察期内，只允许单边报价
        if current_time < self.observation_mode_until:
            return OracleGuardResult(
                action='ONE_SIDE_ONLY',
                reason='OBSERVATION_PERIOD',
                params={
                    'remaining_ms': self.observation_mode_until - current_time,
                    'allowed_side': 'ASK'  # 只允许卖单
                }
            )

        # ════════════════════════════════════════════
        # 检查 4: 结算前夕缩量
        # ════════════════════════════════════════════
        qty_scale = self._calculate_maturity_scale(time_to_expiry_ms)
        spread_scale = self._calculate_spread_scale(time_to_expiry_ms)

        if qty_scale < 1.0 or spread_scale > 1.0:
            return OracleGuardResult(
                action='REDUCE_QTY',
                reason='APPROACHING_EXPIRY',
                params={
                    'qty_multiplier': qty_scale,
                    'spread_multiplier': spread_scale,
                    'time_to_expiry_ms': time_to_expiry_ms
                }
            )

        # 所有检查通过
        return OracleGuardResult(action='NORMAL', reason=None, params={})

    def _calculate_maturity_scale(self, time_to_expiry_ms: int) -> float:
        """计算结算临近的数量缩放比例"""
        hours = time_to_expiry_ms / 3600000

        if hours > 24:
            return 1.0      # 100%
        elif hours > 1:
            return 0.5      # 50%
        elif hours > 0.25:  # 15 分钟
            return 0.2      # 20%
        else:
            return 0.05     # 5%

    def _calculate_spread_scale(self, time_to_expiry_ms: int) -> float:
        """计算结算临近的点差扩大比例"""
        hours = time_to_expiry_ms / 3600000

        if hours > 24:
            return 1.0
        elif hours > 1:
            return 1.5
        elif hours > 0.25:
            return 2.0
        else:
            return 3.0


class OracleGuardConfig:
    """Oracle Guard 配置 (v7.1: 偏离度改为绝对美分)"""

    # 陈旧度检查
    max_oracle_lag_ms: int = 3000           # 最大允许延迟 3 秒

    # 动态偏离度 (v7.1: 从百分比改为绝对美分)
    min_deviation_threshold_cents: int = 2  # 至少容忍 2 美分差价
    deviation_multiplier: float = 2.0       # 波动率倍数 (k)，threshold = max(2, k × σ_cents)

    # 价格跳空观察期 (v7.1: 从百分比改为绝对美分)
    gap_threshold_cents: int = 5            # 跳空阈值 5 美分
    observation_period_ms: int = 30000      # 观察期 30 秒

    # 结算临近配置 (内置于 _calculate_maturity_scale)


@dataclass
class OracleGuardResult:
    """Oracle Guard 检查结果"""
    action: str      # NORMAL, WIDEN_SPREAD, PASSIVE_MODE, REDUCE_QTY, ONE_SIDE_ONLY, HALT
    reason: str
    params: dict
```

#### 10.6.4 Oracle Guard 动作对照表

| 触发条件 | 动作 | 影响 |
|---------|------|------|
| Oracle 延迟 > 3s | PASSIVE_MODE | 点差 × 5，进入"盲飞保护" |
| 价格偏离 > max(2%, 2σ) | HALT | 立即撤单，暂停报价 |
| 价格跳空 > 5% | ONE_SIDE_ONLY | 30秒内只挂卖单 |
| 距结算 < 24h | REDUCE_QTY | 数量 × 50%，点差 × 1.5 |
| 距结算 < 1h | REDUCE_QTY | 数量 × 20%，点差 × 2 |
| 距结算 < 15min | REDUCE_QTY | 数量 × 5%，点差 × 3 |

### 10.7 无预言机 LVR 防御架构（v7.1 新增）

> ⚠️ **v7.1 致命修复**：Oracle Guard 严重依赖连续的外部预言机喂价。
> 但预测市场的结果往往是瞬间公布的（如比赛入球、选举结果），预言机本身是离散且滞后的。
> 没有连续高频输入时，系统要么永久盲飞，要么在突发事件瞬间被知情交易者抽干库存。
>
> **解决方案**：构建"不依赖外部预言机"的四重防御架构，从内部行为特征中自主感知危险。

```
┌─────────────────────────────────────────────────────────────────┐
│          无预言机 LVR 四重防御架构 (v7.1)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 A: 影子预言机监听 (Shadow Oracle) [可选增强]              │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【机制】监听外部高流动性大盘 (PolyMarket/Kalshi) 同类话题      │
│         的订单簿。外部大盘的瞬间跳跃或巨量扫单直接作为           │
│         本地 AMM 触发 HALT 撤单的信号。                          │
│  【限制】仅适用于外部存在同类市场的场景；独有市场退化为           │
│         依赖防御 B/C/D。                                        │
│  【接入】复用成熟开源做市系统 (如 Hummingbot) 的 WebSocket       │
│         基础设施。                                               │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 B: 毫秒级库存流失速率锁 (Velocity Limit) [核心]          │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【核心思路】外部信息慢，就从"自己被吃单的速度"中察觉危险。     │
│  【规则】如果 AMM 在 500ms 内单边库存流失 > 总挂单量的 20%，    │
│          立刻触发 KILL Switch 撤销所有挂单。                     │
│  【原因】正常散户不可能在 500ms 内连续扫完 20% 挂单量，          │
│          这是典型的知情交易者套利行为。                           │
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 C: 事件前夕结构性退让 (Pre-Event Shield) [已知事件]       │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【机制】针对已知结果公布时间的事件（如非农数据发布、比赛开      │
│         球、选举截票），硬编码时间窗口。                          │
│  【规则】事件前后 15 分钟内：                                    │
│          • 主动缩减 95% 挂单量                                  │
│          • 点差放大 5 倍                                         │
│          • 将流动性博弈交给市场散户                              │
│  【实现】管理后台配置: event_times: [timestamp1, timestamp2, ...]│
│                                                                 │
│  ════════════════════════════════════════════════════════════   │
│  防御 D: 非对称延迟重挂 (Post-Fill Delay) [核心]               │
│  ════════════════════════════════════════════════════════════   │
│                                                                 │
│  【核心修改】取消单边被连续吃单时的"原子改单瞬间补齐"逻辑。     │
│  【规则】一旦某笔挂单被成交:                                     │
│          • 强制冷却观察期 2-3 秒                                │
│          • 期间只撤不挂 (Cancel Only)                            │
│          • 观察期结束后，如果没有继续被扫单，才重新挂单          │
│  【原因】高频套利者依赖你"瞬间补单"来连续击穿防线。             │
│          引入延迟后，套利者必须承受价格不确定性。                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```python
class LVRDefense:
    """
    无预言机 LVR 防御引擎 (v7.1)

    不依赖外部预言机，从内部行为特征自主感知危险。
    """

    def __init__(self, config: 'LVRDefenseConfig'):
        self.config = config
        self.fill_history = []       # [(timestamp_ms, side, qty)]
        self.post_fill_cooldown_until = 0  # 冷却期结束时间

    def on_fill(self, timestamp_ms: int, side: str, qty: int,
                total_pending_qty: int) -> str:
        """
        每笔成交后调用，返回防御动作

        Args:
            timestamp_ms: 成交时间
            side: 'YES' or 'NO' (被吃掉的方向)
            qty: 成交数量
            total_pending_qty: AMM 该方向当前总挂单量

        Returns:
            'NORMAL' | 'KILL' | 'COOLDOWN'
        """
        self.fill_history.append((timestamp_ms, side, qty))

        # ═══ 防御 B: 库存流失速率锁 ═══
        velocity_window_ms = self.config.velocity_window_ms
        cutoff = timestamp_ms - velocity_window_ms
        recent_fills = [
            (t, s, q) for t, s, q in self.fill_history
            if t >= cutoff and s == side
        ]
        recent_loss = sum(q for _, _, q in recent_fills)

        if total_pending_qty > 0:
            loss_ratio = recent_loss / total_pending_qty
            if loss_ratio > self.config.velocity_kill_ratio:
                return 'KILL'

        # ═══ 防御 D: 非对称延迟重挂 ═══
        self.post_fill_cooldown_until = timestamp_ms + self.config.post_fill_delay_ms
        return 'COOLDOWN'

    def is_in_cooldown(self, current_time_ms: int) -> bool:
        """检查是否处于冷却期"""
        return current_time_ms < self.post_fill_cooldown_until

    def is_in_event_window(self, current_time_ms: int,
                           event_times: list) -> bool:
        """
        防御 C: 检查是否在已知事件前后窗口内
        """
        window_ms = self.config.event_shield_window_ms
        for event_time in event_times:
            if abs(current_time_ms - event_time) < window_ms:
                return True
        return False


class LVRDefenseConfig:
    """LVR 防御配置"""

    # 防御 B: 库存流失速率锁
    velocity_window_ms: int = 500            # 检测窗口 500ms
    velocity_kill_ratio: float = 0.20        # 单边流失 > 20% 触发 KILL

    # 防御 C: 事件前夕退让
    event_shield_window_ms: int = 900000     # 事件前后 15 分钟
    event_qty_ratio: float = 0.05            # 缩减到 5% 挂单量
    event_spread_multiplier: float = 5.0     # 点差放大 5 倍

    # 防御 D: 非对称延迟重挂
    post_fill_delay_ms: int = 2500           # 成交后冷却 2.5 秒
```

#### 10.7.1 LVR 防御动作对照表

| 触发条件 | 动作 | 影响 |
|---------|------|------|
| 500ms 内单边流失 > 20% 挂单量 | KILL | 立即撤销所有挂单，发警报 |
| 进入已知事件前后 15 分钟窗口 | REDUCE + WIDEN | 挂单量 × 5%，点差 × 5 |
| 任意挂单被成交 | COOLDOWN (2.5s) | 冷却期内只撤不挂 |
| 外部大盘检测到跳空 (影子预言机) | HALT | 撤单等待确认（可选功能） |

#### 10.7.2 与 DefenseStack 的集成

```python
def check_all_defenses(self, market_state: dict) -> DefenseResult:
    """集成 Oracle Guard 的完整风控检查"""

    # ════════════════════════════════════════════
    # 前置检查: Oracle Guard (v6.0 新增)
    # ════════════════════════════════════════════
    oracle_result = self.oracle_guard.check_oracle_safety(
        internal_mid_price=market_state['mid_price'],
        oracle_price=market_state['oracle_price'],
        oracle_timestamp=market_state['oracle_timestamp'],
        market_volatility=market_state['volatility'],
        time_to_expiry_ms=market_state['time_to_expiry_ms']
    )

    if oracle_result.action == 'HALT':
        return DefenseResult(
            action='HALT',
            reason=f'ORACLE_GUARD_{oracle_result.reason}',
            params=oracle_result.params
        )

    if oracle_result.action == 'PASSIVE_MODE':
        return DefenseResult(
            action='WIDEN_SPREAD',
            reason='ORACLE_STALE',
            params=oracle_result.params
        )

    # 保存 Oracle Guard 的缩量/扩差建议，后续应用
    self._oracle_adjustments = oracle_result.params

    # ... 继续执行原有的三道防线检查 ...
```

### 10.8 波动率 σ 计算方法（v7.1 重写：绝对价差 + 伯努利方差衰减混合模型）

> ⚠️ **v7.1 致命修复**：v7.0 采用的"对数收益率标准差 $\ln(P_t / P_{t-1})$"是典型的传统股票波动率算法，
> 在预测市场中存在数学不自洽，属于**致命设计缺陷**。

#### 10.8.1 为什么对数收益率不适用于预测市场？

预测市场的核心特征是**价格有界性**：价格恒定在 1-99 美分之间，代表 1%-99% 的概率。
这与传统金融市场（如股票，价格理论上无上限）有着本质的区别。
类似于期权交易中的二元期权（Binary Options），当极端行情出现、概率逼近 0 或 100 时，
价格的"绝对变动空间"会被压缩。

**对数收益率在预测市场的数学爆炸**：

```
┌─────────────────────────────────────────────────────────────────┐
│          对数收益率 vs 绝对价差 —— 同样涨 1 美分                  │
├──────────────┬──────────────────┬────────────────────────────── │
│  价格区间     │  对数收益率        │  绝对价差                     │
├──────────────┼──────────────────┼────────────────────────────── │
│  1 → 2 美分  │  ln(2) ≈ 69.3%   │  1 美分                       │
│  5 → 6 美分  │  ln(1.2) ≈ 18.2% │  1 美分                       │
│  10 → 11 美分│  ln(1.1) ≈ 9.5%  │  1 美分                       │
│  50 → 51 美分│  ln(1.02) ≈ 2.0% │  1 美分                       │
│  90 → 91 美分│  ln(1.01) ≈ 1.1% │  1 美分                       │
├──────────────┴──────────────────┴────────────────────────────── │
│                                                                 │
│  结论: 对数收益率在低价区（1-5 美分）和高价区（95-99 美分）       │
│  产生量级差异高达 30-70 倍的虚假波动率膨胀。                      │
│  同一笔"涨 1 美分"的交易，在不同价格区间被评估为完全不同的风险。│
│                                                                 │
│  后果:                                                          │
│  ① 风控频繁误触: σ 爆炸导致 Oracle Guard 动态阈值暴涨或 A-S 偏移│
│  ② A-S 保留价格离谱: σ² 项在极值区放大数十倍，库存调整失控      │
│  ③ 风险度量不公平: 低价区的正常交易被标记为"极端波动"           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 10.8.2 绝对价差波动率 + 伯努利方差衰减混合模型 (APV-BVD)

为解决上述问题，我们为预测市场量身定制一套 **绝对价差波动率 (Absolute Price Volatility, APV)
结合伯努利方差衰减 (Bernoulli Variance Decay, BVD)** 的混合模型。

```
┌─────────────────────────────────────────────────────────────────┐
│       APV-BVD 混合波动率模型 (v7.1)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ═══ Step 1: 绝对收益率计算 ═══                                 │
│                                                                 │
│  抛弃对数收益率，直接以"美分绝对差值"为基础:                     │
│    ΔP_t = P_t - P_{t-1}                                         │
│  (例如: 50 → 52 美分, ΔP = 2; 5 → 6 美分, ΔP = 1)              │
│                                                                 │
│  ═══ Step 2: 基础绝对波动率 (Base Absolute Volatility) ═══      │
│                                                                 │
│  取滚动窗口内 ΔP 的样本标准差:                                   │
│    σ_base = sqrt( Σ(ΔP_i - μ_ΔP)² / (N-1) )                    │
│  注: σ_base 单位直接是"美分"，无需任何单位转换                   │
│                                                                 │
│  ═══ Step 3: 伯努利方差约束 (Bernoulli Variance Constraint) ═══ │
│                                                                 │
│  预测市场是对离散事件概率 p 的定价。                              │
│  根据伯努利分布，理论最大方差 = p(1-p)，出现在 p=0.5。           │
│  当 p→0 或 p→1 时，不确定性消除，波动率必须收敛。                │
│                                                                 │
│  约束因子:                                                      │
│    W_bernoulli = P_current × (100 - P_current) / 2500           │
│                                                                 │
│  约束因子取值表:                                                │
│  ┌────────┬────────┬──────────────────────────────────────┐     │
│  │ P (美分)│  W 值  │ 说明                                 │     │
│  ├────────┼────────┼──────────────────────────────────────┤     │
│  │   50   │  1.00  │ 最大不确定性，σ 完全反映真实波动      │     │
│  │   30   │  0.84  │ 轻度压缩                              │     │
│  │   10   │  0.36  │ σ 压缩到 60% (√0.36 = 0.6)           │     │
│  │    5   │  0.19  │ σ 压缩到 44% (√0.19 ≈ 0.44)          │     │
│  │    3   │  0.12  │ σ 压缩到 34% (√0.12 ≈ 0.34)          │     │
│  │    1   │  0.04  │ σ 压缩到 20% (√0.04 = 0.2)           │     │
│  └────────┴────────┴──────────────────────────────────────┘     │
│                                                                 │
│  ═══ Step 4: 最终修正波动率 ═══                                 │
│                                                                 │
│    σ_final = max(1.0, min(15.0, σ_base × √W_bernoulli))        │
│    单位: 美分                                                   │
│    下限 1 美分: 防止 A-S 公式中调整项归零                        │
│    上限 15 美分: 防止异常噪音数据导致过度膨胀                    │
│                                                                 │
│  ═══ 量纲联动变更 ═══                                           │
│                                                                 │
│  A-S 公式:                                                      │
│    r = s - q·γ·σ²·τ(h)                                          │
│    旧 (v7.0): σ 无量纲, 需 ×100 转美分                          │
│    新 (v7.1): σ 直接是美分, 去掉 ×100                            │
│                                                                 │
│  Oracle Guard 偏离度阈值:                                       │
│    旧: threshold = max(0.02, k × σ)  (百分比比较)               │
│    新: threshold = max(2, k × σ)     (绝对美分比较)             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 10.8.3 VolatilityEstimator 实现

```python
import math

class VolatilityEstimator:
    """
    预测市场专用波动率估算器 (v7.1 重写)

    模型: 绝对价差波动率 (APV) + 伯努利方差衰减 (BVD)
    量纲: 美分 (绝对值)，通常在 [1.0, 10.0] 之间
    适用: 预测市场概率价格 (1-99 美分)

    核心设计:
    1. 用绝对价差 ΔP (而非对数收益率 ln(P_t/P_{t-1})) 避免极端价格区的数学爆炸
    2. 用伯努利方差因子 W = P(100-P)/2500 约束: 价格越接近 0/100，波动率越被压缩
    3. 设定下限 1 美分 (保证 A-S 最小调整能力)、上限 15 美分 (防止噪音膨胀)
    """

    def __init__(self, window_size: int = 30, min_samples: int = 5):
        """
        Args:
            window_size: 滚动窗口大小（最近 N 笔成交）
            min_samples: 最少样本数，不足时返回默认波动率
        """
        self.window_size = window_size
        self.min_samples = min_samples
        self.price_history = []  # [(timestamp_ms, price_cents)]
        self.default_volatility_cents = 2.0  # 默认绝对波动率 2 美分

    def add_price(self, timestamp_ms: int, price_cents: int):
        """记录价格观察值"""
        self.price_history.append((timestamp_ms, price_cents))
        # 只保留最近的观察值，避免内存泄漏
        if len(self.price_history) > self.window_size * 2:
            self.price_history = self.price_history[-self.window_size:]

    def estimate(self, current_price_cents: int = None) -> float:
        """
        估算当前波动率 (单位: 美分)

        Args:
            current_price_cents: 当前公允价格 (1-99 美分)，用于伯努利约束。
                                如未提供，使用最新观察价。

        Returns:
            sigma: 绝对波动率（美分），范围 [1.0, 15.0]
        """
        prices = [p for _, p in self.price_history[-self.window_size:]]
        if len(prices) < self.min_samples:
            return self.default_volatility_cents

        # ──── Step 1: 计算绝对价格差 (Absolute Differences) ────
        diffs = []
        for i in range(1, len(prices)):
            diffs.append(prices[i] - prices[i-1])

        if len(diffs) < 2:
            return self.default_volatility_cents

        # ──── Step 2: 基础绝对波动率 = 绝对价差的样本标准差 ────
        mean_diff = sum(diffs) / len(diffs)
        variance = sum((d - mean_diff) ** 2 for d in diffs) / (len(diffs) - 1)
        base_sigma = math.sqrt(variance)

        # ──── Step 3: 伯努利方差衰减约束 ────
        # 理论最大方差在 50 美分处 (p=0.5)
        # 越靠近 0 或 100，概率确定性越高，波动率应被压缩
        # 归一化因子: 50 × 50 = 2500
        p = current_price_cents if current_price_cents else prices[-1]
        p = max(1, min(99, p))  # 边界保护
        bernoulli_weight = (p * (100 - p)) / 2500.0
        # P=50 → W=1.0, P=10 → W=0.36, P=5 → W=0.19, P=1 → W=0.04

        # 将基础波动率按理论不确定性进行缩放
        adjusted_sigma = base_sigma * math.sqrt(bernoulli_weight)

        # ──── Step 4: 边界保护 ────
        # 下限 1 美分: 即使完全无波动，也保证 A-S 有最小调整能力
        # 上限 15 美分: 防止异常噪音数据导致 σ² 过大 (15²=225)
        return max(1.0, min(15.0, adjusted_sigma))
```

---

## 十一、完整业务流程

### 11.1 冷启动完整流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      冷启动完整流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  T=0: 创建市场                                                   │
│  ════════════════                                               │
│  管理员创建市场 "美联储2025年6月降息"                            │
│  市场状态: OPEN                                                  │
│  订单簿: 空                                                      │
│  用户体验: 无法交易                                              │
│                                                                 │
│  T=1: 启动 AMM                                                   │
│  ════════════════                                               │
│  管理员调用:                                                     │
│  POST /api/admin/amm/start                                      │
│  {                                                              │
│    "marketId": "...",                                           │
│    "initialFunding": 100000,         // $1000（美分）           │
│    "initialProbability": 0.50,                                  │
│    "spread": 2,                      // 2 美分 (2%)             │
│    "autoReinvest": true              // ⭐ v3.0                  │
│  }                                                              │
│                                                                 │
│  AMM 执行:                                                       │
│  1. 从管理员账户扣除 $1000                                       │
│  2. 铸造 1000 Yes + 1000 No                                     │
│  3. 计算初始价格: Yes=50%, No=50%                               │
│  4. 挂单:                                                       │
│     Sell Yes @ 0.51, 0.52, 0.53, 0.54, 0.55 (各100份)           │
│     Sell No  @ 0.51, 0.52, 0.53, 0.54, 0.55 (各100份)           │
│                                                                 │
│  订单簿状态:                                                     │
│    YES: 买方空，卖方有 AMM 的 500 份                             │
│    NO:  买方空，卖方有 AMM 的 500 份                             │
│                                                                 │
│  T=2: 用户开始交易                                               │
│  ════════════════════                                           │
│  用户A: 买入 50 份 Yes @ 0.51                                    │
│    → 与 AMM 的 Sell Yes @ 0.51 成交                             │
│    → AMM 收到 $25.5, 失去 50 Yes                                │
│    → AMM 使用原子改单重新调整挂单                               │
│                                                                 │
│  用户B: 买入 100 份 No @ 0.51                                    │
│    → 与 AMM 的 Sell No @ 0.51 成交                              │
│    → AMM 收到 $51, 失去 100 No                                  │
│    → AMM 使用原子改单重新调整挂单                               │
│                                                                 │
│  T=3: 自然用户出现                                               │
│  ════════════════════                                           │
│  用户C: 认为 Yes 被高估，想卖出                                  │
│    → 挂单 Sell Yes @ 0.48                                       │
│    → 这个价格比 AMM 更优                                        │
│                                                                 │
│  用户D: 想买 Yes                                                 │
│    → 发现用户C的 0.48 比 AMM 的 0.51 便宜                        │
│    → 与用户C成交                                                 │
│    → AMM 的单没被吃到                                            │
│                                                                 │
│  市场开始有自然流动性！                                          │
│                                                                 │
│  T=4: 自动复投触发 (v3.0)                                        │
│  ════════════════════════                                       │
│  AMM 状态: Y=200, N=600, Cash=7000000 ($700)                    │
│  检测: Cash > $500 且 Y < 初始20%                               │
│  → 触发自动复投                                                  │
│  → 铸造 700 份 Yes + 700 份 No                                  │
│  复投后: Y=900, N=1300, Cash=0                                  │
│  AMM 继续永续做市！                                              │
│                                                                 │
│  T=5: 市场成熟                                                   │
│  ════════════════                                               │
│  订单簿深度增加，自然用户的报价经常比 AMM 更优                   │
│  AMM 成交量占比下降到 < 10%                                      │
│                                                                 │
│  管理员监控发现:                                                 │
│    AMM 交易占比 < 5%                                            │
│    市场自然深度充足                                              │
│                                                                 │
│  决定: 关闭 AMM，回收资金                                        │
│                                                                 │
│  T=6: 关闭 AMM                                                   │
│  ════════════════                                               │
│  管理员调用:                                                     │
│  POST /api/admin/amm/stop { "mode": "HARD" }                    │
│                                                                 │
│  AMM 执行:                                                       │
│  1. 撤销所有挂单                                                 │
│  2. 当前库存: 800 Yes + 1200 No                                 │
│  3. Merge: 销毁 800 对 → 回收 $800                              │
│  4. 剩余: 0 Yes + 400 No                                        │
│  5. 挂单卖出 400 No @ 市场价                                     │
│  6. 资金返还管理员账户                                           │
│                                                                 │
│  结果:                                                          │
│  初始投入: $1000                                                │
│  回收资金: ~$920 (假设 No 以 0.45 卖出)                          │
│  AMM 成本: $80 (为市场提供流动性的代价)                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 11.2 动态再平衡时序图（v3.0 优化）

```
┌─────────────────────────────────────────────────────────────────┐
│                  动态再平衡时序 (v3.0 优化)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    用户        撮合引擎         Kafka        AMM服务             │
│     │             │               │             │               │
│     │ Buy Yes @0.51              │             │               │
│     │──────────────▶│             │             │               │
│     │             │               │             │               │
│     │             │ Match with    │             │               │
│     │             │ AMM's order   │             │               │
│     │             │               │             │               │
│     │             │ TradeEvent    │             │               │
│     │             │───────────────▶│             │               │
│     │             │               │             │               │
│     │             │               │ TradeEvent  │               │
│     │             │               │─────────────▶│               │
│     │             │               │             │               │
│     │             │               │   (Filter:  │               │
│     │             │               │   maker=AMM)│               │
│     │             │               │             │               │
│     │             │               │    ┌────────┴─────┐         │
│     │             │               │    │Update Y,N    │         │
│     │             │               │    │(Redis)       │         │
│     │             │               │    │Recalc price  │         │
│     │             │               │    │Gen new orders│         │
│     │             │               │    │Check reinvest│ ⭐v3.0  │
│     │             │               │    └────────┬─────┘         │
│     │             │               │             │               │
│     │             │   Atomic Replace (v3.0)     │               │
│     │             │◀────────────────────────────│               │
│     │             │               │             │               │
│     │             │ Order confirmed             │               │
│     │◀────────────│               │             │               │
│     │             │               │             │               │
│                                                                 │
│  延迟要求: 从 TradeEvent 到新挂单完成 < 100ms                    │
│  v3.0 改进: 使用原子改单确保状态一致性                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 十二、数据结构设计（v4.0 增强）

### 12.1 v4.0 完整配置结构

```python
@dataclass
class AMMConfigV6:
    """AMM 配置结构 v6.0 (基于 v4.0 升级计划)"""

    # ═══════════════════════════════════════════════════
    # 基础配置 (保留)
    # ═══════════════════════════════════════════════════
    market_id: str                        # 市场 ID
    amm_user_id: str                      # AMM 用户 ID
    initial_funding_cents: int            # 初始资金（美分）

    # ═══════════════════════════════════════════════════
    # 三层定价配置 (v4.0 新增)
    # ═══════════════════════════════════════════════════
    pricing_config: ThreeLayerPricingConfig = field(
        default_factory=ThreeLayerPricingConfig
    )

    # ═══════════════════════════════════════════════════
    # 两阶段策略配置 (v4.0 新增)
    # ═══════════════════════════════════════════════════
    exploration_config: ExplorationConfig = field(
        default_factory=ExplorationConfig
    )
    stabilization_config: StabilizationConfig = field(
        default_factory=StabilizationConfig
    )

    # ═══════════════════════════════════════════════════
    # Avellaneda-Stoikov 配置 (v4.0 新增)
    # ═══════════════════════════════════════════════════
    as_config: ASConfig = field(
        default_factory=ASConfig
    )

    # ═══════════════════════════════════════════════════
    # 挂单梯度配置 (v4.0 重构)
    # ═══════════════════════════════════════════════════
    gradient_config: GradientConfig = field(
        default_factory=GradientConfig
    )

    # ═══════════════════════════════════════════════════
    # 全栈风控配置 (v4.0 重构)
    # ═══════════════════════════════════════════════════
    defense_config: DefenseStackConfig = field(
        default_factory=DefenseStackConfig
    )

    # ═══════════════════════════════════════════════════
    # 自动复投 (保留 v3.0)
    # ═══════════════════════════════════════════════════
    auto_reinvest_enabled: bool = True
    auto_reinvest_threshold_cents: int = 50000  # $500
    min_inventory_ratio: float = 0.20

    # ═══════════════════════════════════════════════════
    # Oracle Guard (保留 v3.2)
    # ═══════════════════════════════════════════════════
    oracle_guard_enabled: bool = True
    oracle_deviation_warning: float = 0.05   # 5%
    oracle_deviation_halt: float = 0.20      # 20%
```

### 12.2 AMM 配置表（数据库）

```sql
CREATE TABLE amm_config (
  id               SERIAL PRIMARY KEY,
  market_id        VARCHAR(64) NOT NULL UNIQUE,
  amm_user_id      VARCHAR(64) NOT NULL,
  status           VARCHAR(16) NOT NULL,    -- RUNNING/PAUSED/STOPPED

  -- 初始参数
  initial_funding  BIGINT NOT NULL,         -- 初始资金（美分）
  initial_prob     DECIMAL(5,4) NOT NULL,   -- 初始概率

  -- 策略参数
  spread           INT NOT NULL,            -- 点差（美分，如 2 = 2%）
  levels           INT NOT NULL,            -- 阶梯数
  qty_per_level    BIGINT NOT NULL,         -- 每档数量

  -- 风控参数
  max_exposure     DECIMAL(3,2) NOT NULL,   -- 最大敞口
  min_price        INT NOT NULL,            -- 最低价格（美分，1-99）
  max_price        INT NOT NULL,            -- 最高价格（美分，1-99）

  -- ⭐ v3.0 新增: 自动复投配置（v3.1 美分制）
  auto_reinvest_enabled    BOOLEAN DEFAULT true,
  auto_reinvest_threshold  BIGINT DEFAULT 50000,   -- 现金阈值（美分）
  min_inventory_ratio      DECIMAL(3,2) DEFAULT 0.20,

  -- 审计字段
  created_at       TIMESTAMP DEFAULT NOW(),
  updated_at       TIMESTAMP DEFAULT NOW(),
  created_by       VARCHAR(64) NOT NULL
);
```

### 12.3 AMM 库存表（Redis 主存储 + PostgreSQL 备份）

> ⚠️ **v3.2 更新**：与撮合引擎 v4.0 的 PositionRecord 部分对齐，新增 `cost_sum` 字段用于盈亏追踪。
> `pending_sell` 不单独存储，从 Order Manager 的活跃挂单实时计算。

**字段映射（与撮合引擎 PositionRecord 对齐）:**

| AMM 字段 | PositionRecord 字段 | 说明 |
|----------|-------------------|------|
| `yes_volume` | `yes_volume` | 持仓份数 |
| `no_volume` | `no_volume` | 持仓份数 |
| `yes_cost_sum` | `yes_cost_sum` | 累计成本（美分）⭐ v3.2 新增 |
| `no_cost_sum` | `no_cost_sum` | 累计成本（美分）⭐ v3.2 新增 |
| _(从挂单计算)_ | `yes_pending_sell` | 卖单冻结数量 |
| `cash_balance` | _(User.balance)_ | AMM 特有字段 |

**Redis 结构（主存储）:**

```
# Hash 结构存储实时库存
HSET amm:inventory:{market_id}
  yes_volume       1000                     # 对应 PositionRecord.yes_volume
  no_volume        1000                     # 对应 PositionRecord.no_volume
  yes_cost_sum     50000                    # ⭐ v3.2 新增: 累计成本（美分）
  no_cost_sum      50000                    # ⭐ v3.2 新增: 累计成本（美分）
  cash_balance     0
  updated_at       "2025-01-09T10:30:00Z"

# Hash 结构存储当前挂单
HSET amm:orders:{market_id}
  order_001        '{"side":"YES","price":51,"qty":100}'
  order_002        '{"side":"YES","price":52,"qty":100}'
  ...

# pending_sell 从 amm:orders 实时计算，不单独存储
# yes_pending_sell = sum(orders where side=YES and status=ACTIVE)
```

**PostgreSQL 结构（备份 + 审计）:**

```sql
CREATE TABLE amm_inventory (
  id               SERIAL PRIMARY KEY,
  market_id        VARCHAR(64) NOT NULL UNIQUE,

  -- 实时库存 (从 Redis 同步，对齐 PositionRecord)
  yes_volume       BIGINT NOT NULL,         -- Yes 库存（对应 PositionRecord.yes_volume）
  no_volume        BIGINT NOT NULL,         -- No 库存（对应 PositionRecord.no_volume）
  yes_cost_sum     BIGINT NOT NULL DEFAULT 0,  -- ⭐ v3.2 新增: Yes 累计成本（美分）
  no_cost_sum      BIGINT NOT NULL DEFAULT 0,  -- ⭐ v3.2 新增: No 累计成本（美分）
  cash_balance     BIGINT NOT NULL,         -- 现金余额（美分）

  -- 统计信息
  total_volume     BIGINT DEFAULT 0,        -- 累计成交量
  total_trades     INT DEFAULT 0,           -- 累计成交笔数

  -- ⭐ v3.0 新增: 自动复投统计
  total_minted     BIGINT DEFAULT 0,        -- 累计自动铸造数量
  last_mint_at     TIMESTAMP,               -- 最后一次复投时间

  -- ⭐ v3.2 新增: 手续费统计
  total_fees_paid  BIGINT DEFAULT 0,        -- 累计支付手续费（美分）

  -- 盈亏（可从 cost_sum 计算）
  realized_pnl     BIGINT DEFAULT 0,        -- 已实现盈亏

  updated_at       TIMESTAMP DEFAULT NOW()
);

-- 计算属性示例:
-- yes_avg_cost = yes_cost_sum / yes_volume（需要时计算）
-- unrealized_pnl = (yes_volume * current_yes_price + no_volume * current_no_price)
--                  - (yes_cost_sum + no_cost_sum)
```

### 12.4 AMM 挂单记录表

```sql
CREATE TABLE amm_orders (
  id               SERIAL PRIMARY KEY,
  market_id        VARCHAR(64) NOT NULL,
  order_id         VARCHAR(64) NOT NULL,    -- 核心系统的订单ID

  side             VARCHAR(4) NOT NULL,     -- YES/NO
  price            INT NOT NULL,            -- 价格（美分，1-99）
  quantity         BIGINT NOT NULL,         -- 数量
  filled_qty       BIGINT DEFAULT 0,        -- 已成交数量
  status           VARCHAR(16) NOT NULL,    -- ACTIVE/FILLED/CANCELLED/REPLACED

  -- ⭐ v3.0 新增: 改单追踪
  replaced_by      VARCHAR(64),             -- 被哪个订单替换
  replaces         VARCHAR(64),             -- 替换了哪个订单

  created_at       TIMESTAMP DEFAULT NOW(),
  updated_at       TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_amm_orders_market ON amm_orders(market_id, status);
```

### 12.5 AMM 成交记录表

```sql
CREATE TABLE amm_trades (
  id               SERIAL PRIMARY KEY,
  market_id        VARCHAR(64) NOT NULL,
  trade_id         VARCHAR(64) NOT NULL,    -- 核心系统的成交ID
  
  side             VARCHAR(4) NOT NULL,     -- YES/NO
  direction        VARCHAR(4) NOT NULL,     -- BUY/SELL (AMM视角)
  price            INT NOT NULL,
  quantity         BIGINT NOT NULL,
  
  -- 成交前后状态
  yes_before       BIGINT NOT NULL,
  yes_after        BIGINT NOT NULL,
  no_before        BIGINT NOT NULL,
  no_after         BIGINT NOT NULL,
  cash_before      BIGINT NOT NULL,         -- ⭐ v3.0 新增
  cash_after       BIGINT NOT NULL,         -- ⭐ v3.0 新增
  
  created_at       TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_amm_trades_market ON amm_trades(market_id, created_at);
```

### 12.6 自动复投记录表（v3.0 新增）

```sql
CREATE TABLE amm_reinvest_log (
  id               SERIAL PRIMARY KEY,
  market_id        VARCHAR(64) NOT NULL,
  
  -- 触发条件快照
  cash_before      BIGINT NOT NULL,         -- 复投前现金
  yes_before       BIGINT NOT NULL,         -- 复投前 Yes 库存
  no_before        BIGINT NOT NULL,         -- 复投前 No 库存
  
  -- 执行结果
  mint_amount      BIGINT NOT NULL,         -- 铸造数量
  cash_after       BIGINT NOT NULL,         -- 复投后现金
  yes_after        BIGINT NOT NULL,         -- 复投后 Yes 库存
  no_after         BIGINT NOT NULL,         -- 复投后 No 库存
  
  -- 触发原因
  trigger_reason   VARCHAR(64) NOT NULL,    -- LOW_YES / LOW_NO / BOTH
  
  created_at       TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_amm_reinvest_market ON amm_reinvest_log(market_id, created_at);
```

### 12.7 cost_sum 维护逻辑（v3.2 新增）

> ⚠️ **v3.2 新增**：与撮合引擎 v4.0 对齐，使用 `cost_sum`（累计成本）而非 `avg_cost`（平均成本），
> 避免整数除法精度丢失。

```python
class AMMInventoryManager:
    """
    AMM 库存管理器（v3.2 - 对齐 PositionRecord）

    维护 cost_sum 字段，用于准确计算盈亏
    """

    def on_mint(self, quantity: int):
        """
        铸造新合约（初始化或自动复投）

        每对合约成本 100 美分，50/50 分摊到 Yes 和 No
        """
        cost_per_pair = 100  # 美分
        cost_per_side = 50   # 每边 50 美分

        self.inventory.yes_volume += quantity
        self.inventory.no_volume += quantity
        self.inventory.yes_cost_sum += quantity * cost_per_side
        self.inventory.no_cost_sum += quantity * cost_per_side
        self.inventory.cash_balance -= quantity * cost_per_pair

    def on_sell_filled(self, side: str, quantity: int, price: int, fee: int):
        """
        AMM 卖出成交（用户买入 AMM 的挂单）

        Args:
            side: YES 或 NO
            quantity: 成交数量
            price: 成交价格（美分）
            fee: Maker Fee（美分）
        """
        if side == "YES":
            # 按比例减少成本（避免除法精度丢失）
            if self.inventory.yes_volume > 0:
                # cost_to_remove = cost_sum * quantity / volume
                cost_to_remove = (self.inventory.yes_cost_sum * quantity
                                  // self.inventory.yes_volume)
            else:
                cost_to_remove = 0

            self.inventory.yes_volume -= quantity
            self.inventory.yes_cost_sum -= cost_to_remove

            # 收入 = 成交金额 - 手续费
            revenue = quantity * price - fee
            self.inventory.cash_balance += revenue

            # 计算已实现盈亏
            realized_pnl = revenue - cost_to_remove
            self.inventory.realized_pnl += realized_pnl

        elif side == "NO":
            # NO 同理
            if self.inventory.no_volume > 0:
                cost_to_remove = (self.inventory.no_cost_sum * quantity
                                  // self.inventory.no_volume)
            else:
                cost_to_remove = 0

            self.inventory.no_volume -= quantity
            self.inventory.no_cost_sum -= cost_to_remove

            revenue = quantity * price - fee
            self.inventory.cash_balance += revenue

            realized_pnl = revenue - cost_to_remove
            self.inventory.realized_pnl += realized_pnl

    def on_merge(self, quantity: int):
        """
        配对销毁（Merge）回收现金

        销毁等量的 Yes 和 No，回收 100 美分/对
        """
        if quantity > min(self.inventory.yes_volume, self.inventory.no_volume):
            raise ValueError("Insufficient inventory for merge")

        # 按比例减少成本
        yes_cost_remove = (self.inventory.yes_cost_sum * quantity
                          // self.inventory.yes_volume)
        no_cost_remove = (self.inventory.no_cost_sum * quantity
                         // self.inventory.no_volume)

        self.inventory.yes_volume -= quantity
        self.inventory.no_volume -= quantity
        self.inventory.yes_cost_sum -= yes_cost_remove
        self.inventory.no_cost_sum -= no_cost_remove

        # 回收现金
        cash_returned = quantity * 100  # 每对 100 美分
        self.inventory.cash_balance += cash_returned

        # Merge 的已实现盈亏
        cost_basis = yes_cost_remove + no_cost_remove
        realized_pnl = cash_returned - cost_basis
        self.inventory.realized_pnl += realized_pnl

    def get_pending_sell(self, side: str) -> int:
        """
        从 Order Manager 计算卖单冻结数量

        不单独存储，实时计算
        """
        active_orders = self.order_manager.get_active_orders(
            market_id=self.market_id,
            side=side,
            direction="SELL"
        )
        return sum(order.quantity - order.filled_qty for order in active_orders)

    def get_available_to_sell(self, side: str) -> int:
        """
        计算可用于挂卖单的数量

        可用 = 库存 - 已冻结
        """
        if side == "YES":
            return self.inventory.yes_volume - self.get_pending_sell("YES")
        else:
            return self.inventory.no_volume - self.get_pending_sell("NO")
```

---

## 十三、回测与模拟框架（v7.0 新增）

> ⚠️ **v7.0 新增**：在上线前，必须用历史数据或合成数据验证策略参数的合理性。
> 策略层的"纯逻辑无 I/O"设计（第 2.2 节）使得回测框架的构建非常自然。

### 13.1 回测架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    回测框架架构 (v7.0)                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Simulated Connector (模拟连接层)            │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • 替代真实 WebSocket/REST，输入预录数据                 │   │
│  │  • 模拟订单簿撮合逻辑 (简化版)                           │   │
│  │  • 模拟延迟、错误率                                      │   │
│  │  • 输出: MarketState 序列                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓ ↑                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Strategy Layer (策略层) ← 复用生产代码       │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • ThreeLayerPricing, PhaseManager, ASEngine 等          │   │
│  │  • 与生产环境完全相同的代码                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓ ↑                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Risk Middleware (风控层) ← 复用生产代码      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Metrics Collector (指标收集器)               │   │
│  │  ─────────────────────────────────────────────────────  │   │
│  │  • PnL 曲线 (累计盈亏)                                   │   │
│  │  • 库存偏斜度时序                                         │   │
│  │  • 点差/成交量/填充率统计                                 │   │
│  │  • 风控触发次数和原因分布                                 │   │
│  │  • 最大回撤 (Max Drawdown)                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 13.2 三种模拟场景

| 场景 | 数据特征 | 验证目标 |
|------|---------|----------|
| **平稳市场** | 价格在 40-60 区间随机游走，成交均匀 | 验证基础盈亏、点差收入是否覆盖成本 |
| **单边趋势** | 价格从 50 单向移动到 80+（或 20-） | 验证库存管理、A-S 偏斜、阶段回退是否有效 |
| **突发事件** | 价格在短时间内跳变 15-30%（如比赛入球） | 验证 Oracle Guard、VPIN、价格极值保护是否及时触发 |

### 13.3 模拟连接器实现

```python
class SimulatedConnector:
    """
    模拟连接层: 替代真实 API，用于回测

    输入: 预录的成交流 + 盘口快照序列
    输出: MarketState，供策略层消费
    """

    def __init__(self, trade_data: list, orderbook_snapshots: list):
        """
        Args:
            trade_data: [{'time_ms': int, 'price': int, 'qty': int, 'side': str}, ...]
            orderbook_snapshots: [{'time_ms': int, 'bids': [...], 'asks': [...]}, ...]
        """
        self.trade_data = sorted(trade_data, key=lambda x: x['time_ms'])
        self.orderbook_snapshots = sorted(orderbook_snapshots, key=lambda x: x['time_ms'])
        self.current_idx = 0
        self.amm_orders = {}        # 当前 AMM 挂单
        self.amm_fills = []         # AMM 成交记录

    def step(self, current_time_ms: int) -> dict:
        """
        前进一步，返回当前 MarketState

        模拟撮合: 如果 trade_data 中有价格穿越 AMM 挂单的成交，
        视为 AMM 被吃单
        """
        # 收集当前时间点的成交和盘口
        trades = self._get_trades_until(current_time_ms)
        orderbook = self._get_latest_orderbook(current_time_ms)

        # 模拟 AMM 挂单被吃
        fills = self._simulate_fills(trades)
        self.amm_fills.extend(fills)

        return {
            'time_ms': current_time_ms,
            'trades': trades,
            'orderbook': orderbook,
            'amm_fills': fills
        }

    def place_orders(self, orders: list):
        """接收策略层的挂单指令"""
        for order in orders:
            self.amm_orders[order['id']] = order

    def cancel_orders(self, order_ids: list):
        """接收策略层的撤单指令"""
        for oid in order_ids:
            self.amm_orders.pop(oid, None)

    def _simulate_fills(self, trades: list) -> list:
        """简化撮合: 价格穿越挂单即视为成交"""
        fills = []
        for trade in trades:
            for oid, order in list(self.amm_orders.items()):
                if order['side'] == 'SELL' and trade['price'] >= order['price']:
                    fill_qty = min(trade['qty'], order['qty'])
                    fills.append({
                        'order_id': oid,
                        'price': order['price'],
                        'qty': fill_qty,
                        'time_ms': trade['time_ms']
                    })
                    order['qty'] -= fill_qty
                    if order['qty'] <= 0:
                        del self.amm_orders[oid]
        return fills
```

### 13.4 回测指标定义

```python
class BacktestMetrics:
    """回测指标收集器"""

    def __init__(self):
        self.pnl_series = []           # [(time_ms, cumulative_pnl)]
        self.inventory_series = []     # [(time_ms, yes_inv, no_inv)]
        self.spread_series = []        # [(time_ms, effective_spread)]
        self.defense_triggers = []     # [(time_ms, action, reason)]

    def summary(self) -> dict:
        """生成回测摘要"""
        pnls = [p for _, p in self.pnl_series]
        return {
            'total_pnl': pnls[-1] if pnls else 0,
            'max_drawdown': self._max_drawdown(pnls),
            'sharpe_ratio': self._sharpe(pnls),
            'total_fills': len(self.pnl_series),
            'avg_spread': sum(s for _, s in self.spread_series) /
                          len(self.spread_series) if self.spread_series else 0,
            'defense_triggers': len(self.defense_triggers),
            'defense_breakdown': self._defense_breakdown()
        }

    def _max_drawdown(self, pnls: list) -> int:
        """最大回撤"""
        if not pnls:
            return 0
        peak = pnls[0]
        max_dd = 0
        for p in pnls:
            peak = max(peak, p)
            max_dd = min(max_dd, p - peak)
        return max_dd

    def _defense_breakdown(self) -> dict:
        """风控触发原因分布"""
        from collections import Counter
        return dict(Counter(r for _, _, r in self.defense_triggers))
```

### 13.5 回测流程

```
回测执行流程:

1. 准备数据
   ├── 合成数据生成器 (三种场景)
   └── 或导入历史成交数据

2. 初始化
   ├── SimulatedConnector (加载数据)
   ├── Strategy Layer (生产代码)
   ├── Risk Middleware (生产代码)
   └── BacktestMetrics (指标收集)

3. 主循环
   for each time_step in simulation_range:
     ├── market_state = connector.step(time_step)
     ├── orders = strategy.decide(market_state)
     ├── filtered = risk.check(orders)
     ├── connector.place_orders(filtered)
     └── metrics.record(market_state, filtered)

4. 输出报告
   ├── PnL 曲线图
   ├── 库存偏斜时序图
   ├── 风控触发热力图
   └── 参数敏感性分析表
```

### 13.6 参数敏感性分析建议

上线前应对以下参数进行网格搜索或随机搜索:

| 参数 | 搜索范围 | 影响 |
|------|---------|------|
| γ (风险厌恶) | 1.0 ~ 10.0 | 库存管理激进度 |
| base_learning_rate | 0.05 ~ 0.3 | 后验价格跟踪速度 |
| spread (收敛期) | 1 ~ 5 美分 | 盈亏 vs 成交量权衡 |
| qty_ratio (探索期) | 0.1 ~ 0.5 | 探索成本 vs 信息获取速度 |
| extreme_price_halt | 8 ~ 15 | 极值区保护激进度 |

---

## 十四、实施路径（v7.0 更新）

### 14.1 分阶段实施

```
┌─────────────────────────────────────────────────────────────────┐
│                     实施路径 (v7.0 更新)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段1: 基础框架 (1-2周)                                        │
│  ════════════════════════                                       │
│  • 创建 AMM 用户账户体系                                         │
│  • 实现 CPMM 参考定价 + SafeMath 库 ⭐ v3.0                     │
│  • 实现 A-S 主定价引擎 + 三层定价体系 ⭐ v7.0                    │
│  • 实现基础的下单/撤单 API 对接                                  │
│  • 手动触发测试                                                  │
│                                                                 │
│  阶段2: 事件驱动 + API协议升级 (1-2周)                          │
│  ════════════════════════════════════                           │
│  • 接入 Kafka/Redis 事件流                                      │
│  • 实现 Market Listener                                         │
│  • 实现自动再平衡逻辑                                            │
│  • ⭐ v3.0: 撮合引擎增加原子改单接口支持                         │
│  • ⭐ v3.0: Order Manager 对接原子改单 API                       │
│  • 集成测试                                                      │
│                                                                 │
│  阶段3: 存储架构升级 + 自动复投 (1周)                            │
│  ════════════════════════════════════                           │
│  • ⭐ v3.0: Redis 作为主存储，PostgreSQL 异步备份                │
│  • ⭐ v3.0: 实现 Auto-Reinvest 自动复投逻辑                      │
│  • ⭐ v3.0: 复投触发条件和阈值配置                               │
│  • 集成测试永续做市场景                                          │
│                                                                 │
│  阶段4: 管理后台 (1周)                                          │
│  ════════════════════                                           │
│  • 实现管理员控制 API                                            │
│  • 开发监控面板                                                  │
│  • 实现启用/停止/参数调整功能                                    │
│  • ⭐ v3.0: 自动复投状态监控面板                                 │
│                                                                 │
│  阶段5: 风控完善 (1周)                                          │
│  ════════════════════                                           │
│  • 实现敞口监控                                                  │
│  • 实现自动告警                                                  │
│  • 实现价格边界保护                                              │
│  • 实现延迟保护                                                  │
│  • 实现 Oracle Guard 预言机保护                                  │
│                                                                 │
│  阶段6: 回测验证 (1周) ⭐ v7.0 新增                              │
│  ════════════════════════════════                                │
│  • 构建 SimulatedConnector 模拟连接层                            │
│  • 实现三种场景数据生成器 (平稳/趋势/突发)                       │
│  • 执行参数敏感性分析 (γ, α, spread, qty)                       │
│  • 生成回测报告，确认 PnL 和风控行为符合预期                     │
│                                                                 │
│  阶段7: 生产加固 (1周)                                          │
│  ════════════════════                                           │
│  • 性能优化（延迟 < 100ms）                                      │
│  • 异常恢复测试                                                  │
│  • 压力测试                                                      │
│  • ⭐ v3.0: 原子改单并发测试                                     │
│  • 灰度发布                                                      │
│                                                                 │
│  总计: 7-10 周                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 14.2 技术选型建议

| 组件 | 推荐技术 | 理由 |
|------|----------|------|
| AMM 服务 | Python (FastAPI) 或 Go | 快速开发，性能足够 |
| 事件订阅 | Kafka / Redis Streams | 可靠的事件流 |
| 库存存储 | **Redis (主)** + PostgreSQL (备) | ⭐ v3.0: 毫秒级读写 + 可靠性 |
| 监控 | Prometheus + Grafana | 行业标准 |
| 告警 | PagerDuty / Slack | 及时响应 |

---

## 附录A：整数化 CPMM 实现（v3.1 美分制）

### A.1 为什么不能用 LMSR

```
LMSR 公式涉及:
  e^(q/b)  →  指数运算
  ln(x)    →  对数运算

问题:
  1. 无法用整数精确表示 e 和 ln 的结果
  2. 需要高精度浮点运算，与"全链路整数化"冲突
  3. 计算开销大，不适合高频交易场景

结论: LMSR 在我们的架构中不可行
```

### A.2 CPMM 整数化实现（v3.1 美分制）

```
┌─────────────────────────────────────────────────────────────────┐
│                 CPMM 整数化实现 (v3.1 美分制)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  存储单位: 美分 (Cents) - 对齐撮合引擎 v4.0                      │
│  ──────────────────────────────────────────────                 │
│  100 美分 = 100% = $1.00                                        │
│  50  美分 = 50%  = $0.50                                        │
│  价格范围: 1-99 美分                                             │
│                                                                 │
│  库存存储:                                                       │
│  ──────────                                                     │
│  Y: int64  // Yes 库存（份数）                                   │
│  N: int64  // No 库存（份数）                                    │
│                                                                 │
│  价格计算（整数版，美分）:                                        │
│  ────────────────────────                                       │
│  Fair_Yes = N * 100 / (Y + N)   // 公允价格，向下取整            │
│  Fair_No  = Y * 100 / (Y + N)   // 公允价格，向下取整            │
│                                                                 │
│  ⭐ v3.0 保留: 卖价向上取整                                      │
│  ──────────────────────────                                     │
│  Ask_Yes = ceil_div(N * (100 + spread/2), (Y + N))              │
│  Ask_No  = ceil_div(Y * (100 + spread/2), (Y + N))              │
│                                                                 │
│  示例:                                                          │
│  ──────                                                         │
│  Y = 400, N = 600                                               │
│  Fair_Yes = 600 * 100 / (400 + 600)                             │
│           = 60000 / 1000                                        │
│           = 60 美分 (60%)                                       │
│                                                                 │
│  Fair_No  = 400 * 100 / (400 + 600)                             │
│           = 40000 / 1000                                        │
│           = 40 美分 (40%)                                       │
│                                                                 │
│  验证: 60 + 40 = 100  ✓                                         │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  注意事项:                                                       │
│  ──────────                                                     │
│  1. 先乘后除，避免精度丢失                                       │
│     正确: N * 100 / (Y + N)                                     │
│     错误: N / (Y + N) * 100  // 整数除法会丢失精度               │
│                                                                 │
│  2. 使用 int64 防止溢出                                          │
│     如果 N = 1,000,000，则 N * 100 = 100,000,000                 │
│     int32 范围足够，但建议统一用 int64                           │
│                                                                 │
│  3. ⭐ v3.0 保留: 卖价向上取整，买价向下取整                      │
│     作为做市商，这是保护自己的基本原则                           │
│                                                                 │
│  4. ⭐ v3.1: 价格必须在 1-99 范围内                              │
│     计算结果需要 clamp 到有效范围                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### A.3 交易成本的整数化计算（v3.1 美分制）

```python
def calculate_buy_cost(Y: int, N: int, delta: int) -> int:
    """
    计算买入 delta 份 Yes 的成本（美分）

    使用恒定乘积公式: (Y - delta) * N' = Y * N
    解出 N' = Y * N / (Y - delta)
    成本 = N' - N
    """
    if delta >= Y:
        return -1  # 库存不足

    K = Y * N  # 恒定乘积
    new_Y = Y - delta
    new_N = K // new_Y  # 整数除法，向下取整

    # 成本 = 需要增加的 N（或等值现金）
    cost = new_N - N

    # 转换为美分（每份合约 100 美分 = $1）
    cost_in_cents = cost * 100

    return cost_in_cents

# 示例
Y, N = 1000, 1000
delta = 100
cost = calculate_buy_cost(Y, N, delta)
# K = 1,000,000
# new_Y = 900
# new_N = 1,000,000 // 900 = 1111
# cost = 1111 - 1000 = 111 份 No
# cost_in_cents = 111 * 100 = 11100 美分 = $111
# 平均价格 = 11100 / 100 = 111 美分/份 (约 $0.56 每份)
```

---

## 附录B：伪代码实现

### B.1 策略引擎核心逻辑（v3.1 美分制）

```python
class AMMStrategyEngine:

    def __init__(self, config: AMMConfig, redis_client: Redis):
        self.config = config
        self.redis = redis_client  # ⭐ v3.0: 必须从 Redis 读取
        self.safe_math = SafeMath()

    def get_inventory_from_redis(self) -> Inventory:
        """⭐ v3.0: 从 Redis 获取实时库存"""
        data = self.redis.hgetall(f"amm:inventory:{self.config.market_id}")
        return Inventory(
            yes=int(data['yes_inventory']),
            no=int(data['no_inventory']),
            cash=int(data['cash_balance'])  # 美分
        )

    def calculate_fair_price(self, inventory: Inventory) -> tuple[int, int]:
        """计算公允价格（美分，范围 1-99）"""
        Y = inventory.yes
        N = inventory.no
        total = Y + N

        if total == 0:
            return 50, 50  # 默认 50 美分

        price_yes = N * 100 // total  # 向下取整
        price_no = Y * 100 // total   # 向下取整

        return price_yes, price_no

    def generate_orders(self) -> list[Order]:
        """生成目标挂单"""
        inventory = self.get_inventory_from_redis()
        orders = []

        price_yes, price_no = self.calculate_fair_price(inventory)
        spread = self.config.spread  # 美分

        # 检查风控
        exposure = self.calculate_exposure(inventory)
        if exposure > self.config.max_exposure:
            # 只在强势方挂单
            pass

        # 生成 Sell Yes 阶梯挂单
        for i in range(self.config.levels):
            # ⭐ v3.0: 使用向上取整计算卖价
            ask_price = self.safe_math.calculate_ask_price(
                inventory.yes,
                inventory.no,
                spread + i * 1  # 每档增加 1 美分 (1%)
            )
            ask_price = min(ask_price, self.config.max_price)  # max_price 美分

            if inventory.yes > 0:
                orders.append(Order(
                    side="YES",
                    direction="SELL",
                    price=ask_price,  # 美分
                    quantity=self.config.qty_per_level
                ))

        # 生成 Sell No 阶梯挂单 (类似逻辑)
        for i in range(self.config.levels):
            ask_price = self.safe_math.calculate_ask_price(
                inventory.no,
                inventory.yes,
                spread + i * 1
            )
            ask_price = min(ask_price, self.config.max_price)

            if inventory.no > 0:
                orders.append(Order(
                    side="NO",
                    direction="SELL",
                    price=ask_price,  # 美分
                    quantity=self.config.qty_per_level
                ))

        return orders

    def calculate_exposure(self, inventory: Inventory) -> float:
        """计算敞口"""
        Y = inventory.yes
        N = inventory.no
        total = Y + N

        if total == 0:
            return 0

        return abs(Y - N) / total

    def on_trade(self, trade: Trade):
        """处理成交事件"""
        # 更新 Redis 库存
        self.update_inventory_in_redis(trade)

        # 检查是否需要自动复投
        self.check_and_auto_reinvest()

        # 触发重新挂单
        self.rebalance()

    def check_and_auto_reinvest(self):
        """⭐ v3.0: 检查并执行自动复投（v3.1 美分制）"""
        if not self.config.auto_reinvest_enabled:
            return

        inventory = self.get_inventory_from_redis()

        # 条件1: 现金充足（美分）
        if inventory.cash < self.config.auto_reinvest_threshold:
            return

        # 条件2: 库存不足
        initial = self.config.initial_inventory
        min_level = int(initial * self.config.min_inventory_ratio)

        if inventory.yes >= min_level and inventory.no >= min_level:
            return
        
        # 计算铸造数量（每对合约 100 美分）
        max_from_cash = inventory.cash // 100
        need_to_replenish = initial - min(inventory.yes, inventory.no)
        mint_amount = min(max_from_cash, need_to_replenish)
        
        if mint_amount > 0:
            self.trigger_mint(mint_amount)
            logger.info(f"Auto-reinvest: minted {mint_amount} pairs")
    
    def rebalance(self):
        """重新平衡挂单"""
        target_orders = self.generate_orders()
        current_orders = self.get_current_orders_from_redis()
        
        # 计算差量
        to_replace = self.diff_orders(current_orders, target_orders)
        
        # ⭐ v3.0: 使用原子改单
        for old_order, new_order in to_replace:
            self.order_manager.atomic_replace(old_order.id, new_order)
```

---

## 附录C：版本历史

| 版本 | 日期 | 主要变更 |
|------|------|----------|
| v1.0 | 2025-01 | 初始版本，内部路径架构，使用LMSR |
| v2.0 | 2025-01 | 重构为独立服务架构，AMM作为"机器人用户" |
| v2.1 | 2025-01 | 强化CPMM选型论证（排除LMSR），增加单边挂单策略，新增LVR风险和预言机保护机制 |
| **v3.0** | **2025-01** | **⭐ 重大改进：** |
| | | 1. 新增原子化改单接口 (Atomic Replace)，解决竞态条件 |
| | | 2. 新增库存自动回充机制 (Auto-Reinvest)，实现永续做市 |
| | | 3. 价格计算引入向上取整 (Ceiling)，保护做市商利益 |
| | | 4. 架构调整：Redis 作为主存储，Strategy Engine 必须从 Redis 读取 |
| | | 5. 新增 SafeMath 库封装，专门处理价格计算的取整逻辑 |
| | | 6. 新增自动复投记录表，支持复投审计追踪 |
| **v3.1** | **2025-01-16** | **⭐ 价格单位对齐：** |
| | | 1. 全面采用美分制 (1-99)，与撮合引擎 v4.0 对齐 |
| | | 2. 废弃基点制 (1-10000)，简化计算逻辑 |
| | | 3. 更新所有 API 接口、数据结构、伪代码的价格字段说明 |
| | | 4. 更新依赖文档版本：v2.0 → v4.0 |
| **v3.2** | **2025-01-17** | **⭐ 系统对齐与完善：** |
| | | 1. 新增 5.4 节"手续费处理机制"：AMM 始终是 Maker，正常支付 Maker Fee |
| | | 2. 库存数据结构与 PositionRecord 部分对齐，引入 `cost_sum` 字段 |
| | | 3. 新增 9.6 节 `cost_sum` 维护逻辑代码 |
| | | 4. 修复遗留的基点制表述（账户模型、示例数据） |
| | | 5. 新增 AMMFeeTracker 手续费追踪代码 |
| **v6.0** | **2026-02-03** | **⭐ v4.0 升级计划实施：** |
| | | 1. **三层定价体系**：外部锚定价 + 簿内微观价 + 后验学习价 |
| | | 2. **探索—收敛两阶段策略**：宽点差探索期 → 窄点差收敛期 |
| | | 3. **Avellaneda-Stoikov 模型**：`r = s - q·γ·σ²·(T-l)` 含时间因子 |
| | | 4. **非对称梯度 (Skewing)**：库存驱动的点差/数量调整 |
| | | 5. **挂单梯度重构**：线性梯度(探索期) + 几何梯度(收敛期) |
| | | 6. **全栈三道防线风控**：预算熔断 + 库存阈值 + 微观结构防护(VPIN) |
| | | 7. **架构升级**：三层模块架构 (Connector/Strategy/Risk Middleware) |
| | | 8. **配置结构重构**：`AMMConfigV6` 整合所有 v4.0 组件配置 |
| **v7.0** | **2026-02-25** | **⭐ 评审改进：** |
| | | 1. **定价主线明确**：A-S + 三层定价为主引擎，CPMM 降级为辅助参考工具 |
| | | 2. **A-S γ 参数重标定**：从 0.5 提升到 3.0，新增最小调整量保护 |
| | | 3. **自适应学习率**：后验价格 α 从固定 0.1 改为 `base_α / sqrt(trades/min + 1)` |
| | | 4. **微观价格循环引用修复**：冷启动阶段禁用 Layer 2，需非 AMM 深度达标才激活 |
| | | 5. **阶段回退机制**：收敛期可回退到紧急探索期（波动 > 10% 或亏损 > 50%预算） |
| | | 6. **价格极值保护**：价格 ≤ 5/≥ 95 停止做市，≤ 10/≥ 90 扩大点差 |
| | | 7. **自动复投改进**：库存失衡 > 60% 时跳过铸造，避免加剧失衡 |
| | | 8. **波动率 σ 计算方法**：新增 VolatilityEstimator（v7.1 已重写为 APV-BVD 模型） |
| | | 9. **回测框架**：新增第十三章，含 SimulatedConnector、三种场景、指标收集器 |
| | | 10. **手续费追踪精度修复**：avg_fee_per_trade 改用浮点数 |
| **v7.1** | **2026-02-25** | **⭐ 漏洞修复与对抗性增强：** |
| | | 1. **🔴 σ 量纲重构**：从无量纲 log-returns 改为绝对美分 + 伯努利方差衰减 `W=P(100-P)/2500`，消除价格边界处 σ 爆炸问题 |
| | | 2. **🔴 LVR 四层防御**：新增 10.7 节，含库存流失速率锁 (500ms/20%)、事件前护盾、成交后延迟重挂 (2.5s)、可选影子预言机 |
| | | 3. **🟠 反 Spoofing 微观价格**：Layer 2 微观价格增加指数衰减权重 + Top 3 档位过滤，防御虚假挂单操纵 |
| | | 4. **🟠 自动复投重构**：Auto-Merge 优先销毁配对回收现金，铸造条件极严（双边耗尽 + 失衡 < 30%） |
| | | 5. **🟡 时间因子重构**：`(T-l)` 归一化替换为 `τ(h)=h/(h+κ)` 双曲衰减，κ=24h；γ 按市场生命周期三档配置 |
| | | 6. **🟡 原子改单部分成交**：Replace API 新增 `PARTIALLY_FILLED` 响应码；AMM OrderManager 增加 fallback（同步库存→重新计算→独立下单） |
| | | 7. **🟡 ONE_SIDE 折价抛售**：库存 ≥ 80% 时不再只是宽点差，而是根据超出比例线性折价（最大 5 美分），主动甩货 |

---

## 附录D：核心公式汇总 (v7.1 更新)

| 组件 | 公式 | 说明 |
|------|------|------|
| 保留价格 | `r = s - q·γ·σ²·τ(h)` | v7.1: A-S 核心，时间因子改为绝对小时 |
| 时间因子 | `τ(h) = h / (h + κ)` | v7.1: κ=24h，双曲衰减替代归一化 (T-l) |
| γ 分档 | 短期 2.5 / 中期 1.5 / 长期 0.8 | v7.1: 按市场生命周期分三档 |
| 最小调整量 | `min_adj = 1 美分 (当 \|q\| > 0.1)` | v7.0: 防止 σ² 过小导致调整为零 |
| 库存偏斜 | `q = (Y - N) / (Y + N)` | 范围 [-1, 1] |
| 微观价格 | `P_micro = Σ(w_i·V_b_i·P_a_i + w_i·V_a_i·P_b_i) / Σ(w_i·(V_b_i+V_a_i))` | v7.1: Top 3 档位 + 指数衰减权重 |
| 后验学习 | `P_post(t) = P_post(t-1) + α·(P_trade - P_post)` | 成交驱动更新 |
| 自适应学习率 | `α = base_α / sqrt(trades_per_min + 1)` | v7.0: 替代固定 α=0.1 |
| 伯努利波动率 | `σ = max(1, σ_base × √(P(100-P)/2500))` | v7.1: 美分单位，边界自动衰减 |
| LVR 速率锁 | `KILL if filled_pct > 20% in 500ms 单方向` | v7.1: 无预言机替代方案 |
| 折价抛售 | `discount = (ratio-0.8)/(0.9-0.8) × 5 美分` | v7.1: ONE_SIDE 线性折价 |
| 线性梯度 | `P_i = P_base + i × ΔP` | 探索期，如 ±1, ±2, ±3... |
| 几何梯度 | `P_i = P_base × r^i` | 收敛期，r ≈ 1.05 |
| VPIN | `VPIN = \|sell_ratio - 0.5\| × 2` | 逆向选择检测 |
| 锚定衰减 | `w_anchor = w₀ × max(0, 1 - t/τ)` | 时间衰减权重 |

---

**文档结束**
