# 预测市场平台 — 完整实施计划

> **目标读者**: 独立开发者，借助 AI Vibe Coding 逐步实现
> **覆盖范围**: MVP → 中期 → 生产就绪，共 3 个阶段
> **日期**: 2026-02-20

---

## 一、总体阶段划分

| 阶段 | 核心目标 | 预计周期 | 服务形态 | 关键技术 |
|------|----------|----------|----------|----------|
| **Phase 1 — MVP** | 验证核心交易链路：下单→风控→撮合→清算→记账 | 8–12 周 | Java 单体（模块化） | Spring Boot, PostgreSQL, Redis, Disruptor(简化) |
| **Phase 2 — 中期** | 微服务拆分 + 市场管理 + 行情 + 预言机 + 监控 | 10–16 周 | Java + Python 微服务 | Kafka, Consul, TimescaleDB, WebSocket, Prometheus |
| **Phase 3 — 生产就绪** | 高可用、分片、合规审计、CEP 风控、自动裁决 | 12–20 周 | 完整分布式系统 | ShardingSphere, Drools, Flink, Temporal, ClickHouse |

---

## 二、Phase 1 — MVP 详细计划

### 2.1 MVP 包含的功能范围

**包含：**
- 用户账户：注册/登录（JWT）、充值/提现（模拟）、余额查询
- 市场：静态配置文件定义市场（暂不需要独立服务）
- 下单：限价单（GTC/IOC），买入YES/NO合约
- 风控：余额检查、单笔限额、持仓限额（硬编码规则）
- 撮合：单线程限价订单簿（LOB），YES/NO 独立撮合
- 清算：成交后资金划转、手续费扣除、持仓更新
- 查询：订单历史、持仓、账户流水

**不包含（推迟到中期/完备）：**
- 市场生命周期管理（创建、暂停、结算）
- 预言机裁决
- 实时行情推送（K线、深度图）
- 通知系统
- 合成撮合（YES+NO 对冲）
- 分布式消息队列（Kafka）
- 服务发现、配置中心
- 监控、链路追踪

### 2.2 MVP 技术栈

| 层次 | 技术选择 | 说明 |
|------|----------|------|
| 语言 | Java 21 (Eclipse Temurin) | 核心交易链路 |
| 框架 | Spring Boot 3.2+ | 快速开发 |
| API | REST (Spring Web) + gRPC (内部) | 外部 REST，模块间 gRPC 或直接方法调用 |
| 数据库 | PostgreSQL 16 (单实例) | 主账本 |
| 缓存 | Redis 7 (单实例) | 余额缓存、分布式锁 |
| 构建 | Gradle (Kotlin DSL) 8.5+ | 多模块构建 |
| 测试 | JUnit 5 + Testcontainers | 单元 + 集成测试 |
| 容器 | Docker Compose | 本地开发环境 |

### 2.3 MVP 代码结构

```
prediction-market/
├── java-services/
│   ├── build.gradle.kts              # 根构建脚本
│   ├── settings.gradle.kts
│   ├── gradle/libs.versions.toml     # 版本目录
│   │
│   ├── pm-common/                    # 公共模块
│   │   ├── pm-common-core/           # 工具类、异常、常量
│   │   └── pm-common-proto/          # Protobuf 生成代码（预留）
│   │
│   ├── pm-gateway/                   # 简化网关
│   │   └── (JWT + 限流 + 路由)
│   │
│   └── pm-trading-core/              # 核心交易单体
│       └── src/main/java/com/predmarket/
│           ├── account/              # 账户模块
│           ├── order/                # 订单模块
│           ├── risk/                 # 风控模块
│           ├── matching/             # 撮合模块
│           ├── clearing/             # 清算模块
│           └── config/               # 市场配置
│
├── proto/                            # Protobuf 定义
├── infrastructure/docker/            # Docker Compose
├── scripts/                          # 辅助脚本
└── docs/                             # 文档
```

### 2.4 MVP 模块实现顺序与详细步骤

> 每个模块按以下标准流程实施，每一步都可以借助 AI 辅助完成。

---

#### 模块 0：项目脚手架与基础设施（第 1 周）

| 步骤 | 具体任务 | 产出物 | AI 辅助要点 |
|------|----------|--------|-------------|
| 0.1 | 初始化 Git 仓库 + Monorepo 结构 | 目录骨架, .gitignore, README | 让 AI 生成标准 Monorepo 结构 |
| 0.2 | 配置 Gradle 多模块构建 | build.gradle.kts, settings.gradle.kts, libs.versions.toml | 让 AI 配置版本目录统一管理依赖 |
| 0.3 | 编写 Docker Compose | docker-compose.yml (PostgreSQL + Redis) | 让 AI 生成并解释每个配置项 |
| 0.4 | 编写数据库初始化脚本 | init-db.sql (所有核心表) | 参考架构文档 8.2 节的表设计 |
| 0.5 | 配置 CI 基础 | GitHub Actions / GitLab CI 配置 | 构建 + 测试自动化 |
| 0.6 | 编写 setup.sh | 一键启动开发环境 | 检查依赖 + 启动容器 + 初始化数据库 |

**验收标准**: `docker-compose up` 能启动 PG + Redis；Gradle 多模块编译通过。

---

#### 模块 1：pm-common 公共模块（第 1–2 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 1.1 文档 | 定义通用异常码、响应格式、常量 | docs/common-design.md |
| 1.2 代码 | 实现 Result\<T> 统一响应封装 | Result.java, ErrorCode.java |
| 1.3 代码 | 实现全局异常处理器 | GlobalExceptionHandler.java |
| 1.4 代码 | 实现通用工具类 | IdGenerator (Snowflake), DateUtils, DecimalUtils |
| 1.5 代码 | 定义 Protobuf 公共消息 | common.proto (ResultCode, Pagination) |
| 1.6 代码 | 实现 Redis 通用配置 | RedisConfig.java, RedisLockService.java |
| 1.7 测试 | 单元测试 | 每个工具类的测试 |

**验收标准**: `./gradlew :pm-common:test` 全部通过。

---

#### 模块 2：Account 账户模块（第 2–3 周）

这是整个系统的**资金基础**，风控和清算都依赖它。

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 2.1 文档 | 账户模块接口设计 | docs/account-api.md |
| 2.2 Proto | 定义 Account Protobuf | account.proto |
| 2.3 领域模型 | Account, Position, LedgerEntry 实体 | domain/model/*.java |
| 2.4 领域模型 | 账户状态枚举、入账类型枚举 | domain/enums/*.java |
| 2.5 数据库 | accounts, positions, ledger_entries 表 DDL | migration/V1__account.sql |
| 2.6 仓储层 | AccountRepository, PositionRepository 接口 + JPA 实现 | domain/repository/ + infrastructure/persistence/ |
| 2.7 核心逻辑 | 充值/提现、余额冻结/解冻、持仓更新 | domain/service/AccountDomainService.java |
| 2.8 Redis 缓存 | 余额快速查询缓存 + Lua 原子冻结脚本 | infrastructure/cache/BalanceCacheService.java |
| 2.9 应用层 | AccountService (对外暴露的业务方法) | application/AccountAppService.java |
| 2.10 REST API | 余额查询、充值、提现、持仓查询 | api/rest/AccountController.java |
| 2.11 单元测试 | 余额冻结/解冻、乐观锁冲突、边界测试 | test/unit/AccountDomainServiceTest.java |
| 2.12 集成测试 | 数据库 CRUD + Redis 缓存一致性 | test/integration/AccountIntegrationTest.java |

**关键设计决策：**
- 使用乐观锁 (`version` 字段) 防止并发余额问题
- ledger_entries 表 **Append-Only**，永不修改/删除
- Redis Lua 脚本实现原子的冻结操作

**验收标准**: 能通过 API 充值→查余额→冻结→解冻→查流水，全流程跑通。

---

#### 模块 3：Market 市场配置（第 3 周）

MVP 阶段使用静态配置，不需要独立服务。

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 3.1 文档 | 市场数据模型定义 | docs/market-config.md |
| 3.2 代码 | Market 领域模型 (id, title, description, status, contractType, 价格精度等) | config/model/Market.java |
| 3.3 代码 | 市场配置 JSON 文件 | config/markets.json |
| 3.4 代码 | MarketConfigLoader (启动时加载 + 缓存) | config/MarketConfigService.java |
| 3.5 REST API | 市场列表查询、单个市场详情 | api/rest/MarketController.java |
| 3.6 测试 | 配置加载和查询测试 | test/MarketConfigTest.java |

**验收标准**: 启动后能查到预配置的市场列表，包含市场的状态、规则参数。

---

#### 模块 4：Order 订单模块（第 3–4 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 4.1 文档 | 订单接口设计 + 状态机定义 | docs/order-api.md |
| 4.2 Proto | 定义 Order Protobuf | order.proto |
| 4.3 领域模型 | Order, OrderId, OrderSide, OrderType, OrderStatus, TimeInForce | domain/model/*.java |
| 4.4 状态机 | 订单状态流转规则 (NEW→PENDING→PARTIAL→FILLED/CANCELLED) | domain/model/OrderStateMachine.java |
| 4.5 领域事件 | OrderPlaced, OrderCancelled, OrderFilled | domain/event/*.java |
| 4.6 数据库 | orders 表 DDL + 索引 | migration/V2__order.sql |
| 4.7 仓储层 | OrderRepository 接口 + JPA 实现 | domain/repository/ + infrastructure/ |
| 4.8 核心逻辑 | 下单校验、幂等性检查 (client_order_id)、取消订单 | domain/service/OrderDomainService.java |
| 4.9 应用层 | PlaceOrderCommand, CancelOrderCommand, OrderQueryService | application/*.java |
| 4.10 REST API | 下单、取消、查询订单、查询订单列表 | api/rest/OrderController.java |
| 4.11 单元测试 | 状态机流转、幂等校验、边界条件 | test/unit/ |
| 4.12 集成测试 | 下单→入库→查询 完整流程 | test/integration/ |

**关键设计决策：**
- `client_order_id` 实现幂等性，防止重复下单
- 订单状态机严格控制流转，非法状态转换抛异常
- 价格校验：预测市场价格范围 0.01–0.99

**验收标准**: 能创建订单→查询→取消，状态机流转正确。

---

#### 模块 5：Risk 风控模块（第 4–5 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 5.1 文档 | 风控规则定义 | docs/risk-rules.md |
| 5.2 代码 | RiskCheckResult 模型 | domain/model/RiskCheckResult.java |
| 5.3 核心规则 | 实现硬编码风控规则： | domain/service/RiskDomainService.java |
| | ① 余额充足检查 (available ≥ price × quantity) | |
| | ② 单笔订单金额限额 (如 ≤ $10,000) | |
| | ③ 单市场持仓限额 (如 ≤ $25,000) | |
| | ④ 市场状态检查 (必须为 ACTIVE) | |
| | ⑤ 价格合理性检查 (0.01–0.99) | |
| 5.4 集成 | 与 Account 模块联动 (查余额、冻结资金) | application/RiskCheckService.java |
| 5.5 REST API | 风控状态查询 (调试用) | api/rest/RiskController.java |
| 5.6 单元测试 | 每条规则的通过/拒绝测试 | test/unit/RiskDomainServiceTest.java |
| 5.7 集成测试 | 下单→风控检查→余额冻结 完整流程 | test/integration/ |

**关键设计决策：**
- 风控规则链式执行，任一失败即拒绝
- MVP 阶段硬编码规则，中期迁移到 Easy Rules，完备迁移到 Drools
- 余额冻结在风控通过后同步执行

**验收标准**: 余额不足的订单被拒绝；超限额的订单被拒绝；正常订单通过并冻结资金。

---

#### 模块 6：Matching 撮合引擎（第 5–7 周）⭐ 核心难点

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 6.1 文档 | 撮合引擎设计文档 (LOB 数据结构、撮合算法) | docs/matching-engine-design.md |
| 6.2 领域模型 | OrderBook (买卖双方订单簿) | matching/model/OrderBook.java |
| 6.3 领域模型 | PriceLevel (价格档位，用 TreeMap) | matching/model/PriceLevel.java |
| 6.4 领域模型 | MatchResult, Trade 模型 | matching/model/MatchResult.java |
| 6.5 撮合算法 | 价格优先-时间优先撮合逻辑 | matching/engine/MatchingAlgorithm.java |
| 6.6 订单簿 | 订单簿维护 (添加、取消、部分成交) | matching/engine/OrderBookManager.java |
| 6.7 Disruptor | 简化版 Disruptor 集成 (单生产者单消费者) | matching/disruptor/OrderEventHandler.java |
| 6.8 市场路由 | 按 market_id 路由到对应订单簿 | matching/engine/MarketRouter.java |
| 6.9 应用层 | MatchingEngineService (接收订单、输出成交) | application/MatchingEngineService.java |
| 6.10 单元测试 | 撮合核心算法测试 (10+ 场景): | test/unit/ |
| | ① 完全匹配：买1@0.60 vs 卖1@0.60 | |
| | ② 价格交叉：买@0.65 vs 卖@0.60 (以maker价成交) | |
| | ③ 部分成交：买100@0.60 vs 卖50@0.60 | |
| | ④ 多笔撮合：一笔taker吃掉多笔maker | |
| | ⑤ IOC 订单：未完全成交部分自动取消 | |
| | ⑥ 空簿下单：直接挂单 | |
| | ⑦ 取消订单：从订单簿中移除 | |
| | ⑧ 订单簿深度验证 | |
| 6.11 集成测试 | 下单→撮合→返回成交结果 完整链路 | test/integration/ |
| 6.12 性能测试 | 基础吞吐量测试 (目标: >10k ops/sec) | test/performance/ |

**关键设计决策：**
- 数据结构: `TreeMap<BigDecimal, LinkedList<Order>>` 实现价格档位
- 单线程撮合，避免并发问题（LMAX 理念）
- MVP 不做合成撮合（YES+NO 对冲），每个合约类型独立订单簿
- Disruptor 简化使用：单 Ring Buffer，顺序处理

**验收标准**: 撮合算法 10+ 场景单测全绿；性能 >10k ops/sec。

---

#### 模块 7：Clearing 清算模块（第 7–8 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 7.1 文档 | 清算流程设计 | docs/clearing-design.md |
| 7.2 领域模型 | Trade, Settlement, Fee 模型 | clearing/model/*.java |
| 7.3 数据库 | trades, settlements 表 DDL | migration/V3__clearing.sql |
| 7.4 核心逻辑 | 实现清算流程： | clearing/service/ClearingDomainService.java |
| | ① 记录成交 (trades 表) | |
| | ② 计算手续费 (maker/taker 费率) | |
| | ③ 资金划转 (解冻 + 扣款/入账) | |
| | ④ 更新持仓 | |
| | ⑤ 写入资金流水 (ledger_entries) | |
| 7.5 事务保证 | 清算全过程包裹在本地事务中 (SERIALIZABLE) | @Transactional |
| 7.6 集成 | 与 Account 模块联动 | application/ClearingAppService.java |
| 7.7 单元测试 | 清算计算逻辑测试 | test/unit/ |
| 7.8 集成测试 | 成交→清算→余额变化→流水记录 | test/integration/ |

**关键设计决策：**
- MVP 同步清算（不走 Kafka），中期改为异步
- 本地事务保证：trades + accounts + positions + ledger 在同一事务中
- 手续费模型：taker 0.02%, maker 0.01%（可配置）

**验收标准**: 撮合产生的成交能正确清算，买卖双方余额和持仓变化正确，流水记录完整。

---

#### 模块 8：Gateway 网关模块（第 8–9 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 8.1 文档 | API 接口总览 + 鉴权方案 | docs/api-overview.md |
| 8.2 代码 | JWT 认证模块 (登录/注册/刷新 Token) | security/JwtAuthFilter.java |
| 8.3 代码 | 用户管理 (简化版：注册、登录) | user/UserService.java |
| 8.4 代码 | 简单限流 (Bucket4j 或 手写令牌桶) | ratelimit/RateLimitFilter.java |
| 8.5 代码 | 路由配置 (硬编码指向 pm-trading-core) | config/RouteConfig.java |
| 8.6 代码 | 全局错误处理 + 请求日志 | GlobalExceptionHandler, RequestLogFilter |
| 8.7 API 文档 | OpenAPI/Swagger 文档生成 | springdoc-openapi 配置 |
| 8.8 单元测试 | JWT 生成/验证、限流逻辑 | test/unit/ |
| 8.9 集成测试 | 鉴权→路由→下单 完整链路 | test/integration/ |

**验收标准**: 未登录请求被拒绝；登录获取 Token 后能正常访问所有交易 API。

---

#### 模块 9：端到端集成与 MVP 发布（第 9–10 周）

| 步骤 | 具体任务 | 产出物 |
|------|----------|--------|
| 9.1 端到端测试 | 完整交易流程自动化测试: | test/e2e/ |
| | 注册→登录→充值→查余额→下买单→下卖单→撮合→清算→查持仓→查流水 | |
| 9.2 错误场景测试 | 余额不足、重复下单、取消已成交订单、超限额等 | test/e2e/error-cases/ |
| 9.3 数据一致性验证 | 所有用户余额总和 = 系统初始总额 (零和验证) | test/consistency/ |
| 9.4 Docker 打包 | pm-gateway + pm-trading-core 的 Dockerfile | Dockerfile × 2 |
| 9.5 完整 Docker Compose | 一键启动全部服务 | docker-compose.full.yml |
| 9.6 API 测试集 | Postman / Bruno 集合 | api-collection.json |
| 9.7 部署文档 | 本地运行指南 + 环境变量说明 | docs/deployment.md |

**验收标准**: `docker-compose up` 一键启动 → Postman 跑完全部 API 测试 → 零和验证通过。

---

### 2.5 MVP 关键里程碑

```
Week 1:  [项目脚手架] ──────── 仓库结构、Docker、数据库就绪
Week 2:  [pm-common] ──────── 公共工具可用
Week 3:  [Account + Market] ── 充值/余额/市场配置可用
Week 4:  [Order] ──────────── 下单/查单可用
Week 5:  [Risk] ───────────── 风控检查可用
Week 6-7: [Matching] ─────── 撮合引擎可用 ⭐
Week 8:  [Clearing] ────────── 清算结算可用
Week 9:  [Gateway] ─────────── 认证+路由可用
Week 10: [E2E + 发布] ─────── MVP 发布 🎉
```

---

## 三、Phase 2 — 中期实施计划

### 3.1 核心目标
将 MVP 单体拆分为微服务，引入 Python 服务，支持市场管理、行情推送、基本裁决。

### 3.2 中期模块实施顺序

| 优先级 | 模块 | 语言 | 依赖 | 预计周期 |
|--------|------|------|------|----------|
| **P0** | 基础设施升级 (Kafka + Consul) | Infra | — | 2 周 |
| **P0** | 微服务拆分 (pm-trading-core → 独立服务) | Java | Kafka, Consul | 3 周 |
| **P1** | pm-market-service (市场管理) | Python | PostgreSQL | 2 周 |
| **P1** | pm-oracle-service (预言机基础版) | Python | pm-market-service | 2 周 |
| **P2** | pm-market-data-service (行情) | Python | TimescaleDB, WebSocket | 2 周 |
| **P2** | pm-notification-service (通知) | Java | Kafka, WebSocket | 2 周 |
| **P3** | 网关升级 (Kong 替换 SCG) | Infra | — | 1 周 |
| **P3** | 监控体系 (Prometheus + Grafana + Jaeger) | Infra | — | 2 周 |

### 3.3 每个模块的实施步骤（简要）

#### 基础设施升级
1. 部署 Kafka 3 节点集群 (或开发环境用 Redpanda)
2. 部署 Consul (服务发现 + 配置中心)
3. 设计 Kafka Topic 规划 (orders.commands, trades.events, settlements.events 等)
4. 编写 Kafka 公共生产者/消费者模块 (pm-common-kafka)
5. 编写 Consul 服务注册公共模块

#### 微服务拆分
1. 从 pm-trading-core 中拆出 pm-order-service (独立 Spring Boot 应用)
2. 拆出 pm-risk-service
3. 拆出 pm-matching-engine
4. 拆出 pm-clearing-service
5. 拆出 pm-account-service
6. 服务间通信改造：同步 gRPC + 异步 Kafka
7. 每个服务独立数据库 Schema
8. 全链路集成测试

#### pm-market-service (Python)
1. 项目脚手架 (FastAPI + SQLAlchemy + Alembic)
2. 市场领域模型 + 状态机 (DRAFT→ACTIVE→SUSPENDED→RESOLVED→SETTLED)
3. 市场 CRUD API
4. 市场规则配置 (交易时间、最小/最大持仓、手续费率)
5. Kafka 事件发布 (market.created, market.status_changed)
6. 单元测试 + 集成测试

#### pm-oracle-service (Python)
1. 项目脚手架
2. 数据源接口抽象 (支持多种 API 数据源)
3. 简化裁决流程 (人工确认 + 管理后台)
4. 市场结算触发 (结算后更新持仓 + 清算 YES/NO 最终价值)
5. Celery 定时任务 (数据采集)
6. 单元测试 + 集成测试

#### pm-market-data-service (Python)
1. 项目脚手架
2. TimescaleDB 连续聚合 (1m/5m/1h/1d K线)
3. 实时行情消费 (从 Kafka trades.events)
4. WebSocket 推送 (订单簿深度、最新价)
5. REST API (历史 K线、Ticker)
6. 单元测试 + 集成测试

#### pm-notification-service (Java)
1. 项目脚手架
2. Kafka 消费 (订单状态变化、成交通知、市场事件)
3. WebSocket 推送 (实时通知)
4. 邮件/短信通知 (可选)
5. 单元测试 + 集成测试

### 3.4 中期里程碑

```
Week 1-2:   [基础设施升级] ────── Kafka + Consul 就绪
Week 3-5:   [微服务拆分] ──────── 5 个 Java 服务独立运行
Week 6-7:   [Market Service] ──── 市场管理可用
Week 8-9:   [Oracle Service] ──── 基本裁决可用
Week 10-11: [Market Data] ─────── 行情推送可用
Week 12-13: [Notification] ────── 通知系统可用
Week 14:    [Kong + 监控] ─────── 运维体系就绪
Week 15-16: [集成测试 + 发布] ── 中期版本发布 🎉
```

---

## 四、Phase 3 — 生产就绪计划

### 4.1 核心目标
高可用、水平扩展、合规审计、智能风控、自动裁决。

### 4.2 生产就绪模块实施顺序

| 优先级 | 模块 | 关键升级 | 预计周期 |
|--------|------|----------|----------|
| **P0** | 数据库分片 (ShardingSphere) | 订单/账户按 user_id 分片 | 3 周 |
| **P0** | 撮合引擎升级 | 合成撮合 + 分片 + 事件溯源 | 3 周 |
| **P0** | 高可用部署 (K8s) | 多副本 + 自动故障转移 | 3 周 |
| **P1** | 智能风控 (Drools + Flink CEP) | 规则引擎 + 实时异常检测 | 3 周 |
| **P1** | 自动裁决 (Temporal) | 多源验证 + 争议处理工作流 | 3 周 |
| **P2** | 分析系统 (ClickHouse) | 对账、报表、反作弊 ML | 2 周 |
| **P2** | 审计合规 (MinIO WORM) | 不可篡改日志、合规报表 | 2 周 |
| **P3** | 性能优化 | 全链路压测、延迟优化 | 2 周 |
| **P3** | 安全加固 | WAF、DDoS防护、渗透测试 | 2 周 |

---

## 五、每个模块通用的实施模板

无论在哪个阶段，每个模块都应按以下步骤实施：

```
┌──────────────────────────────────────────────────────────────┐
│                    模块实施标准流程                              │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 📋 需求与设计 (Design)                                    │
│     ├── 编写模块设计文档 (接口、数据模型、流程图)                │
│     ├── 定义 Protobuf / API Schema                           │
│     └── 设计数据库表结构                                      │
│                                                              │
│  2. 🏗️ 领域层 (Domain)                                       │
│     ├── 实现领域模型 (Entity, Value Object, Enum)             │
│     ├── 实现领域服务 (核心业务逻辑)                             │
│     ├── 定义领域事件                                          │
│     └── 定义仓储接口                                          │
│                                                              │
│  3. 🔧 基础设施层 (Infrastructure)                             │
│     ├── 实现数据库持久化 (JPA / SQLAlchemy)                    │
│     ├── 实现缓存层 (Redis)                                    │
│     ├── 实现消息生产者/消费者 (Kafka)                           │
│     └── 实现外部服务客户端 (gRPC / HTTP)                       │
│                                                              │
│  4. 🖥️ 应用层 (Application)                                   │
│     ├── 实现 Command/Query Handler                            │
│     └── 编排领域服务与基础设施                                  │
│                                                              │
│  5. 🌐 API 层 (Interface)                                     │
│     ├── 实现 REST Controller / gRPC Service                   │
│     └── 生成 API 文档 (Swagger / gRPC reflection)             │
│                                                              │
│  6. ✅ 测试 (Testing)                                         │
│     ├── 单元测试 (领域逻辑, ≥80% 覆盖率)                      │
│     ├── 集成测试 (数据库 + 缓存, Testcontainers)              │
│     └── 端到端测试 (API 级别)                                 │
│                                                              │
│  7. 🔍 验收 (Verification)                                    │
│     ├── 代码审查 (AI 辅助 review)                              │
│     ├── 测试覆盖率检查                                         │
│     └── 与已有模块的集成验证                                    │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 六、AI Vibe Coding 使用建议

### 6.1 适合让 AI 做的事情

| 任务类型 | 具体示例 | 效率提升 |
|----------|----------|----------|
| **脚手架生成** | Gradle 配置、项目结构、Dockerfile | 极高 |
| **CRUD 代码** | Entity、Repository、Controller、DTO | 极高 |
| **模板代码** | Protobuf 定义、Kafka 配置、Redis 配置 | 极高 |
| **单元测试** | 给定一个类，让 AI 生成全面的测试用例 | 高 |
| **文档编写** | API 文档、设计文档、README | 高 |
| **调试** | 给 AI 错误日志，让它分析根因 | 高 |
| **代码重构** | 提取接口、优化性能、改善命名 | 中 |

### 6.2 需要自己深入理解的事情

| 任务类型 | 原因 |
|----------|------|
| **撮合算法核心逻辑** | 这是系统的核心竞争力，需要理解每一行代码 |
| **资金安全相关代码** | 余额操作、并发控制、事务边界 |
| **架构决策** | 服务拆分、技术选型、数据库设计 |
| **性能优化** | 需要理解瓶颈在哪、为什么这样优化 |

### 6.3 推荐的 AI 辅助工作流

```
1. 先让 AI 生成设计文档 → 自己 Review
2. 让 AI 生成领域模型骨架 → 自己补充业务逻辑
3. 让 AI 生成完整的 CRUD + 测试 → 自己检查边界条件
4. 让 AI 生成集成测试 → 自己确认测试场景覆盖全面
5. 出现 Bug 时，把日志和代码一起给 AI → 让它分析原因
6. 每完成一个模块，让 AI 做 Code Review → 发现潜在问题
```

---

## 七、风险与注意事项

### 7.1 技术风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 撮合引擎性能不达标 | 核心功能受限 | 先实现简单版，性能测试驱动优化 |
| 资金计算精度问题 | 财务对账失败 | 全程使用 BigDecimal，禁用浮点 |
| 并发余额问题 | 超卖/资金不一致 | 乐观锁 + Redis Lua + 数据库事务 |
| 微服务拆分复杂度 | 中期进度延迟 | MVP 单体模块化设计，降低拆分成本 |

### 7.2 项目管理建议

- **每周产出可运行的东西**：不要追求完美，先跑通再优化
- **测试先行**：每个模块完成后必须有自动化测试
- **持续集成**：从第一天就配置 CI/CD
- **文档同步**：设计文档 → 代码 → 测试，保持三者一致
- **Git 规范**：每个模块一个 feature 分支，完成后合并到 main

---

## 八、快速参考 — 一页纸行动清单

```
Phase 1 (MVP, 8-12周):
  □ Week 1:   项目脚手架 + Docker + 数据库
  □ Week 2:   pm-common 公共模块
  □ Week 3:   Account 账户 + Market 市场配置
  □ Week 4:   Order 订单模块
  □ Week 5:   Risk 风控模块
  □ Week 6-7: Matching 撮合引擎 ⭐
  □ Week 8:   Clearing 清算模块
  □ Week 9:   Gateway 网关
  □ Week 10:  E2E 测试 + MVP 发布 🎉

Phase 2 (中期, 10-16周):
  □ Week 1-2:   Kafka + Consul 基础设施
  □ Week 3-5:   微服务拆分
  □ Week 6-7:   Market Service (Python)
  □ Week 8-9:   Oracle Service (Python)
  □ Week 10-11: Market Data Service
  □ Week 12-13: Notification Service
  □ Week 14-16: Kong + 监控 + 集成发布 🎉

Phase 3 (生产就绪, 12-20周):
  □ 数据库分片 + 高可用
  □ 撮合引擎升级 (合成撮合 + 分片)
  □ K8s 部署
  □ Drools + Flink 智能风控
  □ Temporal 自动裁决
  □ ClickHouse 分析 + 审计合规
  □ 安全加固 + 性能优化 + 正式发布 🚀
```

---

*文档版本: v1.0 | 生成日期: 2026-02-20*
