# 文档 3：撮合引擎与清算流程设计

> **版本**: v1.2 — 单账本撮合引擎架构
> **状态**: 草稿（待 Review）
> **适用范围**: Phase 1 MVP，撮合引擎（pm_matching）与清算模块（pm_clearing）的实现指南
> **对齐文档**: 《全局约定与数据库设计 v2.2》、《API 接口契约 v1.1》、《单账本撮合引擎设计方案 v1》、《完整实施计划 v4.1》
> **日期**: 2026-02-20

---

## 目录

1. [文档范围与前提设定](#第一部分文档范围与前提设定)
2. [撮合引擎架构总览](#第二部分撮合引擎架构总览)
3. [内存订单簿设计](#第三部分内存订单簿设计)
4. [订单转换层](#第四部分订单转换层)
5. [撮合算法](#第五部分撮合算法)
6. [四种撮合场景执行](#第六部分四种撮合场景执行)
7. [清算流程](#第七部分清算流程)
8. [自动净额结算 (Auto-Netting)](#第八部分自动净额结算-auto-netting)
9. [订单生命周期管理](#第九部分订单生命周期管理)
10. [市场结算与退出](#第十部分市场结算与退出)
11. [恒等式与一致性校验](#第十一部分恒等式与一致性校验)
12. [附录](#附录)

---

## 第一部分：文档范围与前提设定

### 1.1 文档范围

本文档覆盖撮合引擎（pm_matching）和清算模块（pm_clearing）的**完整业务逻辑与伪代码实现**，包括：

- 内存订单簿的数据结构与维护
- 订单转换层（NO → YES 映射）
- 价格时间优先撮合算法
- 四种撮合场景（Mint / Transfer YES / Transfer NO / Burn）的判定与执行
- 清算资金划转、持仓更新、手续费计算、realized_pnl 持久化
- 自动净额结算（Auto-Netting）
- 订单取消与部分成交处理
- 市场结算（正常判定 + 作废退款）
- 核心恒等式校验

**不在本文档范围内**（后续文档详述）：WAL 预写日志、状态快照、故障恢复、熔断机制、性能优化。这些内容在附录 A 中简要提及。

### 1.2 前提设定

| # | 设定 | 来源 |
|---|------|------|
| 1 | **per-market asyncio.Lock** 保护撮合全链路，非 Sequencer 队列模式 | v4.1 计划 |
| 2 | 每个 market_id 对应**一把 asyncio.Lock**，获取锁后同步执行 校验→冻结→撮合→清算→Netting 全流程 | v4.1 计划 |
| 3 | 余额冻结/解冻通过 **PostgreSQL 原子 SQL** 操作，不经过 Redis | DB v2.2 §1.7 |
| 4 | MVP 仅支持 **GTC** 和 **IOC** 两种 time_in_force，不含 FOK | DB v2.2 orders CHECK |
| 5 | 所有金额/价格/数量均为**整数（美分制）**，禁止 float/Decimal | DB v2.2 §1.1 |
| 6 | 手续费公式：`(trade_value * fee_bps + 9999) // 10000`（向上取整） | 权威设计方案 §3.5 |
| 7 | Synthetic 订单手续费基于 **NO 价格**（用户实际成本），非转换后的 YES 价格 | 权威设计方案 §3.5 |
| 8 | 成交价 = **Maker 的 book_price**，价格改善归 Taker | 权威设计方案 §4.4 |
| 9 | 自成交预防：拒绝与**同一 user_id** 的对手方撮合 | 权威设计方案 §4.3 |
| 10 | **开仓买单预冻结手续费**：FUNDS 冻结类型的订单，冻结额 = `trade_value + max_taker_fee`，防止成交后扣费时 available=0 触发 CHECK 失败 | v1.1 新增 |
| 11 | **SYSTEM_RESERVE / PLATFORM_FEE 延迟聚合**：核心交易事务只写 ledger_entries (INSERT)，系统账户物理行由后台定时任务聚合更新，避免跨 market 行锁串行化 | v1.1 新增 |

### 1.3 模块归属

```
pm_matching   — 撮合引擎: 内存订单簿, 订单转换, 撮合算法, 场景判定
pm_clearing   — 清算模块: 资金划转, 持仓更新, 手续费, realized_pnl, 流水记录
pm_account    — 账户模块: 余额操作, 持仓 CRUD, Auto-Netting
pm_order      — 订单模块: 订单 CRUD, 状态机转换
pm_market     — 市场模块: 市场状态机, 结算/退款
```

---

## 第二部分：撮合引擎架构总览

### 2.1 请求处理全链路

```
┌────────────────────────────────────────────────────────────────────────┐
│                        下单请求全链路                                    │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  API 层 (FastAPI Handler)                                              │
│  ════════════════════════                                              │
│  POST /api/v1/markets/{market_id}/orders                               │
│       │                                                                │
│       ▼                                                                │
│  ┌──────────────────────────────────────┐                              │
│  │  Step 1: 基础校验 (pm_order)         │                              │
│  │  · 幂等性检查 (client_order_id)      │                              │
│  │  · 市场状态 = ACTIVE                 │                              │
│  │  · 价格范围 [1, 99]                  │                              │
│  │  · 数量 > 0 且 ≤ max_order_quantity  │                              │
│  └──────────────┬───────────────────────┘                              │
│                 │                                                       │
│                 ▼                                                       │
│  ┌──────────────────────────────────────┐                              │
│  │  Step 2: 订单转换 (pm_matching)      │                              │
│  │  · transform_order()                 │                              │
│  │  · 确定 book_type / book_direction   │                              │
│  │    / book_price / frozen_asset_type  │                              │
│  └──────────────┬───────────────────────┘                              │
│                 │                                                       │
│                 ▼                                                       │
│  ┌──────────────────────────────────────┐                              │
│  │  Step 3: 获取 per-market Lock        │                              │
│  │  async with market_locks[market_id]: │  ◄── 串行化入口               │
│  └──────────────┬───────────────────────┘                              │
│                 │                                                       │
│                 ▼                                                       │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  Step 4-8: 锁内全流程 (单一 DB 事务)                         │      │
│  │  ─────────────────────────────────────                       │      │
│  │  4. 风控与冻结 — PostgreSQL 原子 UPDATE (pm_account)          │      │
│  │  5. 撮合 — 内存订单簿匹配 (pm_matching)                      │      │
│  │  6. 清算 — 资金划转 + 持仓更新 + 手续费 + PnL (pm_clearing) │      │
│  │  7. Auto-Netting — 检查并执行净额结算 (pm_account)           │      │
│  │  8. 订单状态更新 + 流水写入 (pm_order + pm_account)           │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                 │                                                       │
│                 ▼                                                       │
│  ┌──────────────────────────────────────┐                              │
│  │  Step 9: 返回响应                    │                              │
│  │  · 订单状态 + 成交信息               │                              │
│  └──────────────────────────────────────┘                              │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.2 并发模型

```python
# pm_matching/engine.py

class MatchingEngine:
    """撮合引擎 — 每个 market_id 一把 asyncio.Lock"""

    def __init__(self):
        self._market_locks: dict[str, asyncio.Lock] = {}
        self._orderbooks: dict[str, OrderBook] = {}

    def _get_lock(self, market_id: str) -> asyncio.Lock:
        """懒创建 per-market 锁"""
        if market_id not in self._market_locks:
            self._market_locks[market_id] = asyncio.Lock()
        return self._market_locks[market_id]

    def _get_orderbook(self, market_id: str) -> OrderBook:
        """懒创建内存订单簿"""
        if market_id not in self._orderbooks:
            self._orderbooks[market_id] = OrderBook(market_id)
        return self._orderbooks[market_id]

    async def submit_order(
        self, order_request: OrderRequest, db: AsyncSession
    ) -> OrderResult:
        """
        下单入口 — 全链路串行化

        获取 market_id 对应的 asyncio.Lock 后，在单一 DB 事务内
        同步执行 校验→冻结→撮合→清算→Netting→状态更新 全流程。
        """
        lock = self._get_lock(order_request.market_id)

        async with lock:
            async with db.begin():
                # Step 2: 订单转换
                order = transform_order(order_request)

                # Step 4: 风控与冻结
                await freeze_for_order(order, db)

                # Step 5: 撮合
                market = await get_market(order.market_id, db)
                orderbook = self._get_orderbook(order.market_id)
                trades = match_order(order, orderbook, market.taker_fee_bps)

                # Step 6: 清算 (逐笔)
                for trade in trades:
                    await execute_clearing(trade, db)

                # Step 7: Auto-Netting (检查所有参与方)
                affected_user_ids = collect_affected_users(trades)
                for user_id in affected_user_ids:
                    await execute_netting_if_needed(
                        user_id, order.market_id, db
                    )

                # Step 8: 订单状态 + 入簿 (GTC 剩余挂单)
                await finalize_order(order, trades, orderbook, market, db)

                return OrderResult(order=order, trades=trades)
```

**关键设计决策**:

- **为何不用 Sequencer 队列**: MVP 阶段单进程 + per-market Lock 已足够。asyncio.Lock 保证同一 market 下单请求串行化，无需额外队列基础设施。所有操作在同一 DB 事务中完成，天然保证一致性。
- **跨 market 并发**: 不同 market_id 使用不同的 Lock，天然支持并行撮合。
- **锁粒度**: 锁覆盖从冻结到 Netting 的全流程，避免部分完成的中间状态。

---

## 第三部分：内存订单簿设计

### 3.1 数据结构

> 对齐 exchange-core 的 OrderBook 结构，每个 market 维护单一 YES 订单簿。

```python
# pm_matching/orderbook.py

from dataclasses import dataclass, field
from collections import deque
from typing import Optional
import time


@dataclass
class BookOrder:
    """订单簿中的挂单"""
    order_id: str           # orders.id (UUID as string)
    user_id: str            # 用户 ID
    book_type: str          # NATIVE_BUY / NATIVE_SELL / SYNTHETIC_BUY / SYNTHETIC_SELL
    book_direction: str     # BUY / SELL
    book_price: int         # 订单簿价格 (美分, 1-99)
    remaining_qty: int      # 剩余数量
    original_price: int     # 用户原始价格 (Synthetic 时 ≠ book_price)
    timestamp: float        # 挂单时间戳 (单调递增, 用于时间优先)

    # 以下字段用于冻结管理
    frozen_amount: int      # 剩余冻结额 (FUNDS 含手续费缓冲)
    frozen_asset_type: str  # FUNDS / YES_SHARES / NO_SHARES


class OrderBook:
    """
    单一 YES 订单簿 — O(1) 定长数组 + 游标

    ⚠️ 利用价格边界 [1, 99] 的天然约束, 使用长度 100 的数组实现 O(1) 寻址。
    索引 i 直接代表价格 i 美分, 索引 0 废弃。

    Buy 侧 (Bids): best_bid 游标从高向低扫描
    Sell 侧 (Asks): best_ask 游标从低向高扫描

    成交条件: best_bid >= best_ask
    成交价格: Maker 的 book_price (resting order)

    性能对比:
      dict + sorted(): 每次撮合 O(N log N), N = 活跃价格档位数
      定长数组 + 游标: O(1) 寻址 + O(K) 游标修复, K ≤ 99 (有界常数)
    """

    def __init__(self, market_id: str):
        self.market_id = market_id
        # 索引 0 废弃, 1-99 直接代表价格 → O(1) 寻址
        self._bids: list[deque[BookOrder]] = [deque() for _ in range(100)]
        self._asks: list[deque[BookOrder]] = [deque() for _ in range(100)]
        # 游标: 维护当前最优价格, 避免每次遍历
        self._best_bid: int = 0    # 0 = 无买单
        self._best_ask: int = 100  # 100 = 无卖单
        # 快速定位订单 (用于取消), O(1) 查找
        self._order_index: dict[str, BookOrder] = {}

    @property
    def best_bid(self) -> Optional[int]:
        """当前最高买价, None 表示无买单"""
        return self._best_bid if self._best_bid > 0 else None

    @property
    def best_ask(self) -> Optional[int]:
        """当前最低卖价, None 表示无卖单"""
        return self._best_ask if self._best_ask < 100 else None

    def add_order(self, order: BookOrder) -> None:
        """将订单挂入订单簿 — O(1)"""
        price = order.book_price
        if order.book_direction == "BUY":
            self._bids[price].append(order)
            if price > self._best_bid:
                self._best_bid = price
        else:
            self._asks[price].append(order)
            if price < self._best_ask:
                self._best_ask = price
        self._order_index[order.order_id] = order

    def remove_order(self, order_id: str) -> Optional[BookOrder]:
        """从订单簿移除订单 — O(1) 查找 + O(K) 游标修复"""
        order = self._order_index.pop(order_id, None)
        if order is None:
            return None

        price = order.book_price
        if order.book_direction == "BUY":
            self._bids[price].remove(order)
            # 游标修复: 如果当前最优价格档位空了, 向下扫描
            if not self._bids[price] and price == self._best_bid:
                self._best_bid = self._scan_best_bid(price)
        else:
            self._asks[price].remove(order)
            if not self._asks[price] and price == self._best_ask:
                self._best_ask = self._scan_best_ask(price)
        return order

    def get_order(self, order_id: str) -> Optional[BookOrder]:
        """查找订单簿中的挂单 — O(1)"""
        return self._order_index.get(order_id)

    def _scan_best_bid(self, from_price: int) -> int:
        """从 from_price 向下扫描找到下一个非空 bid 价位, 返回 0 表示无买单"""
        for p in range(from_price - 1, 0, -1):
            if self._bids[p]:
                return p
        return 0

    def _scan_best_ask(self, from_price: int) -> int:
        """从 from_price 向上扫描找到下一个非空 ask 价位, 返回 100 表示无卖单"""
        for p in range(from_price + 1, 100):
            if self._asks[p]:
                return p
        return 100

    def _update_best_bid_after_fill(self, price: int) -> None:
        """成交后若当前价位清空, 修复 best_bid 游标"""
        if not self._bids[price] and price == self._best_bid:
            self._best_bid = self._scan_best_bid(price)

    def _update_best_ask_after_fill(self, price: int) -> None:
        """成交后若当前价位清空, 修复 best_ask 游标"""
        if not self._asks[price] and price == self._best_ask:
            self._best_ask = self._scan_best_ask(price)
```

### 3.2 订单簿恢复

服务重启时，需从 DB 加载活跃订单重建内存订单簿：

```python
async def rebuild_orderbook(
    market_id: str, db: AsyncSession
) -> OrderBook:
    """
    从 DB 重建内存订单簿

    加载该 market 所有 status IN ('OPEN', 'PARTIALLY_FILLED') 的订单，
    利用索引 idx_orders_market_active 快速查询。
    """
    orderbook = OrderBook(market_id)

    # 查询活跃订单 (利用 idx_orders_market_active 索引)
    active_orders = await db.execute(
        select(Order)
        .where(
            Order.market_id == market_id,
            Order.status.in_(["OPEN", "PARTIALLY_FILLED"])
        )
        .order_by(Order.created_at)  # 保持原始时间顺序
    )

    for order in active_orders.scalars():
        book_order = BookOrder(
            order_id=str(order.id),
            user_id=order.user_id,
            book_type=order.book_type,
            book_direction=order.book_direction,
            book_price=order.book_price,
            remaining_qty=order.remaining_quantity,
            original_price=order.original_price,
            timestamp=order.created_at.timestamp(),
            frozen_amount=order.frozen_amount,
            frozen_asset_type=order.frozen_asset_type,
        )
        orderbook.add_order(book_order)

    return orderbook
```

### 3.3 订单簿深度查询

> 对应 API v1.1 §4.3 — GET /api/v1/markets/{market_id}/orderbook

```python
def get_depth(self, max_levels: int = 10) -> dict:
    """
    获取订单簿深度 (YES 视角) — 利用数组天然有序性, 无需 sorted()

    返回 YES bids (降序) 和 YES asks (升序)，
    NO 视角由 API 层转换 (见 API v1.1 §4.3)。
    """
    bids = []
    for price in range(self._best_bid, 0, -1):
        if self._bids[price]:
            total = sum(o.remaining_qty for o in self._bids[price])
            bids.append({"price": price, "quantity": total})
            if len(bids) >= max_levels:
                break

    asks = []
    for price in range(self._best_ask, 100):
        if self._asks[price]:
            total = sum(o.remaining_qty for o in self._asks[price])
            asks.append({"price": price, "quantity": total})
            if len(asks) >= max_levels:
                break

    return {"bids": bids, "asks": asks}
```

---

## 第四部分：订单转换层

### 4.1 转换规则

> 核心原则：单一 YES 订单簿，所有 NO 操作通过 `100 - P` 转换后进入。

```python
# pm_matching/transform.py

def transform_order(request: OrderRequest, taker_fee_bps: int) -> Order:
    """
    订单转换层 — 将用户原始意图映射为订单簿参数

    转换规则 (对齐 DB v2.2 §2.4 订单转换规则表):
    ┌──────────────────┬──────────────────┬────────────────┬───────────┬───────────────────┐
    │ 用户操作          │ book_type        │ book_direction │ book_price│ frozen_asset_type │
    ├──────────────────┼──────────────────┼────────────────┼───────────┼───────────────────┤
    │ Buy YES @ P      │ NATIVE_BUY       │ BUY            │ P         │ FUNDS             │
    │ Sell YES @ P     │ NATIVE_SELL      │ SELL           │ P         │ YES_SHARES        │
    │ Buy NO @ P       │ SYNTHETIC_SELL   │ SELL           │ 100 - P   │ FUNDS             │
    │ Sell NO @ P      │ SYNTHETIC_BUY    │ BUY            │ 100 - P   │ NO_SHARES         │
    └──────────────────┴──────────────────┴────────────────┴───────────┴───────────────────┘

    ⚠️ 手续费预冻结 (v1.1 P0-1 修复):
    对 FUNDS 冻结类型 (开仓买单), frozen_amount = trade_value + max_taker_fee。
    原因: 成交后手续费从 frozen_balance 中扣除, 若不预冻结, 用户 available=0 时
    扣费会触发 DB CHECK 约束异常, 导致整个撮合事务回滚。

    对 SHARES 冻结类型 (平仓卖单), 无需预冻结手续费:
    成交后系统会先发钱给卖方 (available += revenue), 手续费直接从收入中扣除。
    """
    order = Order()
    order.market_id = request.market_id
    order.user_id = request.user_id
    order.client_order_id = request.client_order_id
    order.time_in_force = request.time_in_force  # GTC / IOC

    # 保留用户原始意图
    order.original_side = request.side           # YES / NO
    order.original_direction = request.direction # BUY / SELL
    order.original_price = request.price         # 1-99

    order.quantity = request.quantity
    order.remaining_quantity = request.quantity
    order.filled_quantity = 0

    if request.side == "YES":
        if request.direction == "BUY":
            order.book_type = "NATIVE_BUY"
            order.book_direction = "BUY"
            order.book_price = request.price
            order.frozen_asset_type = "FUNDS"
            trade_value = request.price * request.quantity
            max_fee = _calc_max_fee(trade_value, taker_fee_bps)
            order.frozen_amount = trade_value + max_fee
        else:  # SELL
            order.book_type = "NATIVE_SELL"
            order.book_direction = "SELL"
            order.book_price = request.price
            order.frozen_asset_type = "YES_SHARES"
            order.frozen_amount = request.quantity  # 份数, 无需预冻结费用
    else:  # NO
        if request.direction == "BUY":
            order.book_type = "SYNTHETIC_SELL"
            order.book_direction = "SELL"
            order.book_price = 100 - request.price
            order.frozen_asset_type = "FUNDS"
            trade_value = request.price * request.quantity
            max_fee = _calc_max_fee(trade_value, taker_fee_bps)
            order.frozen_amount = trade_value + max_fee
        else:  # SELL
            order.book_type = "SYNTHETIC_BUY"
            order.book_direction = "BUY"
            order.book_price = 100 - request.price
            order.frozen_asset_type = "NO_SHARES"
            order.frozen_amount = request.quantity  # 份数, 无需预冻结费用

    order.status = "NEW"
    return order


def _calc_max_fee(trade_value: int, taker_fee_bps: int) -> int:
    """按 Taker 费率计算最坏情况手续费 (向上取整)"""
    return (trade_value * taker_fee_bps + 9999) // 10000
```

### 4.2 冻结执行

```python
# pm_account/freeze.py

async def freeze_for_order(order: Order, db: AsyncSession) -> None:
    """
    风控检查 + 资金/持仓冻结 — PostgreSQL 原子操作

    根据 frozen_asset_type 执行不同的冻结逻辑:
    - FUNDS:      available_balance -= amount, frozen_balance += amount
    - YES_SHARES: yes_pending_sell += quantity (需检查 yes_volume - yes_pending_sell >= quantity)
    - NO_SHARES:  no_pending_sell += quantity  (需检查 no_volume - no_pending_sell >= quantity)

    如果余额/持仓不足，抛出 InsufficientFundsError，订单被拒绝 (status → REJECTED)。
    """
    if order.frozen_asset_type == "FUNDS":
        # 冻结资金 (原子 SQL, DB v2.2 §1.7 模式)
        result = await db.execute(
            text("""
                UPDATE accounts
                SET available_balance = available_balance - :amount,
                    frozen_balance = frozen_balance + :amount,
                    version = version + 1,
                    updated_at = NOW()
                WHERE user_id = :user_id
                  AND available_balance >= :amount
                RETURNING *
            """),
            {"user_id": order.user_id, "amount": order.frozen_amount}
        )
        if result.rowcount == 0:
            raise InsufficientFundsError(
                f"余额不足: 需要 {order.frozen_amount} 美分"
            )

    elif order.frozen_asset_type == "YES_SHARES":
        # 冻结 YES 持仓
        result = await db.execute(
            text("""
                UPDATE positions
                SET yes_pending_sell = yes_pending_sell + :qty,
                    updated_at = NOW()
                WHERE user_id = :user_id
                  AND market_id = :market_id
                  AND yes_volume - yes_pending_sell >= :qty
                RETURNING *
            """),
            {
                "user_id": order.user_id,
                "market_id": order.market_id,
                "qty": order.frozen_amount,  # 份数
            }
        )
        if result.rowcount == 0:
            raise InsufficientPositionError(
                f"YES 可卖持仓不足: 需要 {order.frozen_amount} 份"
            )

    elif order.frozen_asset_type == "NO_SHARES":
        # 冻结 NO 持仓
        result = await db.execute(
            text("""
                UPDATE positions
                SET no_pending_sell = no_pending_sell + :qty,
                    updated_at = NOW()
                WHERE user_id = :user_id
                  AND market_id = :market_id
                  AND no_volume - no_pending_sell >= :qty
                RETURNING *
            """),
            {
                "user_id": order.user_id,
                "market_id": order.market_id,
                "qty": order.frozen_amount,
            }
        )
        if result.rowcount == 0:
            raise InsufficientPositionError(
                f"NO 可卖持仓不足: 需要 {order.frozen_amount} 份"
            )

    # 写入冻结流水
    await write_ledger_entry(
        user_id=order.user_id,
        entry_type="ORDER_FREEZE",
        amount=-order.frozen_amount if order.frozen_asset_type == "FUNDS" else 0,
        reference_type="ORDER",
        reference_id=str(order.id),
        db=db,
    )
```

---

## 第五部分：撮合算法

### 5.1 价格时间优先 (Price-Time Priority)

```python
# pm_matching/algorithm.py

@dataclass
class TradeResult:
    """单笔撮合结果"""
    buy_order: BookOrder      # 订单簿 BUY 侧
    sell_order: BookOrder     # 订单簿 SELL 侧
    trade_price: int          # 成交价 = Maker 的 book_price
    quantity: int             # 成交数量
    maker_order_id: str       # Maker 订单 ID
    taker_order_id: str       # Taker 订单 ID
    scenario: str             # MINT / TRANSFER_YES / TRANSFER_NO / BURN


def match_order(
    incoming: BookOrder,
    orderbook: OrderBook,
    taker_fee_bps: int,
) -> list[TradeResult]:
    """
    撮合算法 — 价格时间优先

    规则:
    1. incoming 是 Taker (新到达的订单)
    2. 订单簿中的 resting order 是 Maker
    3. 成交价 = Maker 的 book_price (价格改善归 Taker)
    4. BUY incoming: 从 asks 的最低价开始匹配, 条件: ask_price <= incoming.book_price
    5. SELL incoming: 从 bids 的最高价开始匹配, 条件: bid_price >= incoming.book_price
    6. 自成交预防: 跳过同一 user_id 的对手方

    参数:
      taker_fee_bps: 市场 Taker 手续费率, 传入 _sync_frozen_amount 用于覆盖赋值
    """
    trades: list[TradeResult] = []

    if incoming.book_direction == "BUY":
        trades = _match_buy_order(incoming, orderbook, taker_fee_bps)
    else:
        trades = _match_sell_order(incoming, orderbook, taker_fee_bps)

    return trades


def _match_buy_order(
    incoming: BookOrder, orderbook: OrderBook, taker_fee_bps: int
) -> list[TradeResult]:
    """
    Buy 订单撮合 — 从 asks 最低价 (best_ask) 开始向上遍历

    incoming (BUY) 可能是:
      - NATIVE_BUY  (用户 Buy YES)
      - SYNTHETIC_BUY (用户 Sell NO)

    对手方 (SELL) 可能是:
      - NATIVE_SELL  (用户 Sell YES)
      - SYNTHETIC_SELL (用户 Buy NO)

    ⚠️ v1.1 P0-2: 使用定长数组直接遍历, 不再调用 sorted()
    ⚠️ v1.1 P1-4: 每笔成交后同步更新 Maker 的内存 frozen_amount
    """
    trades: list[TradeResult] = []

    # 从 best_ask 向上遍历 (O(1) 起始, 最多 99 步)
    ask_price = orderbook._best_ask
    while ask_price < 100 and incoming.remaining_qty > 0:
        if ask_price > incoming.book_price:
            break  # 卖价超过买方限价, 停止

        level = orderbook._asks[ask_price]
        if not level:
            ask_price += 1
            continue

        orders_to_remove = []

        for resting in list(level):  # 拷贝迭代, 避免修改中遍历
            if incoming.remaining_qty <= 0:
                break

            # 自成交预防
            if resting.user_id == incoming.user_id:
                continue  # 跳过, 不与自己成交

            fill_qty = min(incoming.remaining_qty, resting.remaining_qty)
            trade_price = resting.book_price  # Maker 价格

            scenario = determine_scenario(
                buy_book_type=incoming.book_type,
                sell_book_type=resting.book_type,
            )

            trade = TradeResult(
                buy_order=incoming,
                sell_order=resting,
                trade_price=trade_price,
                quantity=fill_qty,
                maker_order_id=resting.order_id,
                taker_order_id=incoming.order_id,
                scenario=scenario,
            )
            trades.append(trade)

            # 更新剩余量
            incoming.remaining_qty -= fill_qty
            resting.remaining_qty -= fill_qty

            # ⚠️ v1.2: 覆盖赋值同步内存 frozen_amount (基于 remaining_qty)
            _sync_frozen_amount(resting, taker_fee_bps)
            _sync_frozen_amount(incoming, taker_fee_bps)

            if resting.remaining_qty == 0:
                orders_to_remove.append(resting)

        # 移除已完全成交的 resting orders + 修复游标
        for order in orders_to_remove:
            orderbook.remove_order(order.order_id)

        ask_price += 1

    return trades


def _match_sell_order(
    incoming: BookOrder, orderbook: OrderBook, taker_fee_bps: int
) -> list[TradeResult]:
    """
    Sell 订单撮合 — 从 bids 最高价 (best_bid) 开始向下遍历

    incoming (SELL) 可能是:
      - NATIVE_SELL  (用户 Sell YES)
      - SYNTHETIC_SELL (用户 Buy NO)

    对手方 (BUY) 可能是:
      - NATIVE_BUY  (用户 Buy YES)
      - SYNTHETIC_BUY (用户 Sell NO)
    """
    trades: list[TradeResult] = []

    # 从 best_bid 向下遍历
    bid_price = orderbook._best_bid
    while bid_price > 0 and incoming.remaining_qty > 0:
        if bid_price < incoming.book_price:
            break  # 买价低于卖方限价, 停止

        level = orderbook._bids[bid_price]
        if not level:
            bid_price -= 1
            continue

        orders_to_remove = []

        for resting in list(level):
            if incoming.remaining_qty <= 0:
                break

            if resting.user_id == incoming.user_id:
                continue

            fill_qty = min(incoming.remaining_qty, resting.remaining_qty)
            trade_price = resting.book_price

            scenario = determine_scenario(
                buy_book_type=resting.book_type,
                sell_book_type=incoming.book_type,
            )

            trade = TradeResult(
                buy_order=resting,
                sell_order=incoming,
                trade_price=trade_price,
                quantity=fill_qty,
                maker_order_id=resting.order_id,
                taker_order_id=incoming.order_id,
                scenario=scenario,
            )
            trades.append(trade)

            incoming.remaining_qty -= fill_qty
            resting.remaining_qty -= fill_qty

            # ⚠️ v1.2: 覆盖赋值同步内存 frozen_amount (基于 remaining_qty)
            _sync_frozen_amount(resting, taker_fee_bps)
            _sync_frozen_amount(incoming, taker_fee_bps)

            if resting.remaining_qty == 0:
                orders_to_remove.append(resting)

        for order in orders_to_remove:
            orderbook.remove_order(order.order_id)

        bid_price -= 1

    return trades


def _sync_frozen_amount(order: BookOrder, taker_fee_bps: int) -> None:
    """
    ⚠️ v1.1→v1.2 修正: 基于 remaining_qty 覆盖赋值, 避免手续费截断误差累积

    为什么不用减法:
      旧版 `frozen -= original_price * fill_qty` 只减本金, 不减手续费缓冲。
      若用户取消, 解冻逻辑会把残留的手续费缓冲当本金退回 → 系统亏损。

    覆盖赋值公式:
      FUNDS: frozen = remaining_trade_value + max_fee(remaining_trade_value)
      SHARES: frozen = remaining_qty
    """
    if order.frozen_asset_type == "FUNDS":
        if order.remaining_qty == 0:
            order.frozen_amount = 0
        else:
            remaining_trade_value = order.original_price * order.remaining_qty
            remaining_max_fee = _calc_max_fee(remaining_trade_value, taker_fee_bps)
            order.frozen_amount = remaining_trade_value + remaining_max_fee
    else:
        # SHARES: 冻结了份数
        order.frozen_amount = order.remaining_qty
```

### 5.2 四种撮合场景判定

```python
def determine_scenario(buy_book_type: str, sell_book_type: str) -> str:
    """
    场景判定矩阵 — 由 Buy 侧和 Sell 侧的 book_type 唯一确定

    对齐 DB v2.2 §2.5 四种撮合场景判定矩阵:

                         Sell 侧
                   ┌──────────────┬──────────────┐
                   │ NATIVE_SELL  │SYNTHETIC_SELL│
                   │ (Sell YES)   │ (Buy NO)     │
    ┌──────────────┼──────────────┼──────────────┤
    │ NATIVE_BUY   │ TRANSFER_YES │    MINT      │
    │ (Buy YES)    │              │              │
    ├──────────────┼──────────────┼──────────────┤
    │ SYNTHETIC_BUY│    BURN      │ TRANSFER_NO  │
    │ (Sell NO)    │              │              │
    └──────────────┴──────────────┴──────────────┘
    """
    SCENARIO_MATRIX = {
        ("NATIVE_BUY",    "NATIVE_SELL"):    "TRANSFER_YES",
        ("NATIVE_BUY",    "SYNTHETIC_SELL"): "MINT",
        ("SYNTHETIC_BUY", "NATIVE_SELL"):    "BURN",
        ("SYNTHETIC_BUY", "SYNTHETIC_SELL"): "TRANSFER_NO",
    }
    scenario = SCENARIO_MATRIX.get((buy_book_type, sell_book_type))
    if scenario is None:
        raise MatchingError(
            f"无效的 book_type 组合: buy={buy_book_type}, sell={sell_book_type}"
        )
    return scenario
```

### 5.3 GTC 与 IOC 行为差异

```python
async def finalize_order(
    order: Order,
    trades: list[TradeResult],
    orderbook: OrderBook,
    market: Market,
    db: AsyncSession,
) -> None:
    """
    订单收尾 — 根据 time_in_force 决定未成交部分的处理

    GTC: 未成交部分挂入订单簿等待, status → OPEN 或 PARTIALLY_FILLED
    IOC: 未成交部分立即取消, status → FILLED 或 CANCELLED
    """
    total_filled = sum(t.quantity for t in trades)
    order.filled_quantity = total_filled
    order.remaining_quantity = order.quantity - total_filled

    if total_filled == order.quantity:
        # 完全成交
        order.status = "FILLED"
        order.frozen_amount = 0

    elif order.time_in_force == "GTC":
        # GTC: 剩余挂入订单簿
        if total_filled > 0:
            order.status = "PARTIALLY_FILLED"
        else:
            order.status = "OPEN"

        # 更新冻结额 (仅保留剩余部分的冻结)
        if order.frozen_asset_type == "FUNDS":
            # 资金冻结: 按剩余量重算 (含手续费缓冲)
            remaining_trade_value = order.original_price * order.remaining_quantity
            remaining_max_fee = _calc_max_fee(remaining_trade_value, market.taker_fee_bps)
            order.frozen_amount = remaining_trade_value + remaining_max_fee
        else:
            # 持仓冻结: 按剩余量
            order.frozen_amount = order.remaining_quantity

        # 挂入内存订单簿
        book_order = BookOrder(
            order_id=str(order.id),
            user_id=order.user_id,
            book_type=order.book_type,
            book_direction=order.book_direction,
            book_price=order.book_price,
            remaining_qty=order.remaining_quantity,
            original_price=order.original_price,
            timestamp=time.monotonic(),
            frozen_amount=order.frozen_amount,
            frozen_asset_type=order.frozen_asset_type,
        )
        orderbook.add_order(book_order)

    elif order.time_in_force == "IOC":
        # IOC: 未成交部分取消
        if total_filled > 0:
            order.status = "FILLED" if order.remaining_quantity == 0 else "CANCELLED"
        else:
            order.status = "CANCELLED"

        # 解冻未成交部分
        if order.remaining_quantity > 0:
            await unfreeze_remaining(order, db)
            order.frozen_amount = 0
            order.remaining_quantity = 0
            order.cancel_reason = "IOC_UNFILLED"

    # 持久化订单状态
    await update_order_in_db(order, db)
```

### 5.4 自成交预防 (Self-Trade Prevention)

自成交预防采用**跳过策略**：当 incoming 订单在遍历对手方时遇到同一 user_id 的挂单，直接跳过该挂单继续匹配下一个。

```
场景示例:
──────────

  Asks (Sell 侧):
    [User-A Sell @ 60, User-B Sell @ 62, User-A Sell @ 65]

  Incoming: User-A Buy @ 63

  匹配过程:
    @ 60: User-A ← 自成交, 跳过 ✗
    @ 62: User-B ← 成交 ✓ (trade_price = 62)
    @ 65: 65 > 63, 停止

  结果: 仅与 User-B 成交, User-A @ 60 的挂单保留在簿中
```

**设计选择**: 跳过策略（而非取消策略）保留了 Maker 的挂单，不会因为自己的新订单而丢失已有挂单。这与 Kalshi 的行为一致。

---

## 第六部分：四种撮合场景执行

> 四种场景由 `determine_scenario()` 判定后，清算模块按场景分别执行资金/持仓/Reserve/pnl_pool 的更新。
> 以下伪代码在**同一个 DB 事务**内执行，由 per-market Lock 保护。

### 6.1 场景总览

```
┌──────────────┬──────────────────────────────┬─────────────────────────────────┐
│ 场景          │ 含义                         │ Reserve 变化                     │
├──────────────┼──────────────────────────────┼─────────────────────────────────┤
│ MINT         │ 铸造合约对 — 创建 YES + NO   │ +100 × qty (资金进入托管)        │
│ TRANSFER_YES │ YES 转手 — 卖方转让 YES 给买方│ 不变 (用户间直接转账)             │
│ TRANSFER_NO  │ NO 转手 — 卖方转让 NO 给买方  │ 不变 (用户间直接转账)             │
│ BURN         │ 销毁合约对 — 销毁 YES + NO   │ -100 × qty (资金从托管释放)      │
└──────────────┴──────────────────────────────┴─────────────────────────────────┘
```

### 6.2 MINT — 铸造合约对

**触发条件**: Buy 侧 = NATIVE_BUY (Buy YES), Sell 侧 = SYNTHETIC_SELL (Buy NO)

**本质**: 两个用户分别买入 YES 和 NO，系统创建一对新合约。双方的资金进入 Reserve 托管。

```python
async def execute_mint(
    trade: TradeResult, market: Market, db: AsyncSession
) -> None:
    """
    MINT 场景执行

    参与方:
      Buy 侧: NATIVE_BUY (用户 Buy YES @ trade_price)
      Sell 侧: SYNTHETIC_SELL (用户 Buy NO @ (100 - trade_price))

    资金流向:
      Buy 方冻结资金 → Reserve (YES 成本)
      Sell 方冻结资金 → Reserve (NO 成本)

    持仓变化:
      Buy 方: +YES 持仓
      Sell 方: +NO 持仓

    Reserve: +100 × qty (每对合约锁定 $1.00)
    pnl_pool: 不变 (新铸造无盈亏)
    """
    qty = trade.quantity
    yes_price = trade.trade_price           # YES 美分 (Maker 价格)
    no_price = 100 - yes_price              # NO 美分

    buy_user_id = trade.buy_order.user_id   # Buy YES 的用户
    sell_user_id = trade.sell_order.user_id  # Buy NO 的用户

    # ── 1. 资金: 双方冻结资金 → Reserve ──

    # Buy 方: 从 frozen_balance 扣除 (冻结时已预留)
    buy_cost = yes_price * qty
    await deduct_frozen_balance(buy_user_id, buy_cost, db)

    # Sell 方 (SYNTHETIC_SELL): 从 frozen_balance 扣除 NO 价格
    sell_cost = no_price * qty
    await deduct_frozen_balance(sell_user_id, sell_cost, db)

    # ⚠️ v1.2: 价格改善 + 手续费盈余退还已移至 §7.1 execute_clearing,
    # 在 collect_fees 之后统一执行 (需要 actual_maker_fee / actual_taker_fee)

    # ── 2. 持仓: 双方获得新持仓 ──

    # Buy 方获得 YES
    await update_position(
        user_id=buy_user_id,
        market_id=trade.buy_order.market_id if hasattr(trade, 'market_id') else market.id,
        yes_volume_delta=+qty,
        yes_cost_sum_delta=+buy_cost,
        db=db,
    )

    # Sell 方获得 NO
    await update_position(
        user_id=sell_user_id,
        market_id=market.id,
        no_volume_delta=+qty,
        no_cost_sum_delta=+sell_cost,
        db=db,
    )

    # ── 3. Reserve + 份数 ──
    total_reserve_in = qty * 100  # 每对 100 美分
    market.reserve_balance += total_reserve_in
    market.total_yes_shares += qty
    market.total_no_shares += qty
    # pnl_pool 不变

    # ── 4. SYSTEM_RESERVE ──
    # v1.1: 不再同步 UPDATE SYSTEM_RESERVE 物理行 (避免跨 market 行锁串行化)
    # ledger_entries 中的 MINT_RESERVE_IN 已在 §7.4 写入, 后台聚合任务据此更新 (见 §7.5)
```

### 6.3 TRANSFER_YES — YES 转手

**触发条件**: Buy 侧 = NATIVE_BUY (Buy YES), Sell 侧 = NATIVE_SELL (Sell YES)

**本质**: 已持有 YES 的卖方将持仓卖给买方。资金在用户间直接流转，Reserve 不变。

```python
async def execute_transfer_yes(
    trade: TradeResult, market: Market, db: AsyncSession
) -> ClearingResult:
    """
    TRANSFER_YES 场景执行

    参与方:
      Buy 侧: NATIVE_BUY (用户 Buy YES — 开仓)
      Sell 侧: NATIVE_SELL (用户 Sell YES — 平仓)

    资金流向:
      Buy 方冻结资金 → Sell 方 available_balance (直接转账)

    持仓变化:
      Buy 方: +YES 持仓 (开仓)
      Sell 方: -YES 持仓, -pending_sell (平仓)

    Reserve: 不变
    pnl_pool: -(卖方收入 - 卖方成本) = -(卖方 PnL)
    """
    qty = trade.quantity
    yes_price = trade.trade_price
    buy_user_id = trade.buy_order.user_id
    sell_user_id = trade.sell_order.user_id

    trade_value = yes_price * qty  # 成交金额

    # ── 1. 资金: Buy 方 → Sell 方 ──

    # Buy 方: 从 frozen_balance 扣除
    await deduct_frozen_balance(buy_user_id, trade_value, db)

    # Sell 方: 收入到 available_balance
    await add_available_balance(sell_user_id, trade_value, db)

    # ⚠️ v1.2: 退还已移至 §7.1 execute_clearing (collect_fees 之后)

    # ── 2. 持仓: Buy 方开仓, Sell 方平仓 ──

    # Buy 方获得 YES
    await update_position(
        user_id=buy_user_id,
        market_id=market.id,
        yes_volume_delta=+qty,
        yes_cost_sum_delta=+(yes_price * qty),
        db=db,
    )

    # Sell 方释放 YES (平仓)
    # ⚠️ P2-5: 必须先 calculate_released_cost 再 update_position
    #    released_cost 依赖 pre-update 的 volume 做加权计算
    sell_position = await get_position(sell_user_id, market.id, db)
    released_cost = calculate_released_cost(
        sell_position.yes_cost_sum,
        sell_position.yes_volume,
        qty,
    )
    await update_position(
        user_id=sell_user_id,
        market_id=market.id,
        yes_volume_delta=-qty,
        yes_cost_sum_delta=-released_cost,
        yes_pending_sell_delta=-qty,
        db=db,
    )

    # ── 3. pnl_pool 更新 ──
    seller_pnl = trade_value - released_cost  # 卖方盈亏
    market.pnl_pool -= seller_pnl
    # Reserve 不变, 份数不变

    # ── 4. realized_pnl ──
    # Buy 侧: 开仓, buy_realized_pnl = NULL
    # Sell 侧: 平仓, sell_realized_pnl = seller_pnl
    return ClearingResult(
        buy_realized_pnl=None,
        sell_realized_pnl=seller_pnl,
    )
```

### 6.4 TRANSFER_NO — NO 转手

**触发条件**: Buy 侧 = SYNTHETIC_BUY (Sell NO), Sell 侧 = SYNTHETIC_SELL (Buy NO)

**本质**: 已持有 NO 的卖方（通过 Sell NO → SYNTHETIC_BUY 转换）将 NO 持仓卖给买方（通过 Buy NO → SYNTHETIC_SELL 转换）。

```python
async def execute_transfer_no(
    trade: TradeResult, market: Market, db: AsyncSession
) -> ClearingResult:
    """
    TRANSFER_NO 场景执行

    ⚠️ 订单簿视角 vs 用户视角 对照:
      Buy 侧 (SYNTHETIC_BUY): 用户操作 = Sell NO → 他是 NO 的卖方 (平仓)
      Sell 侧 (SYNTHETIC_SELL): 用户操作 = Buy NO → 他是 NO 的买方 (开仓)

    资金流向:
      Buy NO 的用户 (Sell侧) 冻结资金 → Sell NO 的用户 (Buy侧) available_balance

    持仓变化:
      Buy 侧 (Sell NO): -NO 持仓, -pending_sell (平仓)
      Sell 侧 (Buy NO): +NO 持仓 (开仓)

    Reserve: 不变
    pnl_pool: -(NO卖方收入 - NO卖方成本) = -(Buy侧用户 PnL)
    """
    qty = trade.quantity
    yes_price = trade.trade_price     # YES 视角成交价
    no_price = 100 - yes_price        # NO 视角成交价

    # Buy 侧 (SYNTHETIC_BUY) = 用户 Sell NO → NO 的卖方
    no_seller_user_id = trade.buy_order.user_id
    # Sell 侧 (SYNTHETIC_SELL) = 用户 Buy NO → NO 的买方
    no_buyer_user_id = trade.sell_order.user_id

    trade_value = no_price * qty  # NO 视角的成交金额

    # ── 1. 资金 ──

    # NO 买方 (Sell侧): 从 frozen_balance 扣除 NO 价格
    await deduct_frozen_balance(no_buyer_user_id, trade_value, db)

    # NO 卖方 (Buy侧): 收入到 available_balance
    await add_available_balance(no_seller_user_id, trade_value, db)

    # ⚠️ v1.2: 退还已移至 §7.1 execute_clearing (collect_fees 之后)

    # ── 2. 持仓 ──

    # NO 卖方 (Buy侧, SYNTHETIC_BUY): 释放 NO 持仓
    # ⚠️ P2-5: 必须先 calculate_released_cost 再 update_position
    #    released_cost 依赖 pre-update 的 volume 做加权计算
    seller_position = await get_position(no_seller_user_id, market.id, db)
    released_cost = calculate_released_cost(
        seller_position.no_cost_sum,
        seller_position.no_volume,
        qty,
    )
    await update_position(
        user_id=no_seller_user_id,
        market_id=market.id,
        no_volume_delta=-qty,
        no_cost_sum_delta=-released_cost,
        no_pending_sell_delta=-qty,
        db=db,
    )

    # NO 买方 (Sell侧, SYNTHETIC_SELL): 获得 NO 持仓
    await update_position(
        user_id=no_buyer_user_id,
        market_id=market.id,
        no_volume_delta=+qty,
        no_cost_sum_delta=+(no_price * qty),
        db=db,
    )

    # ── 3. pnl_pool ──
    seller_pnl = trade_value - released_cost
    market.pnl_pool -= seller_pnl
    # Reserve 不变, 份数不变

    # ── 4. realized_pnl ──
    # Buy 侧 (NO卖方, 平仓): buy_realized_pnl = seller_pnl
    # Sell 侧 (NO买方, 开仓): sell_realized_pnl = NULL
    return ClearingResult(
        buy_realized_pnl=seller_pnl,
        sell_realized_pnl=None,
    )
```

### 6.5 BURN — 销毁合约对

**触发条件**: Buy 侧 = SYNTHETIC_BUY (Sell NO), Sell 侧 = NATIVE_SELL (Sell YES)

**本质**: 一个用户卖 YES + 一个用户卖 NO，系统销毁一对合约，从 Reserve 释放资金给双方。**双方都是平仓**。

```python
async def execute_burn(
    trade: TradeResult, market: Market, db: AsyncSession
) -> ClearingResult:
    """
    BURN 场景执行

    参与方:
      Buy 侧 (SYNTHETIC_BUY): 用户 Sell NO → 销毁 NO 持仓
      Sell 侧 (NATIVE_SELL):  用户 Sell YES → 销毁 YES 持仓

    资金流向:
      Reserve → Buy 侧 (NO卖方收入 = NO成交价 × qty)
      Reserve → Sell 侧 (YES卖方收入 = YES成交价 × qty)
      合计: Reserve 释放 100 × qty (每对 $1.00)

    持仓变化:
      Buy 侧: -NO 持仓, -pending_sell (平仓)
      Sell 侧: -YES 持仓, -pending_sell (平仓)

    Reserve: -100 × qty
    pnl_pool: 调整以维持恒等式 (见下)
    """
    qty = trade.quantity
    yes_price = trade.trade_price
    no_price = 100 - yes_price

    no_seller_user_id = trade.buy_order.user_id    # SYNTHETIC_BUY (Sell NO)
    yes_seller_user_id = trade.sell_order.user_id   # NATIVE_SELL (Sell YES)

    # ── 1. 持仓: 先计算成本, 再扣减持仓 ──
    # ⚠️ P2-5: 两处 calculate_released_cost 都必须在对应 update_position 之前调用

    # NO 卖方 (Buy侧): 释放 NO 持仓
    no_position = await get_position(no_seller_user_id, market.id, db)
    no_released_cost = calculate_released_cost(
        no_position.no_cost_sum,
        no_position.no_volume,
        qty,
    )
    await update_position(
        user_id=no_seller_user_id,
        market_id=market.id,
        no_volume_delta=-qty,
        no_cost_sum_delta=-no_released_cost,
        no_pending_sell_delta=-qty,
        db=db,
    )

    # YES 卖方 (Sell侧): 释放 YES 持仓
    yes_position = await get_position(yes_seller_user_id, market.id, db)
    yes_released_cost = calculate_released_cost(
        yes_position.yes_cost_sum,
        yes_position.yes_volume,
        qty,
    )
    await update_position(
        user_id=yes_seller_user_id,
        market_id=market.id,
        yes_volume_delta=-qty,
        yes_cost_sum_delta=-yes_released_cost,
        yes_pending_sell_delta=-qty,
        db=db,
    )

    # ── 2. 资金: Reserve → 双方 ──
    no_seller_revenue = no_price * qty
    yes_seller_revenue = yes_price * qty
    total_release = qty * 100  # no_revenue + yes_revenue = 100 * qty

    await add_available_balance(no_seller_user_id, no_seller_revenue, db)
    await add_available_balance(yes_seller_user_id, yes_seller_revenue, db)

    # ── 3. Reserve + 份数 + pnl_pool ──
    market.reserve_balance -= total_release
    market.total_yes_shares -= qty
    market.total_no_shares -= qty

    # pnl_pool 调整以维持恒等式: reserve + pnl_pool = Σ(cost_sum)
    # reserve 变化 = -total_release
    # cost_sum 变化 = -(no_released_cost + yes_released_cost)
    # 需要: reserve变化 + pnl_pool变化 = cost_sum变化
    # pnl_pool变化 = -cost_released + total_release
    cost_released = no_released_cost + yes_released_cost
    pnl_adjustment = total_release - cost_released
    market.pnl_pool -= pnl_adjustment

    # ── 4. SYSTEM_RESERVE ──
    # v1.1: 不再同步 UPDATE SYSTEM_RESERVE 物理行 (见 §7.5 延迟聚合)
    # ledger_entries 中的 BURN_RESERVE_OUT 已在 §7.4 写入

    # ── 5. realized_pnl: 双方都是平仓 ──
    buy_pnl = no_seller_revenue - no_released_cost
    sell_pnl = yes_seller_revenue - yes_released_cost

    return ClearingResult(
        buy_realized_pnl=buy_pnl,
        sell_realized_pnl=sell_pnl,
    )
```

### 6.6 成本释放计算

```python
def calculate_released_cost(
    cost_sum: int, volume: int, sell_qty: int
) -> int:
    """
    按比例释放成本 — 全仓位卖出时直接取 cost_sum 避免精度丢失

    设计原则 (DB v2.2 §1.1):
    - 使用 cost_sum (累计成本) 而非 avg_cost (平均成本)
    - 全仓位卖出 (sell_qty == volume) 时直接取 cost_sum, 零精度损失
    - 部分卖出时按比例: cost_sum * sell_qty // volume

    ⚠️ Dust 预防: 整数除法的截断误差在多次部分卖出后会累积。
    全仓位清零时不做除法, 直接拿走全部 cost_sum, 这是关键的精度保护。
    """
    assert volume > 0, "持仓为零时不应调用成本释放"
    assert sell_qty <= volume, "卖出量不得超过持仓量"

    if sell_qty == volume:
        # 全仓位卖出 — 零精度损失
        return cost_sum
    else:
        # 部分卖出 — 按比例 (截断向下, 残留成本略高, 保护系统)
        return (cost_sum * sell_qty) // volume
```

---

## 第七部分：清算流程

### 7.1 清算执行入口

```python
# pm_clearing/executor.py

@dataclass
class ClearingResult:
    """清算结果"""
    buy_realized_pnl: Optional[int] = None   # 买方 realized PnL (平仓时有值)
    sell_realized_pnl: Optional[int] = None  # 卖方 realized PnL (平仓时有值)


async def execute_clearing(
    trade: TradeResult, db: AsyncSession
) -> None:
    """
    清算执行入口 — 在同一 DB 事务内完成全部操作

    执行顺序:
    1. 场景结算 (资金划转 + 持仓更新 + Reserve/pnl_pool 调整)
    2. 手续费计算与扣除
    3. 价格改善 + 手续费盈余退还 (Maker + Taker 双侧)
    4. 写入成交记录 (trades 表)
    5. 写入流水记录 (ledger_entries 表)
    6. 持久化 market 变更

    ⚠️ v1.2 变更:
      - 移除 Step 3 (update_order_frozen): 订单表的 frozen_amount 更新
        统一由 finalize_order (§5.3) 在所有撮合结束后一次性执行,
        不在逐笔清算循环中重复 UPDATE。
      - refund 从 §6.x 场景函数移入此处 Step 3, 因为需要 actual fee 参数。
    """
    market = await get_market(trade.buy_order.market_id, db)

    # ── 1. 按场景执行结算 ──
    if trade.scenario == "MINT":
        clearing_result = await execute_mint(trade, market, db)
    elif trade.scenario == "TRANSFER_YES":
        clearing_result = await execute_transfer_yes(trade, market, db)
    elif trade.scenario == "TRANSFER_NO":
        clearing_result = await execute_transfer_no(trade, market, db)
    elif trade.scenario == "BURN":
        clearing_result = await execute_burn(trade, market, db)

    # ── 2. 手续费 ──
    maker_fee, taker_fee = calculate_fees(trade, market)
    await collect_fees(trade, maker_fee, taker_fee, db)

    # ── 3. 退还: 价格改善 + 手续费盈余 (Maker + Taker 双侧) ──
    await refund_price_improvement_and_fee_surplus(
        trade, maker_fee, taker_fee, market.taker_fee_bps, db
    )

    # ── 4. 写入 trades 表 ──
    await insert_trade_record(
        trade=trade,
        market=market,
        maker_fee=maker_fee,
        taker_fee=taker_fee,
        buy_realized_pnl=clearing_result.buy_realized_pnl,
        sell_realized_pnl=clearing_result.sell_realized_pnl,
        db=db,
    )

    # ── 5. 写入 ledger_entries (双侧 + 系统侧) ──
    await write_clearing_ledger_entries(trade, market, maker_fee, taker_fee, db)

    # ── 6. 持久化 market 变更 (reserve, pnl_pool, shares) ──
    await update_market_in_db(market, db)
```

### 7.2 手续费计算

```python
def calculate_fees(
    trade: TradeResult, market: Market
) -> tuple[int, int]:
    """
    手续费计算

    规则 (权威设计方案 §3.5):
    1. 公式: fee = (trade_value * fee_bps + 9999) // 10000 (向上取整)
    2. Maker 用 maker_fee_bps, Taker 用 taker_fee_bps
    3. ⚠️ Synthetic 订单使用 NO 价格 (用户实际成本), 非转换后的 YES 价格

    示例: Buy NO @ 5 × 100份 (转换为 Sell YES @ 95)
      trade_value = 5 × 100 = 500 美分 (用 NO 价格 5, 非 YES 价格 95)
      fee = (500 * 20 + 9999) // 10000 = 1 美分

    为什么: 用 YES 价格 95 计算会得到 (9500 * 20 + 9999) // 10000 = 19 美分,
    对于只花了 $5 的用户收 $0.19 手续费明显不合理。
    """
    qty = trade.quantity

    # 计算每方的 trade_value (基于用户实际支付的价格)
    def _get_user_price(book_order: BookOrder) -> int:
        """获取用户视角的价格"""
        if book_order.book_type in ("NATIVE_BUY", "NATIVE_SELL"):
            return trade.trade_price  # Native: 直接用 YES 成交价
        else:
            return 100 - trade.trade_price  # Synthetic: 用 NO 价格

    # Maker
    maker_order = (
        trade.buy_order
        if trade.maker_order_id == trade.buy_order.order_id
        else trade.sell_order
    )
    maker_price = _get_user_price(maker_order)
    maker_value = maker_price * qty
    maker_fee = (maker_value * market.maker_fee_bps + 9999) // 10000

    # Taker
    taker_order = (
        trade.buy_order
        if trade.taker_order_id == trade.buy_order.order_id
        else trade.sell_order
    )
    taker_price = _get_user_price(taker_order)
    taker_value = taker_price * qty
    taker_fee = (taker_value * market.taker_fee_bps + 9999) // 10000

    return maker_fee, taker_fee


async def collect_fees(
    trade: TradeResult,
    maker_fee: int,
    taker_fee: int,
    db: AsyncSession,
) -> None:
    """
    收取手续费 — 根据冻结类型选择扣费来源

    ⚠️ v1.1 P0-1 修复: 手续费扣除策略按 frozen_asset_type 区分:

    FUNDS 冻结 (开仓买单, NATIVE_BUY / SYNTHETIC_SELL):
      手续费从 frozen_balance 中扣除 (冻结时已预留 max_taker_fee)。
      成交后 frozen_balance 中仍有手续费缓冲, 直接 deduct_frozen_balance。
      剩余缓冲 (max_fee - actual_fee) 在 §7.3 refund_price_improvement_and_fee_surplus 中统一退还。

    SHARES 冻结 (平仓卖单, NATIVE_SELL / SYNTHETIC_BUY):
      成交时系统已将收入 (revenue) 打入用户 available_balance,
      手续费从 available_balance 中扣除, 不会出现 0 余额问题。
    """
    def _get_order_and_user(is_maker: bool):
        if is_maker:
            return (trade.buy_order if trade.maker_order_id == trade.buy_order.order_id
                    else trade.sell_order)
        else:
            return (trade.buy_order if trade.taker_order_id == trade.buy_order.order_id
                    else trade.sell_order)

    total_fee = 0

    for fee_amount, is_maker in [(maker_fee, True), (taker_fee, False)]:
        if fee_amount <= 0:
            continue

        order = _get_order_and_user(is_maker)

        if order.frozen_asset_type == "FUNDS":
            # 开仓买单: 从 frozen_balance 扣除 (已预冻结)
            await deduct_frozen_balance(order.user_id, fee_amount, db)
        else:
            # 平仓卖单: 从 available_balance 扣除 (刚收到的成交收入)
            await deduct_available_balance(order.user_id, fee_amount, db)

        total_fee += fee_amount

    # 手续费流水写入 ledger (不再同步 UPDATE PLATFORM_FEE 物理行)
    # PLATFORM_FEE 余额由后台定时聚合任务维护 (见 §7.5)
```

### 7.3 价格改善与手续费盈余退还

```python
async def refund_price_improvement_and_fee_surplus(
    trade: TradeResult,
    actual_maker_fee: int,
    actual_taker_fee: int,
    taker_fee_bps: int,
    db: AsyncSession,
) -> None:
    """
    统一退还: 同时处理 Maker 的手续费差额 和 Taker 的价格改善+手续费差额

    ⚠️ v1.2 重写: 旧版只处理 Taker, 遗漏了 Maker 的 fee_surplus。
    Maker 预冻结了 taker_fee_bps 级别的缓冲, 但实际只交 maker_fee_bps,
    差额如不退还将永久锁死在 frozen_balance 中。

    处理逻辑 (对买方和卖方各自):
      1. 跳过 SHARES 冻结的订单 (卖出持仓, 无需退资金)
      2. fee_surplus = max_fee(原始冻结) - actual_fee (Maker/Taker 各自的实际手续费)
      3. price_improvement = (original_price - actual_unit_price) × qty
         Maker: 恒为 0 (成交价 = Maker 的 book_price)
         Taker: ≥ 0 (成交价更优时有正值)
      4. total_refund = fee_surplus + price_improvement → unfreeze

    示例 (Maker):
      挂单 Buy YES @ 60 × 100, 冻结 = 6000 + max_fee(6000, 20bps)=12 → 6012
      成交时作为 Maker, maker_fee = (6000 * 10 + 9999) // 10000 = 6
      fee_surplus = 12 - 6 = 6, price_improvement = 0
      退还 6 美分 from frozen → available

    示例 (Taker):
      吃单 Buy YES @ 65 × 100, 冻结 = 6500 + max_fee(6500, 20bps)=13 → 6513
      实际成交 @ 60 × 100, taker_fee = (6500 * 20 + 9999) // 10000 = 13
      fee_surplus = 13 - 13 = 0, price_improvement = (65-60) × 100 = 500
      退还 500 美分 from frozen → available
    """
    for is_maker in [True, False]:
        # 确定该侧对应的 order
        if is_maker:
            order = (trade.buy_order
                     if trade.maker_order_id == trade.buy_order.order_id
                     else trade.sell_order)
        else:
            order = (trade.buy_order
                     if trade.taker_order_id == trade.buy_order.order_id
                     else trade.sell_order)

        # SHARES 冻结 (卖出持仓) 无需退还资金
        if order.frozen_asset_type != "FUNDS":
            continue

        actual_fee = actual_maker_fee if is_maker else actual_taker_fee

        # 1. 手续费差额: 预冻结的 max_fee (按 taker_fee_bps) - 实际收取的 fee
        max_fee_for_fill = _calc_max_fee(
            order.original_price * trade.quantity, taker_fee_bps
        )
        fee_surplus = max_fee_for_fill - actual_fee

        # 2. 价格改善 (仅 Taker 可能有; Maker 成交价 = 挂单价, 恒为 0)
        price_improvement = 0
        if not is_maker:
            if order.book_type == "NATIVE_BUY":
                actual_unit_price = trade.trade_price        # YES 成交价
            else:  # SYNTHETIC_SELL (Buy NO)
                actual_unit_price = 100 - trade.trade_price  # NO 成交价
            price_improvement = (order.original_price - actual_unit_price) * trade.quantity

        total_refund = price_improvement + fee_surplus
        if total_refund > 0:
            # frozen → available
            await unfreeze_funds(order.user_id, total_refund, db)
```

### 7.4 流水记录

```python
async def write_clearing_ledger_entries(
    trade: TradeResult,
    market: Market,
    maker_fee: int,
    taker_fee: int,
    db: AsyncSession,
) -> None:
    """
    按场景写入流水记录 — 遵循复式记账原则

    每笔用户侧流水都有对应的系统侧流水:
      MINT:     MINT_COST (用户, 负) ↔ MINT_RESERVE_IN (SYSTEM_RESERVE, 正)
      BURN:     BURN_REVENUE (用户, 正) ↔ BURN_RESERVE_OUT (SYSTEM_RESERVE, 负)
      TRANSFER: TRANSFER_PAYMENT (买方, 负) + TRANSFER_RECEIPT (卖方, 正)
      FEE:      FEE (用户, 负) ↔ FEE_REVENUE (PLATFORM_FEE, 正)
    """
    trade_ref_id = trade.trade_id if hasattr(trade, 'trade_id') else str(trade.buy_order.order_id)

    if trade.scenario == "MINT":
        # Buy 方 (Buy YES)
        await write_ledger(trade.buy_order.user_id, "MINT_COST",
                           -(trade.trade_price * trade.quantity),
                           "TRADE", trade_ref_id, db)
        # Sell 方 (Buy NO)
        no_cost = (100 - trade.trade_price) * trade.quantity
        await write_ledger(trade.sell_order.user_id, "MINT_COST",
                           -no_cost, "TRADE", trade_ref_id, db)
        # SYSTEM_RESERVE
        await write_ledger("SYSTEM_RESERVE", "MINT_RESERVE_IN",
                           +(trade.quantity * 100),
                           "TRADE", trade_ref_id, db)

    elif trade.scenario == "TRANSFER_YES":
        trade_value = trade.trade_price * trade.quantity
        await write_ledger(trade.buy_order.user_id, "TRANSFER_PAYMENT",
                           -trade_value, "TRADE", trade_ref_id, db)
        await write_ledger(trade.sell_order.user_id, "TRANSFER_RECEIPT",
                           +trade_value, "TRADE", trade_ref_id, db)

    elif trade.scenario == "TRANSFER_NO":
        no_value = (100 - trade.trade_price) * trade.quantity
        # Buy 侧 (SYNTHETIC_BUY = Sell NO 用户) 收款
        await write_ledger(trade.buy_order.user_id, "TRANSFER_RECEIPT",
                           +no_value, "TRADE", trade_ref_id, db)
        # Sell 侧 (SYNTHETIC_SELL = Buy NO 用户) 付款
        await write_ledger(trade.sell_order.user_id, "TRANSFER_PAYMENT",
                           -no_value, "TRADE", trade_ref_id, db)

    elif trade.scenario == "BURN":
        no_revenue = (100 - trade.trade_price) * trade.quantity
        yes_revenue = trade.trade_price * trade.quantity
        await write_ledger(trade.buy_order.user_id, "BURN_REVENUE",
                           +no_revenue, "TRADE", trade_ref_id, db)
        await write_ledger(trade.sell_order.user_id, "BURN_REVENUE",
                           +yes_revenue, "TRADE", trade_ref_id, db)
        await write_ledger("SYSTEM_RESERVE", "BURN_RESERVE_OUT",
                           -(trade.quantity * 100),
                           "TRADE", trade_ref_id, db)

    # 手续费流水 (所有场景通用)
    if maker_fee > 0:
        maker_uid = (trade.buy_order.user_id
                     if trade.maker_order_id == trade.buy_order.order_id
                     else trade.sell_order.user_id)
        await write_ledger(maker_uid, "FEE", -maker_fee, "TRADE", trade_ref_id, db)
    if taker_fee > 0:
        taker_uid = (trade.buy_order.user_id
                     if trade.taker_order_id == trade.buy_order.order_id
                     else trade.sell_order.user_id)
        await write_ledger(taker_uid, "FEE", -taker_fee, "TRADE", trade_ref_id, db)
    if maker_fee + taker_fee > 0:
        await write_ledger("PLATFORM_FEE", "FEE_REVENUE",
                           +(maker_fee + taker_fee),
                           "TRADE", trade_ref_id, db)
```

### 7.5 SYSTEM_RESERVE / PLATFORM_FEE 延迟聚合 (v1.1 新增)

> **v1.1 P1-3**: 核心交易事务中**不再**同步 UPDATE `SYSTEM_RESERVE` 和 `PLATFORM_FEE` 的 accounts 物理行。
> 这两个系统账户只有一行，所有 market 的交易都会竞争同一行的行锁，
> 导致 per-market asyncio.Lock 的并发设计在 DB 层退化为全局串行。

**策略: 只写 ledger, 延迟聚合物理行**

```
核心交易事务 (per-market Lock 内):
  ┌─────────────────────────────────────────────┐
  │ INSERT ledger_entries (MINT_RESERVE_IN,      │
  │        BURN_RESERVE_OUT, NETTING_RESERVE_OUT,│
  │        FEE_REVENUE 等)                       │
  │ ※ INSERT 无行锁竞争, 不同 market 并行写入   │
  └─────────────────────────────────────────────┘

后台聚合任务 (定时 / 事件驱动):
  ┌─────────────────────────────────────────────┐
  │ SELECT SUM(amount) FROM ledger_entries       │
  │   WHERE account_id IN ('SYSTEM_RESERVE',     │
  │         'PLATFORM_FEE')                      │
  │   AND NOT aggregated;                        │
  │                                              │
  │ UPDATE accounts SET available_balance = ...   │
  │   WHERE user_id IN ('SYSTEM_RESERVE',        │
  │         'PLATFORM_FEE');                     │
  │                                              │
  │ UPDATE ledger_entries SET aggregated = TRUE   │
  │   WHERE id IN (...);                         │
  └─────────────────────────────────────────────┘
```

**设计要点**:

1. **ledger_entries 是 Source of Truth**: `SYSTEM_RESERVE` / `PLATFORM_FEE` 的真实余额 = `SUM(ledger_entries.amount)`，物理行只是缓存
2. **恒等式校验不受影响**: §11 中的恒等式查询 `SUM(ledger_entries)` 而非 `accounts.available_balance`，因此聚合延迟不影响校验准确性
3. **聚合频率**: MVP 阶段可每 5-10 秒执行一次，或在每个事务 commit 后异步触发
4. **幂等性**: 使用 `aggregated` 标记防止重复聚合；聚合任务本身也用 `SELECT ... FOR UPDATE` 保证原子性

> **对齐**: §1.2 前提设定 #11、DB v2.2 ledger_entries 表

---

## 第八部分：自动净额结算 (Auto-Netting)

### 8.1 设计原则

> 对齐 Kalshi: 用户**永远不会同时持有 YES 和 NO**。任何成交产生新持仓后，如果检测到同时持有 YES 和 NO，立即在**同一事务内**执行净额结算。

- **触发时机**: 每笔成交后检查所有相关用户
- **执行位置**: 在撮合事务内 (Step 7)，位于清算之后、事务提交之前
- **费用**: 不收手续费（Kalshi 规则，净额结算是后台会计操作）
- **排除冻结**: 已被卖单冻结的持仓不参与净额结算

### 8.2 净额结算执行

```python
# pm_account/netting.py

async def execute_netting_if_needed(
    user_id: str, market_id: str, db: AsyncSession
) -> Optional[NettingResult]:
    """
    账户层净额结算 — 成交事务内同步执行

    检查用户是否同时持有 YES 和 NO, 如果是:
    1. 计算可净额数量 (排除 pending_sell)
    2. 按比例释放双方成本
    3. 销毁合约对, Reserve 释放
    4. 调整 pnl_pool 维持恒等式
    5. 释放资金给用户

    ⚠️ 此函数在交易事务内调用, 共享事务上下文和 per-market Lock
    """
    position = await get_position(user_id, market_id, db)

    # 检查是否需要净额结算
    if position.yes_volume <= 0 or position.no_volume <= 0:
        return None  # 无需处理

    # 计算可净额数量 (排除已被卖单冻结的部分)
    available_yes = position.yes_volume - position.yes_pending_sell
    available_no = position.no_volume - position.no_pending_sell
    netting_qty = min(available_yes, available_no)

    if netting_qty <= 0:
        return None  # 全部被冻结, 无法净额

    market = await get_market(market_id, db)

    # ── 1. 计算双方成本 ──
    yes_released_cost = calculate_released_cost(
        position.yes_cost_sum, position.yes_volume, netting_qty
    )
    no_released_cost = calculate_released_cost(
        position.no_cost_sum, position.no_volume, netting_qty
    )

    # ── 2. 销毁持仓 ──
    await update_position(
        user_id=user_id,
        market_id=market_id,
        yes_volume_delta=-netting_qty,
        yes_cost_sum_delta=-yes_released_cost,
        no_volume_delta=-netting_qty,
        no_cost_sum_delta=-no_released_cost,
        db=db,
    )

    # ── 3. Reserve 释放 ──
    release_amount = netting_qty * 100  # 每对 100 美分
    market.reserve_balance -= release_amount
    market.total_yes_shares -= netting_qty
    market.total_no_shares -= netting_qty

    # ── 4. pnl_pool 调整 ──
    # 恒等式: reserve + pnl_pool = Σ(cost_sum)
    # reserve 变化 = -release_amount
    # cost_sum 变化 = -(yes_released_cost + no_released_cost)
    # pnl_pool 变化 = cost_sum变化 - reserve变化
    #                = -(yes + no) - (-release)
    #                = release - (yes + no)
    cost_released = yes_released_cost + no_released_cost
    pnl_adjustment = release_amount - cost_released
    market.pnl_pool -= pnl_adjustment

    # ── 5. 资金返还用户 ──
    await add_available_balance(user_id, release_amount, db)

    # ── 6. SYSTEM_RESERVE ──
    # v1.1: 不再同步 UPDATE SYSTEM_RESERVE 物理行 (见 §7.5 延迟聚合)

    # ── 7. 流水记录 ──
    await write_ledger(user_id, "NETTING", +release_amount,
                       "MARKET", market_id, db)
    await write_ledger("SYSTEM_RESERVE", "NETTING_RESERVE_OUT",
                       -release_amount, "MARKET", market_id, db)

    # ── 8. 持久化 market ──
    await update_market_in_db(market, db)

    return NettingResult(
        user_id=user_id,
        market_id=market_id,
        quantity=netting_qty,
        release_amount=release_amount,
        yes_released_cost=yes_released_cost,
        no_released_cost=no_released_cost,
    )
```

### 8.3 部分成交 + Netting 交互

> 关键规则：订单冻结金额与 Netting 释放资金是**两个独立的资金池**。

```
场景示例:
──────────
  初始状态:
    用户 A 持有 NO 100份, available_balance = 10000
    用户 A 提交: Buy YES @ 65 × 100份 (GTC)
    冻结: 65 × 100 = 6500 美分

  部分成交 50份 (Mint 场景):
    Step 1: Mint 结算 — A 支付 65 × 50 = 3250 → Reserve, 获得 YES 50份
    Step 2: 订单冻结更新 — frozen_amount: 6500 → 3250
    Step 3: Netting 检查 — yes=50, no=100, netting_qty=50
    Step 4: Netting 执行 — 销毁 YES 50 + NO 50, Release 5000 → A.available

  最终状态:
    用户 A: YES 0份, NO 50份
    frozen_amount: 3250 (订单剩余 50份)
    available_balance: 10000 - 6500 + 5000 = 8500
    订单: PARTIALLY_FILLED, remaining=50
```

---

## 第九部分：订单生命周期管理

### 9.1 状态机

> 对齐 DB v2.2 §2.4 订单状态机

```
NEW ──→ REJECTED        (风控不通过, 直接拒绝)
NEW ──→ OPEN            (风控通过, 未撮合或部分撮合后仍有剩余, 仅 GTC)
NEW ──→ FILLED          (风控通过, 全部立即成交)
NEW ──→ CANCELLED       (IOC 未成交或部分成交后剩余取消)
OPEN ─→ PARTIALLY_FILLED (部分成交)
OPEN ─→ FILLED          (全部成交)
OPEN ─→ CANCELLED       (用户主动取消)
PARTIALLY_FILLED ─→ FILLED    (剩余部分被成交)
PARTIALLY_FILLED ─→ CANCELLED (用户取消剩余部分)
```

### 9.2 订单取消

> 对齐 API v1.1 §5.2 — POST /api/v1/orders/{order_id}/cancel

```python
async def cancel_order(
    order_id: str, db: AsyncSession, orderbook: OrderBook
) -> bool:
    """
    取消订单 — 根据 frozen_asset_type 执行不同的解冻逻辑

    可取消状态: OPEN, PARTIALLY_FILLED
    不可取消状态: NEW, FILLED, CANCELLED, REJECTED
    """
    order = await get_order(order_id, db)

    if order.status not in ("OPEN", "PARTIALLY_FILLED"):
        raise OrderNotCancellableError(
            f"订单状态 {order.status} 不可取消"
        )

    remaining = order.remaining_quantity

    # ── 1. 解冻 ──
    if order.frozen_asset_type == "FUNDS":
        # 解冻资金: frozen → available
        frozen_remaining = order.frozen_amount
        await unfreeze_funds(order.user_id, frozen_remaining, db)

    elif order.frozen_asset_type == "YES_SHARES":
        # 解冻 YES 持仓
        await update_position(
            user_id=order.user_id,
            market_id=order.market_id,
            yes_pending_sell_delta=-remaining,
            db=db,
        )

    elif order.frozen_asset_type == "NO_SHARES":
        # 解冻 NO 持仓
        await update_position(
            user_id=order.user_id,
            market_id=order.market_id,
            no_pending_sell_delta=-remaining,
            db=db,
        )

    # ── 2. 从内存订单簿移除 ──
    orderbook.remove_order(str(order.id))

    # ── 3. 更新订单状态 ──
    order.status = "CANCELLED"
    order.frozen_amount = 0
    order.remaining_quantity = 0
    order.cancel_reason = "USER_CANCELLED"
    await update_order_in_db(order, db)

    # ── 4. 写入解冻流水 ──
    if order.frozen_asset_type == "FUNDS":
        await write_ledger(order.user_id, "ORDER_UNFREEZE",
                           +frozen_remaining, "ORDER", str(order.id), db)

    # ── 5. 卖单取消后检查 Netting ──
    # 解冻持仓后, 原本被冻结的份数现在可用了, 可能触发 Netting
    if order.frozen_asset_type in ("YES_SHARES", "NO_SHARES"):
        await execute_netting_if_needed(
            order.user_id, order.market_id, db
        )

    return True
```

---

## 第十部分：市场结算与退出

### 10.1 正常结算流程

> 市场到期后，由 Oracle/管理员提交裁决结果（YES 或 NO），触发结算。

```python
# pm_market/settlement.py

async def settle_market(
    market_id: str, outcome: str, db: AsyncSession
) -> None:
    """
    市场正常结算

    流程:
    1. 市场状态 → RESOLVED (停止交易)
    2. 取消所有活跃订单 (释放冻结)
    3. 遍历所有持仓, 赢家获得 100美分/份
    4. 验证 Reserve 清空
    5. 市场状态 → SETTLED

    结算规则:
      outcome = "YES": YES 持仓者每份获得 100 美分, NO 持仓归零
      outcome = "NO":  NO 持仓者每份获得 100 美分, YES 持仓归零
    """
    market = await get_market_with_lock(market_id, db)
    assert market.status in ("ACTIVE", "SUSPENDED", "HALTED")

    # ── Phase 1: 锁定市场 ──
    market.status = "RESOLVED"
    market.resolution_result = outcome
    market.resolved_at = utc_now()

    # ── Phase 2: 取消所有活跃订单 ──
    orderbook = engine._get_orderbook(market_id)
    active_orders = await get_active_orders(market_id, db)
    for order in active_orders:
        await cancel_order(str(order.id), db, orderbook)

    # ── Phase 3: 执行清算 ──
    total_payout = 0
    all_positions = await get_all_positions(market_id, db)

    for position in all_positions:
        if outcome == "YES":
            winning_shares = position.yes_volume
        else:  # NO
            winning_shares = position.no_volume

        if winning_shares > 0:
            payout = winning_shares * 100  # 每份 100 美分
            await add_available_balance(position.user_id, payout, db)
            total_payout += payout

            # 结算流水
            await write_ledger(
                position.user_id, "SETTLEMENT_PAYOUT",
                +payout, "MARKET", market_id, db
            )

        # 清空持仓 (但保留行, 不删除)
        await clear_position(position, db)

    # Reserve 释放到 SYSTEM_RESERVE
    await write_ledger(
        "SYSTEM_RESERVE", "BURN_RESERVE_OUT",
        -market.reserve_balance, "MARKET", market_id, db
    )

    # ── Phase 4: 验证 ──
    assert market.reserve_balance == total_payout, \
        f"Reserve 不匹配: reserve={market.reserve_balance}, payout={total_payout}"

    # ── Phase 5: 完成 ──
    market.reserve_balance = 0
    market.pnl_pool = 0
    market.total_yes_shares = 0
    market.total_no_shares = 0
    market.status = "SETTLED"
    market.settled_at = utc_now()

    await update_market_in_db(market, db)
```

### 10.2 市场作废 (VOID) 处理

> 异常情况下市场被取消，需按 cost_sum 比例退还用户资金。已收手续费不退还。

```python
async def void_market(
    market_id: str, reason: str, db: AsyncSession
) -> None:
    """
    市场作废退款 — 基于 cost_sum 和 pnl_pool 的精确退款

    设计要点:
    - 已收手续费不退还 (Kalshi 规则)
    - 先强制净额结算, 再按 cost_sum 比例分配剩余资金
    - 最后一位用户拿走剩余全部 (消除截断误差)
    """
    market = await get_market_with_lock(market_id, db)

    # ── Phase 1: 取消所有活跃订单 ──
    orderbook = engine._get_orderbook(market_id)
    active_orders = await get_active_orders(market_id, db)
    for order in active_orders:
        await cancel_order(str(order.id), db, orderbook)

    # ── Phase 2: 强制净额结算 (无手续费) ──
    all_positions = await get_all_positions(market_id, db)
    for position in all_positions:
        netting_qty = min(position.yes_volume, position.no_volume)
        if netting_qty > 0:
            yes_cost = calculate_released_cost(
                position.yes_cost_sum, position.yes_volume, netting_qty
            )
            no_cost = calculate_released_cost(
                position.no_cost_sum, position.no_volume, netting_qty
            )

            await update_position(
                user_id=position.user_id,
                market_id=market_id,
                yes_volume_delta=-netting_qty,
                yes_cost_sum_delta=-yes_cost,
                no_volume_delta=-netting_qty,
                no_cost_sum_delta=-no_cost,
                db=db,
            )

            netting_refund = netting_qty * 100
            await add_available_balance(position.user_id, netting_refund, db)
            market.reserve_balance -= netting_refund

    # ── Phase 3: 单边持仓按成本比例退款 ──
    available_funds = market.reserve_balance + market.pnl_pool

    # 重新加载持仓 (净额后可能有变化)
    all_positions = await get_all_positions(market_id, db)
    total_cost = sum(
        p.yes_cost_sum + p.no_cost_sum for p in all_positions
    )

    if total_cost > 0 and available_funds > 0:
        total_refunded = 0
        positions_list = list(all_positions)

        for i, position in enumerate(positions_list):
            user_cost = position.yes_cost_sum + position.no_cost_sum

            if user_cost > 0:
                if i == len(positions_list) - 1:
                    # 最后一位: 拿走剩余全部 (消除截断误差)
                    refund = available_funds - total_refunded
                else:
                    refund = (user_cost * available_funds) // total_cost

                if refund > 0:
                    await add_available_balance(position.user_id, refund, db)
                    total_refunded += refund

                    await write_ledger(
                        position.user_id, "SETTLEMENT_VOID",
                        +refund, "MARKET", market_id, db
                    )

            await clear_position(position, db)

    # ── Phase 4: 关闭市场 ──
    market.reserve_balance = 0
    market.pnl_pool = 0
    market.total_yes_shares = 0
    market.total_no_shares = 0
    market.status = "VOIDED"
    market.resolution_result = "VOID"
    market.settled_at = utc_now()

    await update_market_in_db(market, db)
```

---

## 第十一部分：恒等式与一致性校验

### 11.1 核心恒等式

> 系统必须在**每笔交易后**满足以下约束。任何恒等式失败应触发告警并暂停该市场。

| # | 恒等式 | 公式 | 校验时机 |
|---|--------|------|---------|
| 1 | 份数平衡 | `total_yes_shares == total_no_shares` | 每笔交易后 |
| 2 | 托管平衡 | `reserve_balance == total_yes_shares × 100` | 每笔交易后 |
| 3 | 成本守恒 | `reserve_balance + pnl_pool == Σ(用户 yes_cost_sum + no_cost_sum)` | 每笔交易后 |
| 4 | 余额非负 | `available_balance >= 0` 且 `frozen_balance >= 0` | 每次操作后 |
| 5 | 持仓非负 | `volume >= pending_sell >= 0` | 每次操作后 |
| 6 | 价格边界 | `1 <= price <= 99` | 多层校验 |
| 7 | 净额完成 | `NOT (yes_volume > 0 AND no_volume > 0)` (排除 pending_sell 锁定) | 每笔交易后 (软约束) |
| 8 | 订单转换一致 | Synthetic: `book_price == 100 - original_price` | 订单创建时 |
| 9 | 全局零和 | `Σ(用户 available + frozen) + SYSTEM_RESERVE + PLATFORM_FEE == Σ(deposits) - Σ(withdrawals)` | 定期对账 |

### 11.2 校验执行

```python
async def verify_invariants_after_trade(
    market_id: str, db: AsyncSession
) -> None:
    """
    交易后恒等式校验 — 在事务提交前执行

    任何断言失败都应:
    1. 记录详细上下文到日志
    2. 触发告警
    3. 回滚事务 (自动, 因为是同一事务)
    4. 市场状态 → HALTED (后续人工排查)
    """
    market = await get_market(market_id, db)

    # 恒等式 1: 份数平衡
    assert market.total_yes_shares == market.total_no_shares, \
        f"[INV-1] 份数不平衡: YES={market.total_yes_shares}, NO={market.total_no_shares}"

    # 恒等式 2: 托管平衡
    expected_reserve = market.total_yes_shares * 100
    assert market.reserve_balance == expected_reserve, \
        f"[INV-2] Reserve 不匹配: actual={market.reserve_balance}, expected={expected_reserve}"

    # 恒等式 3: 成本守恒
    all_positions = await get_all_positions(market_id, db)
    total_cost_sum = sum(
        p.yes_cost_sum + p.no_cost_sum for p in all_positions
    )
    assert market.reserve_balance + market.pnl_pool == total_cost_sum, \
        f"[INV-3] 成本不守恒: reserve({market.reserve_balance}) + pnl_pool({market.pnl_pool}) " \
        f"= {market.reserve_balance + market.pnl_pool}, Σcost_sum = {total_cost_sum}"

    # 恒等式 7: 净额完成 (软约束, 只告警不阻断)
    for p in all_positions:
        available_yes = p.yes_volume - p.yes_pending_sell
        available_no = p.no_volume - p.no_pending_sell
        if available_yes > 0 and available_no > 0:
            log_warning(
                f"[INV-7] 用户 {p.user_id} 仍同时持有可用 YES({available_yes}) "
                f"和 NO({available_no}), 应已被 Netting 清除"
            )
```

### 11.3 定期对账

```sql
-- ═══════════════════════════════════════════════════════════════
-- 恒等式 1+2: 份数平衡 + 托管平衡 (per market)
-- ═══════════════════════════════════════════════════════════════
SELECT id, total_yes_shares, total_no_shares, reserve_balance,
       total_yes_shares * 100 AS expected_reserve,
       CASE WHEN total_yes_shares != total_no_shares THEN 'FAIL-INV1'
            WHEN reserve_balance != total_yes_shares * 100 THEN 'FAIL-INV2'
            ELSE 'OK'
       END AS check_result
FROM markets
WHERE status IN ('ACTIVE', 'SUSPENDED');

-- ═══════════════════════════════════════════════════════════════
-- 恒等式 3: 成本守恒 (per market)
-- ═══════════════════════════════════════════════════════════════
SELECT m.id,
       m.reserve_balance + m.pnl_pool AS left_side,
       COALESCE(SUM(p.yes_cost_sum + p.no_cost_sum), 0) AS right_side,
       CASE WHEN m.reserve_balance + m.pnl_pool
                != COALESCE(SUM(p.yes_cost_sum + p.no_cost_sum), 0)
            THEN 'FAIL-INV3'
            ELSE 'OK'
       END AS check_result
FROM markets m
LEFT JOIN positions p ON p.market_id = m.id
WHERE m.status IN ('ACTIVE', 'SUSPENDED')
GROUP BY m.id, m.reserve_balance, m.pnl_pool;

-- ═══════════════════════════════════════════════════════════════
-- 恒等式 9: 全局零和
-- ═══════════════════════════════════════════════════════════════
SELECT
    (SELECT SUM(available_balance + frozen_balance) FROM accounts) AS total_in_system,
    (SELECT SUM(amount) FROM ledger_entries WHERE entry_type = 'DEPOSIT') AS total_deposits,
    (SELECT ABS(SUM(amount)) FROM ledger_entries WHERE entry_type = 'WITHDRAW') AS total_withdrawals,
    CASE WHEN (SELECT SUM(available_balance + frozen_balance) FROM accounts)
            != (SELECT COALESCE(SUM(amount), 0) FROM ledger_entries WHERE entry_type = 'DEPOSIT')
              - (SELECT COALESCE(ABS(SUM(amount)), 0) FROM ledger_entries WHERE entry_type = 'WITHDRAW')
         THEN 'FAIL-INV9'
         ELSE 'OK'
    END AS check_result;
```

---

## 附录

### 附录 A：WAL / 熔断 / 故障恢复（后续文档规划）

以下内容将在第四文档《运维与可靠性设计》中详细描述：

| 主题 | 简要说明 | 优先级 |
|------|---------|--------|
| WAL 预写日志 | 每次状态变更写入 WAL，支持 Event Sourcing + Deterministic Replay | P5 |
| 状态快照 | 定期序列化内存订单簿状态，加速恢复 | P5 |
| 故障恢复 | 加载快照 + 重放 WAL → 验证恒等式 → 恢复服务 | P5 |
| 熔断机制 | 恒等式校验失败时自动暂停市场 (status → HALTED) | P5 |
| 监控告警 | 恒等式校验结果、撮合延迟、订单队列深度 | P5 |

### 附录 B：术语对照表

| 本文档术语 | 权威设计方案 | exchange-core | 说明 |
|-----------|-------------|---------------|------|
| BookOrder | Order (in orderbook) | GtcOrder | 内存订单簿中的挂单 |
| OrderBook | OrderBook | OrderBook | 单一 YES 订单簿 |
| book_type | order_type | — | 订单簿身份标记 |
| NATIVE_BUY | NATIVE_BUY | — | 用户 Buy YES |
| SYNTHETIC_SELL | SYNTHETIC_SELL | — | 用户 Buy NO → Sell YES |
| SYNTHETIC_BUY | SYNTHETIC_BUY | — | 用户 Sell NO → Buy YES |
| NATIVE_SELL | NATIVE_SELL | — | 用户 Sell YES |
| cost_sum | cost_sum | openPriceSum | 累计成本 |
| pending_sell | pending_sell | pendingSellSize | 卖单冻结数 |
| pnl_pool | pnl_pool | — | 盈亏池 |

### 附录 C：跨文档引用

| 引用内容 | 所在文档 | 章节 |
|---------|---------|------|
| 表结构 DDL + CHECK 约束 | DB v2.2 | §2.1–§2.7 |
| 四种场景判定矩阵 | DB v2.2 | §2.5 |
| realized_pnl 场景适用性 | DB v2.2 | §2.5 |
| 枚举值定义 | DB v2.2 | §4.1 |
| 下单 API 请求/响应格式 | API v1.1 | §5.1 |
| 取消订单 API | API v1.1 | §5.2 |
| 订单簿深度 API + NO 视角转换 | API v1.1 | §4.3 |
| 成交历史 API + realized_pnl 字段 | API v1.1 | §5.4, §7.1 |

### 附录 D：版本历史

| 版本 | 日期 | 主要变更 |
|------|------|---------|
| v1.0 | 2026-02-20 | 初始版本，基于权威设计方案 v1 + DB v2.2 + API v1.1 编写 |
| v1.1 | 2026-02-20 | **P0-1**: 手续费预冻结 — FUNDS 冻结额包含 max_taker_fee，清算时从 frozen_balance 扣费，新增 `refund_price_improvement_and_fee_surplus` 统一退还。**P0-2**: O(1) 定长数组订单簿 — 替换 dict+sorted 为 array[100]+cursor。**P1-3**: SYSTEM_RESERVE 延迟聚合 — 核心事务只写 ledger_entries，系统账户物理行由后台聚合。**P1-4**: 内存 frozen_amount 同步 — 每笔 fill 后调用 `_sync_frozen_amount`。**P2-5**: 成本释放顺序注释。 |
| v1.2 | 2026-02-20 | **P0-1**: Maker 手续费差额退还 — `refund_price_improvement_and_fee_surplus` 重写为双侧 (Maker+Taker) 循环, 防止 Maker 的 fee_surplus 永久锁死。**P0-2**: `_sync_frozen_amount` 改用覆盖赋值 — 基于 `remaining_qty` 重算, 避免减法导致手续费截断误差累积引发超额解冻。**P1-3**: 删除 `update_order_frozen` — 订单表冻结更新统一由 `finalize_order` 执行, 不在逐笔清算中重复 UPDATE。**联动**: refund 调用从 §6.x 场景函数移至 §7.1 清算入口 (依赖 actual fee 参数)。 |

---

*文档结束*
