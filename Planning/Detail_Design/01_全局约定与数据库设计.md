# 文档 1：全局约定与数据库设计

> **版本**: v2.3 — 单账本撮合引擎架构
> **状态**: 草稿（待 Review）
> **适用范围**: Phase 1 MVP，所有模块开发时必须参考本文档
> **核心原则**: 全局整数化（美分制）、单账本撮合（单一 YES 订单簿 + 四种场景）、Append-Only 流水、按市场分片锁
> **对齐文档**: 《单账本撮合引擎设计方案 v1》、《完整实施计划 v4.1》
> **日期**: 2026-02-20

---

## 第一部分：全局约定

### 1.1 整数化规则（美分制）

全系统所有金额、价格字段**禁止**使用 `float`、`Decimal`、`NUMERIC`。

| 概念 | 单位 | 类型 (Python) | 类型 (PostgreSQL) | 取值范围 | 示例 |
|------|------|---------------|-------------------|----------|------|
| 价格 | 美分 | `int` | `SMALLINT` | [1, 99] | 60 = $0.60 |
| 数量 | 合约份数 | `int` | `INT` | [1, ∞) | 100 份 |
| 金额 | 美分 | `int` | `BIGINT` | (-∞, ∞) | 6000 = $60.00 |
| 余额 | 美分 | `int` | `BIGINT` | [0, ∞) | 1000000 = $10,000.00 |
| 成本 | 美分 | `int` | `BIGINT` | [0, ∞) | 累计成本 cost_sum，**不使用** avg_cost |
| 手续费率 | 基点 (bps) | `int` | `SMALLINT` | [0, 10000] | 20 = 0.20% |

**换算公式（仅在 API 序列化层使用）**:
```
显示金额 = cents / 100          # 6000 → "$60.00"
手续费 = (amount * fee_bps + 9999) // 10000  # 向上取整，保证平台不亏
```

**为什么用 `cost_sum` 而非 `avg_cost`**: 假设 3 份合约总成本 100 美分，`avg_cost = 100 // 3 = 33`，精度丢失 1 美分。累积下来会破坏恒等式。`cost_sum` 直接存累计值，零精度损失。

### 1.2 主键策略

| 表 | 主键类型 | 生成方式 | 理由 |
|----|----------|----------|------|
| users | `UUID` | `gen_random_uuid()` | 防止 ID 枚举 |
| accounts | `UUID` | `gen_random_uuid()` | 与 users 一致 |
| orders | `UUID` | `gen_random_uuid()` | 对外暴露，防枚举 |
| trades | `UUID` | `gen_random_uuid()` | 对外暴露，防枚举 |
| positions | `UUID` | `gen_random_uuid()` | 与其他表一致 |
| ledger_entries | `BIGSERIAL` | 自增 | Append-Only，顺序写入性能最优 |
| markets | `VARCHAR(64)` | 业务自定义 | 可读 ID 如 `MKT-BTC-100K-2026` |

### 1.3 时间字段约定

- 所有时间字段使用 `TIMESTAMPTZ`（带时区），存储 UTC
- `created_at`: 插入时自动填充 `NOW()`，永不修改
- `updated_at`: 每次 UPDATE 时自动更新（通过触发器）
- Python 侧使用 `datetime.datetime`（timezone-aware, UTC）

### 1.4 字符串枚举约定

MVP 阶段使用 `VARCHAR` + `CHECK` 约束存储枚举，不使用 PostgreSQL `ENUM` 类型。

理由：`ALTER TYPE ... ADD VALUE` 在事务中不可回滚，Alembic 迁移容易出问题。`VARCHAR` + `CHECK` 更灵活。

### 1.5 外键策略

MVP 阶段**不使用数据库级外键约束**。

理由：
- 中期微服务拆分后，跨服务表无法维持 FK
- FK 的 INSERT 检查在高频写入时有性能开销
- 数据完整性通过**应用层校验 + 集成测试**保证

在代码注释和本文档中标注逻辑外键关系，供理解数据模型用。

### 1.6 软删除约定

MVP 阶段**不使用软删除**。

- `orders` 通过 `status = CANCELLED` 表示取消，行不删除
- `ledger_entries` 是 Append-Only，永不删除
- `accounts` / `positions` 永不删除（量为 0 时保留行）

### 1.7 并发控制约定

MVP 采用**按市场分片锁 + PostgreSQL 原子操作**双重保护：

- **分片锁**: 每个 `market_id` 一把 `asyncio.Lock`，保护该话题的撮合全链路
- **账户余额**: 使用 PostgreSQL 原子 SQL 操作，**不经过 Redis**

```sql
-- 冻结余额（原子操作，余额不足则 RETURNING 空行）
UPDATE accounts
SET available_balance = available_balance - :amount,
    frozen_balance = frozen_balance + :amount,
    version = version + 1,
    updated_at = NOW()
WHERE user_id = :user_id AND available_balance >= :amount
RETURNING *;
```

需要乐观锁的表使用 `version BIGINT DEFAULT 0` 字段。

---

## 第二部分：数据库表设计

### 2.0 前置：公共函数和触发器

```sql
-- ============================================================
-- 公共: updated_at 自动更新触发器函数
-- ============================================================
CREATE OR REPLACE FUNCTION fn_update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

### 2.1 users — 用户表

**业务含义**: 平台上的一个注册用户。
**所属模块**: pm_gateway
**用途**: 用户注册、登录认证。

```sql
-- ============================================================
-- 表: users
-- 模块: pm_gateway
-- 说明: 用户账号，注册/登录用
-- ============================================================
CREATE TABLE users (
    -- 主键
    id              UUID            PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 登录凭证
    username        VARCHAR(64)     NOT NULL,
    email           VARCHAR(255)    NOT NULL,
    password_hash   VARCHAR(255)    NOT NULL,       -- bcrypt hash

    -- 状态
    is_active       BOOLEAN         NOT NULL DEFAULT TRUE,

    -- 时间
    created_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT uq_users_username    UNIQUE (username),
    CONSTRAINT uq_users_email       UNIQUE (email),
    CONSTRAINT ck_users_username_len CHECK (LENGTH(username) >= 3)
);

-- 索引
CREATE INDEX idx_users_email ON users (email);

-- 触发器
CREATE TRIGGER trg_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

-- 列注释
COMMENT ON TABLE  users IS '用户表 — 注册/登录认证';
COMMENT ON COLUMN users.id IS '用户唯一标识 (UUID)';
COMMENT ON COLUMN users.username IS '用户名，唯一，3-64字符';
COMMENT ON COLUMN users.email IS '邮箱，唯一';
COMMENT ON COLUMN users.password_hash IS 'bcrypt 哈希后的密码';
COMMENT ON COLUMN users.is_active IS '账户是否激活';
```

---

### 2.2 accounts — 账户余额表

**业务含义**: 用户的钱包，记录当前能花多少钱、冻结了多少钱。每个用户注册时自动创建一个 account（1:1 关系）。另有两个特殊账户行：`SYSTEM_RESERVE`（全平台资金托管池）和 `PLATFORM_FEE`（平台手续费累计账户）。
**所属模块**: pm_account
**用途**: 记录用户可用余额和冻结余额，支撑风控检查和清算资金划转。
**并发安全**: 余额变更通过 PostgreSQL 原子 SQL 操作（`UPDATE ... WHERE available >= X RETURNING *`），**不使用 Redis 做余额缓存或冻结**，避免双写一致性问题。

```sql
-- ============================================================
-- 表: accounts
-- 模块: pm_account
-- 说明: 用户资金账户 (所有金额单位: 美分)
--       包含 SYSTEM_RESERVE 系统托管总池
--       包含 PLATFORM_FEE 平台手续费累计账户
-- ============================================================
CREATE TABLE accounts (
    -- 主键
    id                  UUID        PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 业务键: 与 users.id 一一对应, 或特殊账户标识
    user_id             VARCHAR(64) NOT NULL,

    -- 余额 (美分)
    available_balance   BIGINT      NOT NULL DEFAULT 0,    -- 可用余额
    frozen_balance      BIGINT      NOT NULL DEFAULT 0,    -- 下单冻结金额

    -- 并发控制
    version             BIGINT      NOT NULL DEFAULT 0,    -- 乐观锁版本号

    -- 时间
    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT uq_accounts_user_id          UNIQUE (user_id),
    CONSTRAINT ck_accounts_available_gte_0  CHECK (available_balance >= 0),
    CONSTRAINT ck_accounts_frozen_gte_0     CHECK (frozen_balance >= 0)
);

-- 触发器
CREATE TRIGGER trg_accounts_updated_at
    BEFORE UPDATE ON accounts
    FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

-- 列注释
COMMENT ON TABLE  accounts IS '用户资金账户 — 所有金额单位: 美分 (cents)';
COMMENT ON COLUMN accounts.user_id IS '用户标识, 或 SYSTEM_RESERVE / PLATFORM_FEE 表示系统特殊账户';
COMMENT ON COLUMN accounts.available_balance IS '可用余额 (美分), >= 0';
COMMENT ON COLUMN accounts.frozen_balance IS '冻结余额 (美分), >= 0. 下单时冻结, 成交/取消时释放';
COMMENT ON COLUMN accounts.version IS '乐观锁版本号, 每次 UPDATE +1, 防止并发余额问题';
```

**系统特殊账户**:
```sql
-- 种子数据: 系统特殊账户 (在 seed_data.py 中插入)
-- SYSTEM_RESERVE: 全平台资金托管总池，所有话题 reserve_balance 之和与此对应
INSERT INTO accounts (user_id, available_balance, frozen_balance)
VALUES ('SYSTEM_RESERVE', 0, 0);

-- PLATFORM_FEE: 平台手续费累计账户，参与全局零和校验
INSERT INTO accounts (user_id, available_balance, frozen_balance)
VALUES ('PLATFORM_FEE', 0, 0);
```

**说明**:
- `SYSTEM_RESERVE` 是全平台的资金托管总池，`available_balance = Σ(所有活跃话题 reserve_balance)`
- `PLATFORM_FEE` 累计收取的全部手续费
- 全局零和: `Σ(用户 available + frozen) + SYSTEM_RESERVE.available + PLATFORM_FEE.available = Σ(deposits) - Σ(withdrawals)`

---

### 2.3 markets — 预测话题表

**业务含义**: 一个预测话题，例如"BTC 年底能否突破 10 万美元"或"某场比赛谁赢"。每一行代表一个独立的预测话题，包含交易规则、风控参数、单账本托管状态（Reserve + pnl_pool），以及最终裁决结果。
**所属模块**: pm_market
**用途**: 存储预测话题的定义、交易规则和单账本托管状态。MVP 阶段由 seed 脚本从 JSON 导入。

```sql
-- ============================================================
-- 表: markets
-- 模块: pm_market
-- 说明: 预测话题定义、交易规则与单账本托管状态 (MVP 从 JSON seed)
-- ============================================================
CREATE TABLE markets (
    -- 主键: 业务可读 ID
    id                      VARCHAR(64)     PRIMARY KEY,

    -- 基本信息
    title                   VARCHAR(500)    NOT NULL,       -- 话题标题/问题
    description             TEXT,                           -- 详细描述
    category                VARCHAR(64),                    -- 分类 (如 crypto, politics, sports)

    -- 状态
    status                  VARCHAR(20)     NOT NULL DEFAULT 'DRAFT',

    -- 交易规则 (价格为美分)
    min_price_cents         SMALLINT        NOT NULL DEFAULT 1,     -- 最低价格 (美分)
    max_price_cents         SMALLINT        NOT NULL DEFAULT 99,    -- 最高价格 (美分)
    -- 风控规则
    max_order_quantity      INT             NOT NULL DEFAULT 10000, -- 单笔最大合约数
    max_position_per_user   INT             NOT NULL DEFAULT 25000, -- 单用户单市场最大持仓
    max_order_amount_cents  BIGINT          NOT NULL DEFAULT 1000000, -- 单笔最大金额 (美分, $10K)

    -- 手续费 (基点, 1 bps = 0.01%)
    maker_fee_bps           SMALLINT        NOT NULL DEFAULT 10,    -- maker 手续费率 0.10%
    taker_fee_bps           SMALLINT        NOT NULL DEFAULT 20,    -- taker 手续费率 0.20%

    -- 时间
    trading_start_at        TIMESTAMPTZ,                    -- 开始交易时间
    trading_end_at          TIMESTAMPTZ,                    -- 停止交易时间
    resolution_date         TIMESTAMPTZ,                    -- 预期裁决日期
    resolved_at             TIMESTAMPTZ,                    -- 实际裁决时间
    settled_at              TIMESTAMPTZ,                    -- 实际结算时间

    -- 裁决结果 (裁决后填入)
    resolution_result       VARCHAR(10),                    -- YES / NO / VOID

    -- ⭐ 单账本托管追踪 (核心字段)
    reserve_balance         BIGINT          NOT NULL DEFAULT 0,     -- 托管余额 (美分): Mint +100/份, Burn -100/份
    pnl_pool                BIGINT          NOT NULL DEFAULT 0,     -- 盈亏池 (美分, 可正可负): Transfer 场景盈亏沉淀
    total_yes_shares        BIGINT          NOT NULL DEFAULT 0,     -- YES 总份数: Mint +N, Burn/Netting -N
    total_no_shares         BIGINT          NOT NULL DEFAULT 0,     -- NO 总份数: Mint +N, Burn/Netting -N

    -- 审计
    created_at              TIMESTAMPTZ     NOT NULL DEFAULT NOW(),
    updated_at              TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT ck_markets_reserve_gte_0          CHECK (reserve_balance >= 0),
    CONSTRAINT ck_markets_yes_shares_gte_0       CHECK (total_yes_shares >= 0),
    CONSTRAINT ck_markets_no_shares_gte_0        CHECK (total_no_shares >= 0),
    CONSTRAINT ck_markets_shares_balanced        CHECK (total_yes_shares = total_no_shares),
    CONSTRAINT ck_markets_reserve_consistency    CHECK (reserve_balance = total_yes_shares * 100),
    CONSTRAINT ck_markets_status CHECK (
        status IN ('DRAFT', 'ACTIVE', 'SUSPENDED', 'HALTED', 'RESOLVED', 'SETTLED', 'VOIDED')
    ),
    CONSTRAINT ck_markets_price_range CHECK (
        min_price_cents >= 1 AND max_price_cents <= 99
        AND min_price_cents < max_price_cents
    ),
    CONSTRAINT ck_markets_fee CHECK (
        maker_fee_bps >= 0 AND maker_fee_bps <= 1000
        AND taker_fee_bps >= 0 AND taker_fee_bps <= 1000
    ),
    CONSTRAINT ck_markets_resolution CHECK (
        resolution_result IS NULL OR resolution_result IN ('YES', 'NO', 'VOID')
    )
);

-- 索引
CREATE INDEX idx_markets_status ON markets (status);

-- 触发器
CREATE TRIGGER trg_markets_updated_at
    BEFORE UPDATE ON markets
    FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

-- 列注释
COMMENT ON TABLE  markets IS '预测话题 — 交易规则/风控参数/单账本托管状态/裁决结果';
COMMENT ON COLUMN markets.id IS '话题 ID, 业务可读, 如 MKT-BTC-100K-2026';
COMMENT ON COLUMN markets.status IS '话题状态: DRAFT/ACTIVE/SUSPENDED/HALTED/RESOLVED/SETTLED/VOIDED';
COMMENT ON COLUMN markets.min_price_cents IS '最低可交易价格 (美分), 通常为 1';
COMMENT ON COLUMN markets.max_price_cents IS '最高可交易价格 (美分), 通常为 99';
COMMENT ON COLUMN markets.maker_fee_bps IS 'Maker 手续费率 (基点), 10 = 0.10%';
COMMENT ON COLUMN markets.taker_fee_bps IS 'Taker 手续费率 (基点), 20 = 0.20%';
COMMENT ON COLUMN markets.reserve_balance IS '话题级托管余额 (美分): Mint 时 +100/份, Burn/Netting 时 -100/份';
COMMENT ON COLUMN markets.pnl_pool IS '盈亏池 (美分, 可正可负): Transfer 场景中卖方盈亏沉淀, Netting 时调整. 恒等式: reserve_balance + pnl_pool = Σ(用户 cost_sum)';
COMMENT ON COLUMN markets.total_yes_shares IS 'YES 合约总份数, 恒等于 total_no_shares';
COMMENT ON COLUMN markets.total_no_shares IS 'NO 合约总份数, 恒等于 total_yes_shares';
COMMENT ON COLUMN markets.resolution_result IS '裁决结果: YES=YES方胜, NO=NO方胜, VOID=作废(全额退款)';
```

**话题状态机**:
```
DRAFT → ACTIVE → SUSPENDED → ACTIVE (可反复)
                    ↓
ACTIVE → HALTED (紧急停止, 人工干预)
                    ↓
ACTIVE → RESOLVED → SETTLED (正常结算)
ACTIVE → VOIDED (话题作废, 退款)
```

**单账本托管追踪说明**:
- `reserve_balance`: Mint 场景 +100×qty，Burn/Netting 场景 -100×qty，恒等于 `total_yes_shares × 100`
- `pnl_pool`: Transfer 场景中，卖方的盈亏（卖出收入 - 历史成本）沉淀于此；Netting 时释放资金与历史成本的差额也沉淀于此。可正可负
- 核心恒等式: `reserve_balance + pnl_pool = Σ(该话题所有用户的 yes_cost_sum + no_cost_sum)`

---

### 2.4 orders — 订单表

**业务含义**: 用户对某个预测话题的一次交易意向（挂单）。例如用户以 60 美分的价格买入 100 份 YES 合约。订单可能全部成交、部分成交或被取消。在单账本架构下，每笔订单同时记录用户的原始意图和订单簿视角的转换后参数。
**所属模块**: pm_order
**用途**: 记录用户的全部下单请求、单账本转换参数及冻结信息。

```sql
-- ============================================================
-- 表: orders
-- 模块: pm_order
-- 说明: 用户订单 — 单账本架构 (价格/金额单位: 美分)
--       同时记录用户原始意图 (original_*) 和订单簿视角 (book_*)
-- ============================================================
CREATE TABLE orders (
    -- 主键
    id                  UUID            PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 幂等键
    client_order_id     VARCHAR(64)     NOT NULL,

    -- 市场/用户
    market_id           VARCHAR(64)     NOT NULL,       -- → markets.id
    user_id             VARCHAR(64)     NOT NULL,       -- → users.id (UUID as string)

    -- ⭐ 用户原始意图 (用户界面上看到的)
    original_side       VARCHAR(10)     NOT NULL,       -- YES / NO (用户选择的合约方向)
    original_direction  VARCHAR(10)     NOT NULL,       -- BUY / SELL (用户选择的买卖方向)
    original_price      SMALLINT        NOT NULL,       -- 用户填写的价格 (1-99 美分)

    -- ⭐ 订单簿视角 (转换后, 撮合引擎使用)
    book_type           VARCHAR(20)     NOT NULL,       -- NATIVE_BUY / NATIVE_SELL / SYNTHETIC_BUY / SYNTHETIC_SELL
    book_direction      VARCHAR(10)     NOT NULL,       -- BUY / SELL (订单簿中的实际方向)
    book_price          SMALLINT        NOT NULL,       -- 订单簿中的价格 (1-99 美分)

    -- 定价类型
    price_type          VARCHAR(20)     NOT NULL DEFAULT 'LIMIT',  -- LIMIT (未来可扩展 MARKET)
    time_in_force       VARCHAR(10)     NOT NULL DEFAULT 'GTC',    -- GTC / IOC

    -- 数量
    quantity            INT             NOT NULL,       -- 原始下单数量 (合约份数)
    filled_quantity     INT             NOT NULL DEFAULT 0,     -- 已成交数量
    remaining_quantity  INT             NOT NULL,               -- 剩余待成交数量

    -- ⭐ 冻结 (撤单时根据 frozen_asset_type 解冻到对应账户)
    -- ⚠️ 关键规则: 发生部分成交时，必须在同一清算事务中按实际成交量扣减此冻结额。
    --    否则撤单时会超额解冻，导致凭空印钞漏洞。
    frozen_amount       BIGINT          NOT NULL DEFAULT 0,     -- 当前剩余冻结的资金(美分)或持仓(份数), 部分成交时同步扣减
    frozen_asset_type   VARCHAR(20)     NOT NULL,               -- FUNDS / YES_SHARES / NO_SHARES

    -- 状态
    status              VARCHAR(20)     NOT NULL DEFAULT 'NEW',
    cancel_reason       VARCHAR(100),                   -- 取消/拒绝原因

    -- 时间
    created_at          TIMESTAMPTZ     NOT NULL DEFAULT NOW(),
    updated_at          TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT uq_orders_client_order_id    UNIQUE (client_order_id),
    CONSTRAINT ck_orders_original_side      CHECK (original_side IN ('YES', 'NO')),
    CONSTRAINT ck_orders_original_direction CHECK (original_direction IN ('BUY', 'SELL')),
    CONSTRAINT ck_orders_original_price     CHECK (original_price BETWEEN 1 AND 99),
    CONSTRAINT ck_orders_book_type          CHECK (
        book_type IN ('NATIVE_BUY', 'NATIVE_SELL', 'SYNTHETIC_BUY', 'SYNTHETIC_SELL')
    ),
    CONSTRAINT ck_orders_book_direction     CHECK (book_direction IN ('BUY', 'SELL')),
    CONSTRAINT ck_orders_book_price         CHECK (book_price BETWEEN 1 AND 99),
    CONSTRAINT ck_orders_price_type         CHECK (price_type IN ('LIMIT')),
    CONSTRAINT ck_orders_tif                CHECK (time_in_force IN ('GTC', 'IOC')),
    CONSTRAINT ck_orders_quantity           CHECK (quantity > 0),
    CONSTRAINT ck_orders_filled             CHECK (filled_quantity >= 0 AND filled_quantity <= quantity),
    CONSTRAINT ck_orders_remaining          CHECK (remaining_quantity >= 0 AND remaining_quantity <= quantity),
    CONSTRAINT ck_orders_fill_consistency   CHECK (filled_quantity + remaining_quantity = quantity),
    CONSTRAINT ck_orders_frozen_amount_gte_0 CHECK (frozen_amount >= 0),
    CONSTRAINT ck_orders_frozen_asset_type  CHECK (frozen_asset_type IN ('FUNDS', 'YES_SHARES', 'NO_SHARES')),
    CONSTRAINT ck_orders_book_type_dir_match CHECK (
        (book_type IN ('NATIVE_BUY', 'SYNTHETIC_BUY') AND book_direction = 'BUY') OR
        (book_type IN ('NATIVE_SELL', 'SYNTHETIC_SELL') AND book_direction = 'SELL')
    ),
    CONSTRAINT ck_orders_status             CHECK (
        status IN ('NEW', 'OPEN', 'PARTIALLY_FILLED', 'FILLED', 'CANCELLED', 'REJECTED')
    )
);

-- 索引
-- 查询"我的订单列表": 用户+状态筛选, 时间倒序
CREATE INDEX idx_orders_user_status ON orders (user_id, status, created_at DESC);

-- 撮合恢复: 重启后加载某话题全部活跃订单到内存订单簿 (单一 YES 簿)
-- 对齐故障恢复设计 v1.1 §2.3: 按 created_at 排序保证时间优先重建
CREATE INDEX idx_orders_market_active ON orders (market_id, created_at)
    WHERE status IN ('OPEN', 'PARTIALLY_FILLED');

-- 自成交检查: 查同一话题同一用户的反向活跃订单
CREATE INDEX idx_orders_self_trade ON orders (market_id, user_id, book_direction)
    WHERE status IN ('OPEN', 'PARTIALLY_FILLED');

-- 触发器
CREATE TRIGGER trg_orders_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

-- 列注释
COMMENT ON TABLE  orders IS '用户订单 — 单账本架构, 同时记录原始意图和订单簿视角';
COMMENT ON COLUMN orders.client_order_id IS '客户端幂等键, 防止重复提交';
COMMENT ON COLUMN orders.original_side IS '用户选择的合约方向: YES 或 NO';
COMMENT ON COLUMN orders.original_direction IS '用户选择的买卖方向: BUY 或 SELL';
COMMENT ON COLUMN orders.original_price IS '用户填写的价格 (1-99 美分)';
COMMENT ON COLUMN orders.book_type IS '订单簿身份: NATIVE_BUY(买YES)/NATIVE_SELL(卖YES)/SYNTHETIC_BUY(卖NO→买YES)/SYNTHETIC_SELL(买NO→卖YES)';
COMMENT ON COLUMN orders.book_direction IS '订单簿中的实际方向: BUY(进入 bids) 或 SELL(进入 asks)';
COMMENT ON COLUMN orders.book_price IS '订单簿中的价格: Native 不变, Synthetic 转换为 100-original_price';
COMMENT ON COLUMN orders.price_type IS '定价类型: LIMIT (限价单)';
COMMENT ON COLUMN orders.frozen_amount IS '当前剩余冻结额: 资金(美分)或持仓(份数). 部分成交时必须在清算事务中同步扣减, 撤单时按剩余值解冻';
COMMENT ON COLUMN orders.frozen_asset_type IS '冻结资产类型: FUNDS(冻结资金)/YES_SHARES(冻结YES持仓)/NO_SHARES(冻结NO持仓), 撤单时据此调用对应解冻接口';
COMMENT ON COLUMN orders.status IS '订单状态: NEW→OPEN→PARTIALLY_FILLED→FILLED/CANCELLED, 或 NEW→REJECTED';
```

**订单转换规则** (NO 操作 → YES 订单簿):

| 用户操作 | book_type | book_direction | book_price | frozen_asset_type |
|---------|-----------|----------------|------------|-------------------|
| Buy YES @ P | NATIVE_BUY | BUY | P | FUNDS |
| Sell YES @ P | NATIVE_SELL | SELL | P | YES_SHARES |
| Buy NO @ P | SYNTHETIC_SELL | SELL | 100-P | FUNDS |
| Sell NO @ P | SYNTHETIC_BUY | BUY | 100-P | NO_SHARES |

**订单状态机**:
```
NEW ──→ REJECTED        (风控不通过, 直接拒绝)
NEW ──→ OPEN            (风控通过, 未撮合或部分撮合后仍有剩余)
NEW ──→ FILLED          (风控通过, 全部立即成交)
OPEN ─→ PARTIALLY_FILLED (部分成交)
OPEN ─→ FILLED          (全部成交)
OPEN ─→ CANCELLED       (用户主动取消)
PARTIALLY_FILLED ─→ FILLED    (剩余部分被成交)
PARTIALLY_FILLED ─→ CANCELLED (用户取消剩余部分)
```

---

### 2.5 trades — 成交记录表

**业务含义**: 两个对手方的订单在单一 YES 订单簿中配对成功后产生的成交记录。每笔成交有一个明确的撮合场景（Mint/Transfer YES/Transfer NO/Burn），决定了后续清算资金的流向。
**所属模块**: pm_clearing
**用途**: 记录撮合引擎产生的每一笔成交，含场景和双方 book_type。

```sql
-- ============================================================
-- 表: trades
-- 模块: pm_clearing
-- 说明: 撮合成交记录 — 单账本架构 (价格/金额单位: 美分)
-- ============================================================
CREATE TABLE trades (
    -- 主键
    id              UUID            PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 业务唯一标识 (由撮合引擎生成)
    trade_id        VARCHAR(64)     NOT NULL,

    -- 市场
    market_id       VARCHAR(64)     NOT NULL,       -- → markets.id

    -- ⭐ 撮合场景 (决定清算资金流向)
    scenario        VARCHAR(20)     NOT NULL,       -- MINT / TRANSFER_YES / TRANSFER_NO / BURN

    -- 参与方 (按订单簿方向: buy 侧 + sell 侧)
    buy_order_id    UUID            NOT NULL,       -- → orders.id (订单簿 BUY 侧)
    sell_order_id   UUID            NOT NULL,       -- → orders.id (订单簿 SELL 侧)
    buy_user_id     VARCHAR(64)     NOT NULL,       -- → users.id
    sell_user_id    VARCHAR(64)     NOT NULL,       -- → users.id
    buy_book_type   VARCHAR(20)     NOT NULL,       -- 买方的 book_type
    sell_book_type  VARCHAR(20)     NOT NULL,       -- 卖方的 book_type

    -- 成交参数 (YES 订单簿视角)
    price           SMALLINT        NOT NULL,       -- 成交价 (YES 美分, 取 maker 价)
    quantity        INT             NOT NULL,       -- 成交数量 (合约份数)

    -- Maker/Taker
    maker_order_id  UUID            NOT NULL,       -- → orders.id (挂单方, 其价格为成交价)
    taker_order_id  UUID            NOT NULL,       -- → orders.id (吃单方)

    -- 手续费 (美分, 清算时计算后回填)
    maker_fee       BIGINT          NOT NULL DEFAULT 0,
    taker_fee       BIGINT          NOT NULL DEFAULT 0,

    -- ⭐ 已实现盈亏 (美分, 清算时计算后持久化, 开仓方为 NULL)
    -- 计算公式 (平仓方): (成交价 × qty) - 按比例分摊的历史 cost_sum
    -- NULL = 不适用 (开仓操作), 0 = 平仓但盈亏恰好为零
    buy_realized_pnl  BIGINT        DEFAULT NULL,   -- 买方已实现盈亏 (TRANSFER_NO/BURN 时有值)
    sell_realized_pnl BIGINT        DEFAULT NULL,   -- 卖方已实现盈亏 (TRANSFER_YES/BURN 时有值)

    -- 时间
    executed_at     TIMESTAMPTZ     NOT NULL,       -- 撮合发生时间
    created_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT uq_trades_trade_id       UNIQUE (trade_id),
    CONSTRAINT ck_trades_scenario       CHECK (
        scenario IN ('MINT', 'TRANSFER_YES', 'TRANSFER_NO', 'BURN')
    ),
    CONSTRAINT ck_trades_buy_book_type  CHECK (
        buy_book_type IN ('NATIVE_BUY', 'SYNTHETIC_BUY')
    ),
    CONSTRAINT ck_trades_sell_book_type CHECK (
        sell_book_type IN ('NATIVE_SELL', 'SYNTHETIC_SELL')
    ),
    CONSTRAINT ck_trades_price          CHECK (price BETWEEN 1 AND 99),
    CONSTRAINT ck_trades_quantity       CHECK (quantity > 0),
    CONSTRAINT ck_trades_fee_gte_0      CHECK (maker_fee >= 0 AND taker_fee >= 0),
    CONSTRAINT ck_trades_diff_users     CHECK (buy_user_id != sell_user_id)
);

-- 索引
-- 用户查成交历史 (买方/卖方两个索引)
CREATE INDEX idx_trades_buy_user ON trades (buy_user_id, executed_at DESC);
CREATE INDEX idx_trades_sell_user ON trades (sell_user_id, executed_at DESC);

-- 话题维度: 行情聚合、K线生成 (中期用)
CREATE INDEX idx_trades_market_time ON trades (market_id, executed_at DESC);

-- 按场景统计 (对账用)
CREATE INDEX idx_trades_scenario ON trades (market_id, scenario);

-- 列注释
COMMENT ON TABLE  trades IS '撮合成交记录 — 单账本架构, 含撮合场景';
COMMENT ON COLUMN trades.trade_id IS '业务成交 ID, 由撮合引擎的 ID 生成器创建';
COMMENT ON COLUMN trades.scenario IS '撮合场景: MINT(铸造合约对)/TRANSFER_YES(YES转手)/TRANSFER_NO(NO转手)/BURN(销毁合约对)';
COMMENT ON COLUMN trades.buy_book_type IS '买方的订单簿身份: NATIVE_BUY 或 SYNTHETIC_BUY';
COMMENT ON COLUMN trades.sell_book_type IS '卖方的订单簿身份: NATIVE_SELL 或 SYNTHETIC_SELL';
COMMENT ON COLUMN trades.price IS '成交价格 (YES 美分), 取 maker 的挂单价';
COMMENT ON COLUMN trades.maker_fee IS 'Maker 手续费 (美分), Synthetic 用 NO 价格计算';
COMMENT ON COLUMN trades.taker_fee IS 'Taker 手续费 (美分), Synthetic 用 NO 价格计算';
COMMENT ON COLUMN trades.buy_realized_pnl IS '买方已实现盈亏 (美分): TRANSFER_NO/BURN 场景下买方平仓时由清算模块计算并持久化, 开仓时为 NULL';
COMMENT ON COLUMN trades.sell_realized_pnl IS '卖方已实现盈亏 (美分): TRANSFER_YES/BURN 场景下卖方平仓时由清算模块计算并持久化, 开仓时为 NULL';
```

**四种撮合场景判定矩阵**:
```
                    Sell 侧
              ┌────────────┬────────────┐
              │  NATIVE    │ SYNTHETIC  │
              │ (Sell YES) │ (Buy NO)   │
    ┌─────────┼────────────┼────────────┤
Buy │ NATIVE  │ Transfer   │   Mint     │
侧  │(Buy YES)│   YES      │  (铸造)    │
    ├─────────┼────────────┼────────────┤
    │SYNTHETIC│   Burn     │ Transfer   │
    │(Sell NO)│  (销毁)    │    NO      │
    └─────────┴────────────┴────────────┘
```

**各场景下 realized_pnl 适用性**:

| 场景 | Buy 侧行为 | buy_realized_pnl | Sell 侧行为 | sell_realized_pnl |
|------|-----------|-----------------|------------|------------------|
| MINT | Buy YES (开仓) | `NULL` | Buy NO (开仓) | `NULL` |
| TRANSFER_YES | Buy YES (开仓) | `NULL` | Sell YES (平仓) | `(YES成交价 × qty) - 释放的YES历史成本` |
| TRANSFER_NO | Sell NO (平仓) | `(NO成交价 × qty) - 释放的NO历史成本` | Buy NO (开仓) | `NULL` |
| BURN | Sell NO (平仓) | `(NO成交价 × qty) - 释放的NO历史成本` | Sell YES (平仓) | `(YES成交价 × qty) - 释放的YES历史成本` |

---

### 2.6 positions — 持仓表

**业务含义**: 用户在某个预测话题上持有的合约。单账本架构下，每用户每话题只有**一行记录**，同时包含 YES 和 NO 的持仓量、累计成本和卖单冻结数。例如用户在"BTC 破 10 万"话题上持有 200 份 YES + 50 份 NO，就是一行 position 记录。
**所属模块**: pm_account
**用途**: 记录用户在每个预测话题中 YES/NO 双边的持仓量、成本和冻结量。

```sql
-- ============================================================
-- 表: positions
-- 模块: pm_account
-- 说明: 用户持仓 — 单账本架构 (每用户每话题一行, YES/NO 合并)
-- ============================================================
CREATE TABLE positions (
    -- 主键
    id                  UUID        PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 业务键 (二元组唯一: 用户+话题)
    user_id             VARCHAR(64) NOT NULL,       -- → users.id
    market_id           VARCHAR(64) NOT NULL,       -- → markets.id

    -- ⭐ YES 持仓
    yes_volume          INT         NOT NULL DEFAULT 0,     -- YES 持有份数
    yes_cost_sum        BIGINT      NOT NULL DEFAULT 0,     -- YES 累计成本 (美分), 不使用 avg_cost
    yes_pending_sell    INT         NOT NULL DEFAULT 0,     -- YES 卖单冻结份数 (挂 Sell YES 单时增加)

    -- ⭐ NO 持仓
    no_volume           INT         NOT NULL DEFAULT 0,     -- NO 持有份数
    no_cost_sum         BIGINT      NOT NULL DEFAULT 0,     -- NO 累计成本 (美分), 不使用 avg_cost
    no_pending_sell     INT         NOT NULL DEFAULT 0,     -- NO 卖单冻结份数 (挂 Sell NO 单时增加)

    -- 时间
    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT uq_positions_user_market         UNIQUE (user_id, market_id),
    CONSTRAINT ck_positions_yes_volume_gte_0    CHECK (yes_volume >= 0),
    CONSTRAINT ck_positions_yes_cost_gte_0      CHECK (yes_cost_sum >= 0),
    CONSTRAINT ck_positions_yes_pending_gte_0   CHECK (yes_pending_sell >= 0),
    CONSTRAINT ck_positions_yes_pending_lte_vol CHECK (yes_pending_sell <= yes_volume),
    CONSTRAINT ck_positions_no_volume_gte_0     CHECK (no_volume >= 0),
    CONSTRAINT ck_positions_no_cost_gte_0       CHECK (no_cost_sum >= 0),
    CONSTRAINT ck_positions_no_pending_gte_0    CHECK (no_pending_sell >= 0),
    CONSTRAINT ck_positions_no_pending_lte_vol  CHECK (no_pending_sell <= no_volume)
);

-- 索引 (UNIQUE 约束自带索引, 额外建一个用户维度)
CREATE INDEX idx_positions_user ON positions (user_id);

-- 触发器
CREATE TRIGGER trg_positions_updated_at
    BEFORE UPDATE ON positions
    FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp();

-- 列注释
COMMENT ON TABLE  positions IS '用户持仓 — 单账本架构, 每用户每话题一行, YES/NO 合并';
COMMENT ON COLUMN positions.yes_volume IS 'YES 持有份数, >= 0';
COMMENT ON COLUMN positions.yes_cost_sum IS 'YES 累计购入成本 (美分), 不使用 avg_cost 避免整数除法精度丢失';
COMMENT ON COLUMN positions.yes_pending_sell IS 'YES 卖单冻结份数, 挂 Sell YES 或 NATIVE_SELL 单时冻结, 可交易量 = yes_volume - yes_pending_sell';
COMMENT ON COLUMN positions.no_volume IS 'NO 持有份数, >= 0';
COMMENT ON COLUMN positions.no_cost_sum IS 'NO 累计购入成本 (美分)';
COMMENT ON COLUMN positions.no_pending_sell IS 'NO 卖单冻结份数, 挂 Sell NO 或 SYNTHETIC_BUY 单时冻结, 可交易量 = no_volume - no_pending_sell';
```

---

### 2.7 ledger_entries — 资金流水表

**业务含义**: 每一笔钱的进出流水账，相当于系统的"银行对账单"。充值、冻结、成交扣款、手续费、Netting 释放、结算派奖——所有资金变动都在这里留下不可篡改的记录。单账本架构下，新增了针对四种撮合场景和挂单冻结的流水类型。
**所属模块**: pm_account
**用途**: 记录每一笔资金变动，Append-Only，是审计和对账的唯一真相源。

```sql
-- ============================================================
-- 表: ledger_entries
-- 模块: pm_account
-- 说明: 资金流水 (Append-Only, 永不 UPDATE/DELETE)
--       所有金额单位: 美分
-- ============================================================
CREATE TABLE ledger_entries (
    -- 主键: 自增, 顺序写入性能最优
    id              BIGSERIAL       PRIMARY KEY,

    -- 所属用户 (含 SYSTEM_RESERVE / PLATFORM_FEE)
    user_id         VARCHAR(64)     NOT NULL,

    -- 流水类型
    entry_type      VARCHAR(30)     NOT NULL,

    -- 金额 (美分): 正数=入账, 负数=出账
    amount          BIGINT          NOT NULL,

    -- 操作后余额快照 (available_balance 快照)
    balance_after   BIGINT          NOT NULL,

    -- 关联
    reference_type  VARCHAR(30),                    -- ORDER / TRADE / MARKET / DEPOSIT / WITHDRAW
    reference_id    VARCHAR(64),                    -- 关联的业务 ID

    -- 描述
    description     VARCHAR(500),

    -- 时间
    created_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    -- 约束 (无 updated_at: Append-Only 表不允许 UPDATE)
    CONSTRAINT ck_ledger_entry_type CHECK (
        entry_type IN (
            -- 充值/提现
            'DEPOSIT',              -- 充值
            'WITHDRAW',             -- 提现
            -- 挂单冻结/解冻 (用户侧)
            'ORDER_FREEZE',         -- 下单冻结 (available → frozen), 挂单时写入
            'ORDER_UNFREEZE',       -- 取消订单解冻 (frozen → available), 撤单时写入
            -- Mint 场景 (用户侧 + 系统侧成对)
            'MINT_COST',            -- 用户侧: 资金扣除进入 Reserve (负数)
            'MINT_RESERVE_IN',      -- 系统侧: SYSTEM_RESERVE 入账 (正数)
            -- Burn 场景 (用户侧 + 系统侧成对)
            'BURN_REVENUE',         -- 用户侧: Reserve 释放资金给用户 (正数)
            'BURN_RESERVE_OUT',     -- 系统侧: SYSTEM_RESERVE 出账 (负数)
            -- Transfer 场景 (用户侧)
            'TRANSFER_PAYMENT',     -- 买方: 付出资金 (负数, 资金离开钱包)
            'TRANSFER_RECEIPT',     -- 卖方: 收入资金 (正数, 资金进入钱包)
            -- Netting (用户侧 + 系统侧成对)
            'NETTING',              -- 用户侧: 净额结算释放 (正数)
            'NETTING_RESERVE_OUT',  -- 系统侧: SYSTEM_RESERVE 出账 (负数)
            -- 手续费 (用户侧 + 系统侧成对)
            'FEE',                  -- 用户侧: 手续费扣除 (负数)
            'FEE_REVENUE',          -- 系统侧: PLATFORM_FEE 入账 (正数)
            -- 结算 (中期)
            'SETTLEMENT_PAYOUT',    -- 市场结算派奖 (中期)
            'SETTLEMENT_VOID'       -- 市场作废退款 (中期)
        )
    ),
    CONSTRAINT ck_ledger_balance_gte_0 CHECK (balance_after >= 0)
);

-- 索引
-- 用户流水查询 (时间倒序翻页)
CREATE INDEX idx_ledger_user_time ON ledger_entries (user_id, created_at DESC);

-- 关联查询 (通过 trade_id 查这笔成交产生的所有流水)
CREATE INDEX idx_ledger_reference ON ledger_entries (reference_type, reference_id)
    WHERE reference_id IS NOT NULL;

-- 对账: 按类型统计
CREATE INDEX idx_ledger_type ON ledger_entries (entry_type, created_at);

-- 列注释
COMMENT ON TABLE  ledger_entries IS '资金流水 — Append-Only, 永不修改/删除, 所有金额单位: 美分';
COMMENT ON COLUMN ledger_entries.amount IS '变动金额 (美分), 正=入账, 负=出账';
COMMENT ON COLUMN ledger_entries.balance_after IS '操作后的 available_balance 快照 (美分)';
COMMENT ON COLUMN ledger_entries.entry_type IS '流水类型: 用户侧(DEPOSIT/WITHDRAW/ORDER_FREEZE/ORDER_UNFREEZE/MINT_COST/BURN_REVENUE/TRANSFER_PAYMENT/TRANSFER_RECEIPT/NETTING/FEE) + 系统侧(MINT_RESERVE_IN/BURN_RESERVE_OUT/NETTING_RESERVE_OUT/FEE_REVENUE) + 结算(SETTLEMENT_*)';
COMMENT ON COLUMN ledger_entries.reference_type IS '关联业务类型: ORDER/TRADE/MARKET/DEPOSIT/WITHDRAW';
COMMENT ON COLUMN ledger_entries.reference_id IS '关联业务 ID, 如 order.id 或 trade.trade_id';
```

**关键规则**:
- **绝对禁止** UPDATE 或 DELETE
- 如果要"撤销"一笔错误记录，写一笔**反向**的新记录（冲正）
- `balance_after` 是写入时的快照，用于审计回放验证

---

### 2.8 wal_events + circuit_breaker_events — 故障恢复与审计表

**业务含义**: 撮合引擎运行时产生的审计日志和熔断事件记录。`wal_events` 记录订单簿的每次变更（入簿、成交、取消等），仅用于事后排查和分析，**不参与崩溃恢复**（恢复策略为 DB 全量重建）。`circuit_breaker_events` 记录每次市场熔断的触发原因和人工解除信息。
**所属模块**: pm_matching
**用途**: 审计日志、故障排查、熔断事件追踪。
**对齐**: 故障恢复设计 v1.1 §4.1、§5.4

```sql
-- ============================================================
-- 表: wal_events
-- 模块: pm_matching
-- 说明: 订单簿变更审计日志 (Append-Only, 不参与崩溃恢复)
-- ============================================================
CREATE TABLE wal_events (
    id              BIGSERIAL       PRIMARY KEY,
    market_id       VARCHAR(64)     NOT NULL,       -- → markets.id
    event_type      VARCHAR(30)     NOT NULL,
    payload         JSONB           NOT NULL,
    created_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW(),

    CONSTRAINT ck_wal_event_type CHECK (
        event_type IN (
            'ORDER_ACCEPTED',
            'ORDER_MATCHED',
            'ORDER_PARTIALLY_FILLED',
            'ORDER_CANCELLED',
            'ORDER_EXPIRED'
        )
    )
);

-- 按 market 和时间查询审计日志
CREATE INDEX idx_wal_market_time ON wal_events (market_id, created_at);

-- 按订单 ID 查找相关事件
CREATE INDEX idx_wal_order_id ON wal_events
    USING GIN ((payload->'order_id'));

-- 列注释
COMMENT ON TABLE wal_events IS '订单簿变更审计日志 — Append-Only, 仅用于事后排查和分析, 不参与崩溃恢复。与业务操作同事务提交';
COMMENT ON COLUMN wal_events.market_id IS '所属话题 ID';
COMMENT ON COLUMN wal_events.event_type IS '事件类型: ORDER_ACCEPTED/ORDER_MATCHED/ORDER_PARTIALLY_FILLED/ORDER_CANCELLED/ORDER_EXPIRED';
COMMENT ON COLUMN wal_events.payload IS '事件详情 (JSONB): order_id, fill_qty, trade_price 等';

-- ============================================================
-- 表: circuit_breaker_events
-- 模块: pm_matching
-- 说明: 熔断事件记录 — 含触发原因和人工解除信息
-- ============================================================
CREATE TABLE circuit_breaker_events (
    id              BIGSERIAL       PRIMARY KEY,
    market_id       VARCHAR(64)     NOT NULL,       -- → markets.id
    trigger_reason  VARCHAR(50)     NOT NULL,
    context         JSONB           NOT NULL DEFAULT '{}',
    resolved_at     TIMESTAMPTZ,
    resolved_by     VARCHAR(50),
    resolution_note TEXT,
    triggered_at    TIMESTAMPTZ     NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_cb_market ON circuit_breaker_events (market_id, triggered_at DESC);

-- 列注释
COMMENT ON TABLE circuit_breaker_events IS '熔断事件记录 — 含触发原因和人工解除信息';
COMMENT ON COLUMN circuit_breaker_events.trigger_reason IS '熔断原因: INVARIANT_RESERVE/INVARIANT_COST_SUM/RECOVERY_FAILED/NEGATIVE_BALANCE 等';
COMMENT ON COLUMN circuit_breaker_events.context IS '触发上下文详情 (JSONB)';
COMMENT ON COLUMN circuit_breaker_events.resolved_at IS '人工解除时间, NULL=尚未解除';
COMMENT ON COLUMN circuit_breaker_events.resolved_by IS '解除操作人';
```

---

## 第三部分：Redis 使用说明

### 3.1 MVP 阶段 Redis 用途

MVP 阶段 Redis **仅用于会话管理和限流**，**不用于余额缓存或冻结操作**。

理由：余额冻结/解冻与 PostgreSQL 事务在同一个原子操作中完成（`UPDATE ... WHERE available >= X RETURNING *`），消除 Redis↔PostgreSQL 双写一致性风险。如果先用 Redis Lua 冻结资金，但 PostgreSQL 事务回滚，Redis 中的资金会被永久冻结。

### 3.2 Redis Key 命名规范

```
{模块}:{实体}:{业务键}:{字段}
```

### 3.3 Redis 数据结构

| Key 模式 | 类型 | 用途 | TTL |
|----------|------|------|-----|
| `ratelimit:{user_id}:{endpoint}` | STRING (计数器) | API 限流 | 60s |
| `session:{session_id}` | HASH | 会话管理 | 配置 |

---

## 第四部分：枚举值完整定义

### 4.1 Python Enum 对照表

```python
# 以下枚举值必须与数据库 CHECK 约束完全一致

class MarketStatus(str, Enum):
    DRAFT = "DRAFT"
    ACTIVE = "ACTIVE"
    SUSPENDED = "SUSPENDED"
    HALTED = "HALTED"
    RESOLVED = "RESOLVED"
    SETTLED = "SETTLED"
    VOIDED = "VOIDED"

# ⭐ 单账本核心枚举
class BookType(str, Enum):
    """订单簿身份: 标识订单在单一 YES 订单簿中的来源和角色"""
    NATIVE_BUY = "NATIVE_BUY"           # Buy YES → Buy YES (不转换)
    NATIVE_SELL = "NATIVE_SELL"          # Sell YES → Sell YES (不转换)
    SYNTHETIC_BUY = "SYNTHETIC_BUY"      # Sell NO → Buy YES @ (100-P)
    SYNTHETIC_SELL = "SYNTHETIC_SELL"     # Buy NO → Sell YES @ (100-P)

class TradeScenario(str, Enum):
    """撮合场景: 由 buy/sell 的 BookType 组合决定"""
    MINT = "MINT"                        # 铸造: Native Buy + Synthetic Sell → 创建 YES/NO 合约对
    TRANSFER_YES = "TRANSFER_YES"        # YES 转手: Native Buy + Native Sell
    TRANSFER_NO = "TRANSFER_NO"          # NO 转手: Synthetic Buy + Synthetic Sell
    BURN = "BURN"                        # 销毁: Synthetic Buy + Native Sell → 销毁 YES/NO 合约对

class FrozenAssetType(str, Enum):
    """冻结资产类型: 撤单时据此解冻到对应账户"""
    FUNDS = "FUNDS"                      # 冻结资金 (美分)
    YES_SHARES = "YES_SHARES"            # 冻结 YES 持仓 (份数)
    NO_SHARES = "NO_SHARES"              # 冻结 NO 持仓 (份数)

class OriginalSide(str, Enum):
    """用户选择的合约方向"""
    YES = "YES"
    NO = "NO"

class OrderDirection(str, Enum):
    """买卖方向 (用户原始意图 + 订单簿视角共用)"""
    BUY = "BUY"
    SELL = "SELL"

class PriceType(str, Enum):
    """定价类型"""
    LIMIT = "LIMIT"

class TimeInForce(str, Enum):
    GTC = "GTC"     # Good Till Cancel
    IOC = "IOC"     # Immediate Or Cancel

class OrderStatus(str, Enum):
    NEW = "NEW"
    OPEN = "OPEN"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"

class LedgerEntryType(str, Enum):
    # 充值/提现
    DEPOSIT = "DEPOSIT"
    WITHDRAW = "WITHDRAW"
    # 挂单冻结/解冻 (用户侧)
    ORDER_FREEZE = "ORDER_FREEZE"
    ORDER_UNFREEZE = "ORDER_UNFREEZE"
    # Mint 场景 (用户侧 + 系统侧成对)
    MINT_COST = "MINT_COST"                     # 用户: 资金扣除进 Reserve (负数)
    MINT_RESERVE_IN = "MINT_RESERVE_IN"         # SYSTEM_RESERVE: 入账 (正数)
    # Burn 场景 (用户侧 + 系统侧成对)
    BURN_REVENUE = "BURN_REVENUE"               # 用户: Reserve 释放资金 (正数)
    BURN_RESERVE_OUT = "BURN_RESERVE_OUT"       # SYSTEM_RESERVE: 出账 (负数)
    # Transfer 场景 (用户侧)
    TRANSFER_PAYMENT = "TRANSFER_PAYMENT"       # 买方: 资金离开钱包 (负数)
    TRANSFER_RECEIPT = "TRANSFER_RECEIPT"        # 卖方: 资金进入钱包 (正数)
    # Netting (用户侧 + 系统侧成对)
    NETTING = "NETTING"                         # 用户: 净额结算释放 (正数)
    NETTING_RESERVE_OUT = "NETTING_RESERVE_OUT" # SYSTEM_RESERVE: 出账 (负数)
    # 手续费 (用户侧 + 系统侧成对)
    FEE = "FEE"                                 # 用户: 手续费扣除 (负数)
    FEE_REVENUE = "FEE_REVENUE"                 # PLATFORM_FEE: 入账 (正数)
    # 结算 (中期)
    SETTLEMENT_PAYOUT = "SETTLEMENT_PAYOUT"
    SETTLEMENT_VOID = "SETTLEMENT_VOID"

class ResolutionResult(str, Enum):
    YES = "YES"
    NO = "NO"
    VOID = "VOID"
```

---

## 第五部分：数据完整性规则（单账本不变量）

### 5.1 话题级不变量 1：份数平衡

对于每个活跃话题，在任意时刻：

```
total_yes_shares = total_no_shares
```

由数据库 CHECK 约束 `ck_markets_shares_balanced` 强制保证。

验证 SQL：
```sql
-- 不变量 1: 份数平衡校验
SELECT
    id,
    total_yes_shares,
    total_no_shares,
    total_yes_shares = total_no_shares AS is_balanced
FROM markets
WHERE status NOT IN ('SETTLED', 'VOIDED');
```

### 5.2 话题级不变量 2：托管平衡

对于每个活跃话题，在任意时刻：

```
reserve_balance = total_yes_shares × 100
```

由数据库 CHECK 约束 `ck_markets_reserve_consistency` 强制保证。

验证 SQL：
```sql
-- 不变量 2: 托管平衡校验
SELECT
    id,
    reserve_balance,
    total_yes_shares * 100 AS expected_reserve,
    reserve_balance = total_yes_shares * 100 AS is_consistent
FROM markets
WHERE status NOT IN ('SETTLED', 'VOIDED');
```

### 5.3 话题级不变量 3：成本守恒

对于每个活跃话题，在任意时刻：

```
reserve_balance + pnl_pool = Σ(该话题所有用户的 yes_cost_sum + no_cost_sum)
```

验证 SQL：
```sql
-- 不变量 3: 成本守恒校验
WITH market_costs AS (
    SELECT
        p.market_id,
        COALESCE(SUM(p.yes_cost_sum + p.no_cost_sum), 0) AS total_cost_sum
    FROM positions p
    GROUP BY p.market_id
)
SELECT
    m.id,
    m.reserve_balance,
    m.pnl_pool,
    m.reserve_balance + m.pnl_pool AS reserve_plus_pnl,
    COALESCE(mc.total_cost_sum, 0) AS total_cost_sum,
    (m.reserve_balance + m.pnl_pool) = COALESCE(mc.total_cost_sum, 0) AS is_conserved
FROM markets m
LEFT JOIN market_costs mc ON mc.market_id = m.id
WHERE m.status NOT IN ('SETTLED', 'VOIDED');
```

### 5.4 全局零和校验（含手续费）

在任意时刻：

```
Σ(所有用户 available + frozen) + SYSTEM_RESERVE.available + PLATFORM_FEE.available
= Σ(DEPOSIT) - Σ(|WITHDRAW|)
```

验证 SQL：
```sql
-- 全局零和校验
WITH user_totals AS (
    SELECT SUM(available_balance + frozen_balance) AS total_user_funds
    FROM accounts
    WHERE user_id NOT IN ('SYSTEM_RESERVE', 'PLATFORM_FEE')
),
system_accounts AS (
    SELECT
        SUM(CASE WHEN user_id = 'SYSTEM_RESERVE' THEN available_balance ELSE 0 END) AS reserve_balance,
        SUM(CASE WHEN user_id = 'PLATFORM_FEE' THEN available_balance ELSE 0 END) AS fee_balance
    FROM accounts
    WHERE user_id IN ('SYSTEM_RESERVE', 'PLATFORM_FEE')
),
flows AS (
    SELECT
        COALESCE(SUM(CASE WHEN entry_type = 'DEPOSIT' THEN amount ELSE 0 END), 0) AS total_deposits,
        COALESCE(SUM(CASE WHEN entry_type = 'WITHDRAW' THEN amount ELSE 0 END), 0) AS total_withdrawals
    FROM ledger_entries
    WHERE user_id NOT IN ('SYSTEM_RESERVE', 'PLATFORM_FEE')
)
SELECT
    ut.total_user_funds,
    sa.reserve_balance,
    sa.fee_balance,
    ut.total_user_funds + sa.reserve_balance + sa.fee_balance AS actual_total,
    f.total_deposits + f.total_withdrawals AS expected_total,
    (ut.total_user_funds + sa.reserve_balance + sa.fee_balance)
        = (f.total_deposits + f.total_withdrawals) AS is_zero_sum
FROM user_totals ut, system_accounts sa, flows f;
```

### 5.5 SYSTEM_RESERVE 与话题级 Reserve 一致性

```
SYSTEM_RESERVE.available_balance = Σ(所有活跃话题的 reserve_balance)
```

验证 SQL：
```sql
-- Reserve 一致性校验
WITH reserve_account AS (
    SELECT available_balance AS global_reserve
    FROM accounts
    WHERE user_id = 'SYSTEM_RESERVE'
),
market_reserves AS (
    SELECT COALESCE(SUM(reserve_balance), 0) AS total_market_reserve
    FROM markets
    WHERE status NOT IN ('SETTLED', 'VOIDED')
)
SELECT
    ra.global_reserve,
    mr.total_market_reserve,
    ra.global_reserve = mr.total_market_reserve AS is_consistent
FROM reserve_account ra, market_reserves mr;
```

### 5.6 订单字段一致性

由 CHECK 约束强制: `filled_quantity + remaining_quantity = quantity`

### 5.7 Append-Only 表保护

`ledger_entries` 表不设 `updated_at`，且应用层代码中不允许出现 UPDATE/DELETE 语句操作此表。可在 PostgreSQL 级别用 Rule 防护（生产环境）：

```sql
-- 生产环境: 禁止 UPDATE/DELETE ledger_entries
CREATE RULE rule_no_update_ledger AS ON UPDATE TO ledger_entries DO INSTEAD NOTHING;
CREATE RULE rule_no_delete_ledger AS ON DELETE TO ledger_entries DO INSTEAD NOTHING;
```

---

## 第六部分：种子数据

### 6.1 系统初始化数据

```sql
-- 1. 系统 Reserve 账户 (全平台资金托管总池)
INSERT INTO accounts (user_id, available_balance, frozen_balance, version)
VALUES ('SYSTEM_RESERVE', 0, 0, 0);

-- 2. 平台手续费账户 (累计收取的全部手续费)
INSERT INTO accounts (user_id, available_balance, frozen_balance, version)
VALUES ('PLATFORM_FEE', 0, 0, 0);

-- 3. 示例话题
INSERT INTO markets (id, title, description, category, status,
                     min_price_cents, max_price_cents,
                     max_order_quantity, max_position_per_user, max_order_amount_cents,
                     maker_fee_bps, taker_fee_bps,
                     trading_start_at, resolution_date)
VALUES
    ('MKT-BTC-100K-2026',
     'Will BTC exceed $100,000 by end of 2026?',
     'Resolves YES if Bitcoin price exceeds $100,000 on any major exchange before 2027-01-01 00:00 UTC.',
     'crypto', 'ACTIVE',
     1, 99,
     10000, 25000, 1000000,
     10, 20,
     '2026-01-01T00:00:00Z', '2026-12-31T23:59:59Z'),

    ('MKT-ETH-10K-2026',
     'Will ETH exceed $10,000 by end of 2026?',
     'Resolves YES if Ethereum price exceeds $10,000 on any major exchange before 2027-01-01 00:00 UTC.',
     'crypto', 'ACTIVE',
     1, 99,
     10000, 25000, 1000000,
     10, 20,
     '2026-01-01T00:00:00Z', '2026-12-31T23:59:59Z'),

    ('MKT-FED-RATE-CUT-2026Q2',
     'Will the Fed cut rates in Q2 2026?',
     'Resolves YES if the Federal Reserve announces a rate cut at any FOMC meeting in April, May, or June 2026.',
     'economics', 'ACTIVE',
     1, 99,
     10000, 25000, 1000000,
     10, 20,
     '2026-01-01T00:00:00Z', '2026-06-30T23:59:59Z');
```

---

## 第七部分：SQLAlchemy ORM 映射指南

### 7.1 类型映射

| PostgreSQL | SQLAlchemy | Python |
|------------|------------|--------|
| `UUID` | `Uuid` (SA 2.0) | `uuid.UUID` |
| `VARCHAR(N)` | `String(N)` | `str` |
| `SMALLINT` | `SmallInteger` | `int` |
| `INT` / `INTEGER` | `Integer` | `int` |
| `BIGINT` | `BigInteger` | `int` |
| `BIGSERIAL` | `BigInteger, autoincrement=True` | `int` |
| `BOOLEAN` | `Boolean` | `bool` |
| `TEXT` | `Text` | `str` |
| `TIMESTAMPTZ` | `DateTime(timezone=True)` | `datetime.datetime` |

### 7.2 ORM 模型示例 — Position (单账本)

```python
# 示例: PositionModel (pm_account/infrastructure/db_models.py)
from sqlalchemy import BigInteger, Integer, String, DateTime, text
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
import uuid

class PositionModel(Base):
    __tablename__ = "positions"

    id: Mapped[uuid.UUID] = mapped_column(
        Uuid, primary_key=True, server_default=text("gen_random_uuid()")
    )
    user_id: Mapped[str] = mapped_column(String(64), nullable=False)
    market_id: Mapped[str] = mapped_column(String(64), nullable=False)

    # YES 持仓
    yes_volume: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    yes_cost_sum: Mapped[int] = mapped_column(BigInteger, nullable=False, default=0)
    yes_pending_sell: Mapped[int] = mapped_column(Integer, nullable=False, default=0)

    # NO 持仓
    no_volume: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    no_cost_sum: Mapped[int] = mapped_column(BigInteger, nullable=False, default=0)
    no_pending_sell: Mapped[int] = mapped_column(Integer, nullable=False, default=0)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=text("NOW()")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=text("NOW()")
    )
```

### 7.3 重要注意事项

- ORM 模型中**不定义** `relationship()`（MVP 无 FK）
- CHECK 约束写在 DDL/Migration 中，ORM 层不重复
- `server_default` 用于数据库级默认值，`default` 用于 Python 级
- 所有金额字段类型统一为 `Mapped[int]` + `BigInteger`
- 所有持仓量字段为 `Mapped[int]` + `Integer`

---

## 第八部分：表关系总览（逻辑 ER 图）

```
users (1) ──── (1) accounts           用户注册时自动创建 account
  │
  │ (1:N)
  ├──── orders                        用户下单
  │       │                           含 original_* (用户意图) + book_* (订单簿视角)
  │       │ (N:1)                     含 frozen_amount + frozen_asset_type
  │       └──── markets               订单属于某个话题
  │
  │ (1:N)
  ├──── positions                     用户在话题中的持仓 (YES/NO 合并行)
  │       │                           含 yes_volume/cost_sum/pending_sell
  │       │ (N:1)                     含 no_volume/cost_sum/pending_sell
  │       └──── markets
  │
  │ (1:N)
  └──── ledger_entries                用户资金流水

orders (buy) ───┐
                ├──── trades          一笔成交关联 buy + sell 两笔订单
orders (sell) ──┘                     含 scenario (MINT/TRANSFER/BURN)
                                      含 buy/sell_book_type

markets ──── reserve_balance          话题级 Reserve (Mint +, Burn/Netting -)
         ──── pnl_pool                话题级盈亏池 (Transfer 盈亏沉淀)
         ──── total_yes/no_shares     话题级合约总份数

SYSTEM_RESERVE ──── accounts          全平台资金托管总池 (= Σ reserve_balance)
PLATFORM_FEE ───── accounts           平台手续费累计账户

markets ──── wal_events               订单簿变更审计日志 (不参与恢复)
markets ──── circuit_breaker_events   熔断事件记录
```

---

## 附录 A：全部表索引汇总

| 表 | 索引名 | 列 | 类型 | 用途 |
|----|--------|-----|------|------|
| users | uq_users_username | username | UNIQUE | 登录查重 |
| users | uq_users_email | email | UNIQUE | 注册查重 |
| users | idx_users_email | email | B-tree | 邮箱登录查询 |
| accounts | uq_accounts_user_id | user_id | UNIQUE | 用户唯一账户 |
| markets | idx_markets_status | status | B-tree | 按状态筛选话题 |
| orders | uq_orders_client_order_id | client_order_id | UNIQUE | 幂等 |
| orders | idx_orders_user_status | user_id, status, created_at DESC | B-tree | 我的订单列表 |
| orders | idx_orders_market_active | market_id, created_at (partial) | B-tree | 撮合恢复 (DB全量重建) |
| orders | idx_orders_self_trade | market_id, user_id, book_direction (partial) | B-tree | 自成交检查 |
| trades | uq_trades_trade_id | trade_id | UNIQUE | 成交去重 |
| trades | idx_trades_buy_user | buy_user_id, executed_at DESC | B-tree | 买方成交历史 |
| trades | idx_trades_sell_user | sell_user_id, executed_at DESC | B-tree | 卖方成交历史 |
| trades | idx_trades_market_time | market_id, executed_at DESC | B-tree | 行情/K线 |
| trades | idx_trades_scenario | market_id, scenario | B-tree | 按场景统计 |
| positions | uq_positions_user_market | user_id, market_id | UNIQUE | 持仓唯一 |
| positions | idx_positions_user | user_id | B-tree | 用户持仓列表 |
| ledger_entries | idx_ledger_user_time | user_id, created_at DESC | B-tree | 用户流水翻页 |
| ledger_entries | idx_ledger_reference | reference_type, reference_id (partial) | B-tree | 关联查询 |
| ledger_entries | idx_ledger_type | entry_type, created_at | B-tree | 对账统计 |
| wal_events | idx_wal_market_time | market_id, created_at | B-tree | 按话题查审计日志 |
| wal_events | idx_wal_order_id | (payload->'order_id') | GIN | 按订单查审计事件 |
| circuit_breaker_events | idx_cb_market | market_id, triggered_at DESC | B-tree | 查熔断历史 |

---

## 附录 B：Alembic 迁移文件命名规范

```
alembic/versions/
├── 001_create_common_functions.py     # fn_update_timestamp()
├── 002_create_users.py
├── 003_create_accounts.py
├── 004_create_markets.py              # 含单账本托管字段
├── 005_create_orders.py               # 含单账本转换字段 + frozen_asset_type
├── 006_create_trades.py               # 含 scenario + buy/sell_book_type
├── 007_create_positions.py            # YES/NO 合并行
├── 008_create_ledger_entries.py       # 含单账本流水类型
├── 009_create_wal_events.py           # WAL 审计日志表
├── 010_create_circuit_breaker_events.py  # 熔断事件表
└── 011_seed_initial_data.py           # SYSTEM_RESERVE + PLATFORM_FEE + 示例话题
```

每个迁移文件只负责一张表，方便回滚和调试。

---

## 附录 C：v1.1 → v2.0 修正对照表

| v1.1 设计 | v2.0 (单账本) | 理由 |
|-----------|-------------|------|
| `SYSTEM_RESERVE` 单一全局托管 | `SYSTEM_RESERVE` + `PLATFORM_FEE` 两个系统账户 | 手续费独立追踪，参与全局零和 |
| markets: `total_matched_pairs` + `escrowed_cents` | `reserve_balance` + `pnl_pool` + `total_yes_shares` + `total_no_shares` | 对齐单账本四种场景的 Reserve 和盈亏追踪 |
| orders: `contract_type` + `side` + `order_type` | `original_side/direction/price` + `book_type/direction/price` + `price_type` | 单账本需同时记录用户意图和订单簿视角 |
| orders: 无冻结信息 | `frozen_amount` + `frozen_asset_type` | 撤单时明确解冻资产类型，防资金↔持仓混淆 |
| trades: `contract_type` + `maker/taker` | `scenario` + `buy/sell_order_id` + `buy/sell_book_type` | 四种场景决定清算流向，按订单簿方向记录 |
| positions: `(user, market, contract_type)` 三元组 | `(user, market)` 二元组, YES/NO 合并行 | 对齐 exchange-core PositionRecord，一行管双边 |
| positions: `avg_entry_price` | `yes_cost_sum` + `no_cost_sum` | 避免整数除法精度丢失 |
| positions: 无卖单冻结 | `yes_pending_sell` + `no_pending_sell` | 卖单需冻结持仓，防止超卖 |
| ledger: `TRADE_COST/TRADE_REVENUE` | `MINT_COST/BURN_REVENUE/TRANSFER_IN/TRANSFER_OUT` + `ORDER_FREEZE/ORDER_UNFREEZE` | 按场景细分流水类型 + 挂单冻结可追溯 |
| Redis: 余额缓存 + Lua 原子冻结 | Redis 仅用于限流/会话，余额纯走 PostgreSQL | 消除双写一致性风险 |
| 零和 = 用户 + Reserve | 零和 = 用户 + Reserve + Fee | 手续费是系统资金，必须参与零和 |
| 2 条不变量 | 5 条不变量 (3 话题级 + 1 全局零和 + 1 Reserve 一致性) | 单账本有更严格的守恒要求 |
| 全局乐观锁 | 按市场分片锁 + PostgreSQL 原子操作 | 话题间隔离，避免全局串行瓶颈 |

---

*文档版本: v2.3 (单账本撮合引擎架构) | 生成日期: 2026-02-20 | 状态: 待 Review*
*v2.0 变更: 全面对齐单账本撮合引擎架构 — 见附录 C 完整对照表*
*v2.1 变更: 流水复式记账(系统侧成对流水) + TRANSFER命名修正(PAYMENT/RECEIPT) + book_type↔book_direction一致性约束 + frozen_amount部分成交扣减规则*
*v2.2 变更: trades表新增 buy_realized_pnl/sell_realized_pnl 双向已实现盈亏字段(清算时持久化)*
*v2.3 变更: 移除冗余tick_size_cents字段 + 新增§2.8故障恢复审计表(wal_events/circuit_breaker_events) + idx_orders_market_active索引列对齐故障恢复v1.1*
